"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/../../node_modules/remotion/dist/esm/index.mjs":
/*!******************************************************!*\
  !*** ../../node_modules/remotion/dist/esm/index.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   AnimatedImage: () => (/* binding */ AnimatedImage),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true,\n        configurable: true,\n        set: (newValue)=>all[name] = ()=>newValue\n    });\n};\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n    const err = [\n        'Remotion requires React.createContext, but it is \"undefined\".',\n        'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n        \"\",\n        \"Before:\",\n        '  import {useCurrentFrame} from \"remotion\";',\n        \"\",\n        \"After:\",\n        '  \"use client\";',\n        '  import {useCurrentFrame} from \"remotion\";'\n    ];\n    throw new Error(err.join(`\n`));\n}\n// src/Clipper.tsx\nvar Clipper = ()=>{\n    throw new Error(\"<Clipper> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n// src/enable-sequence-stack-traces.ts\n\n// src/get-remotion-environment.ts\nfunction getNodeEnvString() {\n    return [\n        \"NOD\",\n        \"E_EN\",\n        \"V\"\n    ].join(\"\");\n}\nvar getEnvString = ()=>{\n    return [\n        \"e\",\n        \"nv\"\n    ].join(\"\");\n};\nvar getRemotionEnvironment = ()=>{\n    const isPlayer =  false && 0;\n    const isRendering =  false && (0);\n    const isStudio =  false && 0;\n    const isReadOnlyStudio =  false && 0;\n    return {\n        isStudio,\n        isRendering,\n        isPlayer,\n        isReadOnlyStudio\n    };\n};\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar componentsToAddStacksTo = [];\nvar enableSequenceStackTraces = ()=>{\n    if (!getRemotionEnvironment().isStudio) {\n        return;\n    }\n    const proxy = new Proxy(originalCreateElement, {\n        apply (target, thisArg, argArray) {\n            if (componentsToAddStacksTo.includes(argArray[0])) {\n                const [first, props, ...rest] = argArray;\n                const newProps = {\n                    ...props ?? {},\n                    stack: new Error().stack\n                };\n                return Reflect.apply(target, thisArg, [\n                    first,\n                    newProps,\n                    ...rest\n                ]);\n            }\n            return Reflect.apply(target, thisArg, argArray);\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement = proxy;\n};\nvar addSequenceStackTraces = (component)=>{\n    componentsToAddStacksTo.push(component);\n    enableSequenceStackTraces();\n};\n// src/is-player.tsx\n\n\nvar IsPlayerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar useIsPlayer = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/version.ts\nvar VERSION = \"4.0.290\";\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = ()=>{\n    if (typeof globalThis === \"undefined\") {\n        return;\n    }\n    const set = ()=>{\n        globalThis.remotion_imported = VERSION;\n        if (false) {}\n    };\n    const alreadyImported = globalThis.remotion_imported ||  false && 0;\n    if (alreadyImported) {\n        if (alreadyImported === VERSION) {\n            return;\n        }\n        if (typeof alreadyImported === \"string\" && alreadyImported.includes(\"webcodecs\")) {\n            set();\n            return;\n        }\n        throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n            VERSION,\n            typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n        ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n    }\n    set();\n};\n// src/Null.tsx\nvar Null = ()=>{\n    throw new Error(\"<Null> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n// src/Sequence.tsx\n\n// src/AbsoluteFill.tsx\n\n\nvar hasTailwindClassName = (className, classPrefix)=>{\n    if (!className) {\n        return false;\n    }\n    return classPrefix.some((prefix)=>{\n        return className.startsWith(prefix) || className.includes(` ${prefix}`) || className.includes(`:${prefix}`);\n    });\n};\nvar AbsoluteFillRefForwarding = (props, ref)=>{\n    const { style, ...other } = props;\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AbsoluteFillRefForwarding.useMemo[actualStyle]\": ()=>{\n            return {\n                position: \"absolute\",\n                top: hasTailwindClassName(other.className, [\n                    \"top-\",\n                    \"inset-\"\n                ]) ? undefined : 0,\n                left: hasTailwindClassName(other.className, [\n                    \"left-\",\n                    \"inset-\"\n                ]) ? undefined : 0,\n                right: hasTailwindClassName(other.className, [\n                    \"right-\",\n                    \"inset-\"\n                ]) ? undefined : 0,\n                bottom: hasTailwindClassName(other.className, [\n                    \"bottom-\",\n                    \"inset-\"\n                ]) ? undefined : 0,\n                width: hasTailwindClassName(other.className, [\n                    \"w-\"\n                ]) ? undefined : \"100%\",\n                height: hasTailwindClassName(other.className, [\n                    \"h-\"\n                ]) ? undefined : \"100%\",\n                display: hasTailwindClassName(other.className, [\n                    \"block\",\n                    \"inline-block\",\n                    \"inline\",\n                    \"flex\",\n                    \"inline-flex\",\n                    \"flow-root\",\n                    \"grid\",\n                    \"inline-grid\",\n                    \"contents\",\n                    \"list-item\",\n                    \"hidden\"\n                ]) ? undefined : \"flex\",\n                flexDirection: hasTailwindClassName(other.className, [\n                    \"flex-row\",\n                    \"flex-col\",\n                    \"flex-row-reverse\",\n                    \"flex-col-reverse\"\n                ]) ? undefined : \"column\",\n                ...style\n            };\n        }\n    }[\"AbsoluteFillRefForwarding.useMemo[actualStyle]\"], [\n        other.className,\n        style\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref,\n        style: actualStyle,\n        ...other\n    });\n};\nvar AbsoluteFill = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n// src/SequenceContext.tsx\n\nvar SequenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    registerSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    unregisterSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    sequences: []\n});\nvar SequenceVisibilityToggleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    hidden: {},\n    setHidden: ()=>{\n        throw new Error(\"SequenceVisibilityToggle not initialized\");\n    }\n});\nvar SequenceManagerProvider = ({ children })=>{\n    const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SequenceManagerProvider.useCallback[registerSequence]\": (seq)=>{\n            setSequences({\n                \"SequenceManagerProvider.useCallback[registerSequence]\": (seqs)=>{\n                    return [\n                        ...seqs,\n                        seq\n                    ];\n                }\n            }[\"SequenceManagerProvider.useCallback[registerSequence]\"]);\n        }\n    }[\"SequenceManagerProvider.useCallback[registerSequence]\"], []);\n    const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SequenceManagerProvider.useCallback[unregisterSequence]\": (seq)=>{\n            setSequences({\n                \"SequenceManagerProvider.useCallback[unregisterSequence]\": (seqs)=>seqs.filter({\n                        \"SequenceManagerProvider.useCallback[unregisterSequence]\": (s)=>s.id !== seq\n                    }[\"SequenceManagerProvider.useCallback[unregisterSequence]\"])\n            }[\"SequenceManagerProvider.useCallback[unregisterSequence]\"]);\n        }\n    }[\"SequenceManagerProvider.useCallback[unregisterSequence]\"], []);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SequenceManagerProvider.useMemo2[sequenceContext]\": ()=>{\n            return {\n                registerSequence,\n                sequences,\n                unregisterSequence\n            };\n        }\n    }[\"SequenceManagerProvider.useMemo2[sequenceContext]\"], [\n        registerSequence,\n        sequences,\n        unregisterSequence\n    ]);\n    const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SequenceManagerProvider.useMemo2[hiddenContext]\": ()=>{\n            return {\n                hidden,\n                setHidden\n            };\n        }\n    }[\"SequenceManagerProvider.useMemo2[hiddenContext]\"], [\n        hidden\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n        value: sequenceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n            value: hiddenContext,\n            children\n        })\n    });\n};\n// src/nonce.ts\n\nvar NonceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    getNonce: ()=>0,\n    fastRefreshes: 0\n});\nvar useNonce = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useNonce.useState2\": ()=>context.getNonce()\n    }[\"useNonce.useState2\"]);\n    const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNonce.useEffect\": ()=>{\n            if (lastContext.current === context) {\n                return;\n            }\n            lastContext.current = context;\n            setNonce(context.getNonce);\n        }\n    }[\"useNonce.useEffect\"], [\n        context\n    ]);\n    return nonce;\n};\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n    useTimelineSetFrame: ()=>useTimelineSetFrame,\n    useTimelinePosition: ()=>useTimelinePosition,\n    usePlayingState: ()=>usePlayingState,\n    persistCurrentFrame: ()=>persistCurrentFrame,\n    getInitialFrameState: ()=>getInitialFrameState,\n    getFrameForComposition: ()=>getFrameForComposition,\n    TimelineContext: ()=>TimelineContext,\n    SetTimelineContext: ()=>SetTimelineContext\n});\n\n// src/use-video.ts\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    compositions: [],\n    folders: [],\n    currentCompositionMetadata: null,\n    canvasContent: null\n});\nvar CompositionSetters = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerComposition: ()=>{\n        return;\n    },\n    unregisterComposition: ()=>{\n        return;\n    },\n    registerFolder: ()=>{\n        return;\n    },\n    unregisterFolder: ()=>{\n        return;\n    },\n    setCanvasContent: ()=>{\n        return;\n    },\n    updateCompositionDefaultProps: ()=>{\n        return;\n    },\n    onlyRenderComposition: null\n});\n// src/ResolveCompositionConfig.tsx\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    props: {},\n    updateProps: ()=>{\n        throw new Error(\"Not implemented\");\n    },\n    resetUnsaved: ()=>{\n        throw new Error(\"Not implemented\");\n    }\n});\nvar editorPropsProviderRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar timeValueRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children })=>{\n    const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"EditorPropsProvider.useCallback2[updateProps]\": ({ defaultProps, id, newProps })=>{\n            setProps({\n                \"EditorPropsProvider.useCallback2[updateProps]\": (prev)=>{\n                    return {\n                        ...prev,\n                        [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n                    };\n                }\n            }[\"EditorPropsProvider.useCallback2[updateProps]\"]);\n        }\n    }[\"EditorPropsProvider.useCallback2[updateProps]\"], []);\n    const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"EditorPropsProvider.useCallback2[resetUnsaved]\": ()=>{\n            setProps({});\n        }\n    }[\"EditorPropsProvider.useCallback2[resetUnsaved]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, {\n        \"EditorPropsProvider.useImperativeHandle\": ()=>{\n            return {\n                getProps: ({\n                    \"EditorPropsProvider.useImperativeHandle\": ()=>props\n                })[\"EditorPropsProvider.useImperativeHandle\"],\n                setProps\n            };\n        }\n    }[\"EditorPropsProvider.useImperativeHandle\"], [\n        props\n    ]);\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"EditorPropsProvider.useMemo3[ctx]\": ()=>{\n            return {\n                props,\n                updateProps,\n                resetUnsaved\n            };\n        }\n    }[\"EditorPropsProvider.useMemo3[ctx]\"], [\n        props,\n        resetUnsaved,\n        updateProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n        value: ctx,\n        children\n    });\n};\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithCustomFields = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n        }\n        return value;\n    });\n};\nvar serializeThenDeserialize = (props)=>{\n    return deserializeJSONWithCustomFields(serializeJSONWithDate({\n        data: props,\n        indent: 2,\n        staticBase: window.remotion_staticBase\n    }).serializedString);\n};\nvar serializeThenDeserializeInStudio = (props)=>{\n    if (getRemotionEnvironment().isStudio) {\n        return serializeThenDeserialize(props);\n    }\n    return props;\n};\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = ()=>{\n    if (didWarnSSRImport) {\n        return;\n    }\n    didWarnSSRImport = true;\n    console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n    console.warn(\"To hide this warning, don't call this function on the server:\");\n    console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = ()=>{\n    if (true) {\n        warnOnceSSRImport();\n        return {};\n    }\n    if (getRemotionEnvironment().isPlayer) {\n        throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n    }\n    const param = window.remotion_inputProps;\n    if (!param) {\n        return {};\n    }\n    const parsed = deserializeJSONWithCustomFields(param);\n    return parsed;\n};\n// src/codec.ts\nvar validCodecs = [\n    \"h264\",\n    \"h265\",\n    \"vp8\",\n    \"vp9\",\n    \"mp3\",\n    \"aac\",\n    \"wav\",\n    \"prores\",\n    \"h264-mkv\",\n    \"h264-ts\",\n    \"gif\"\n];\n// src/validation/validate-default-codec.ts\nfunction validateDefaultCodec(defaultCodec, location) {\n    if (typeof defaultCodec === \"undefined\") {\n        return;\n    }\n    if (typeof defaultCodec !== \"string\") {\n        throw new TypeError(`The \"defaultCodec\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n    }\n    if (!validCodecs.includes(defaultCodec)) {\n        throw new Error(`The \"defaultCodec\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n    }\n}\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/resolve-video-config.ts\nvar validateCalculated = ({ calculated, compositionId, compositionFps, compositionHeight, compositionWidth, compositionDurationInFrames })=>{\n    const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n    const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n    const width = calculated?.width ?? compositionWidth ?? undefined;\n    validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const height = calculated?.height ?? compositionHeight ?? undefined;\n    validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const fps = calculated?.fps ?? compositionFps ?? null;\n    validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n    const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n    validateDurationInFrames(durationInFrames, {\n        allowFloats: false,\n        component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n    });\n    const defaultCodec = calculated?.defaultCodec;\n    validateDefaultCodec(defaultCodec, calculateMetadataErrorLocation);\n    const defaultOutName = calculated?.defaultOutName;\n    return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        defaultCodec,\n        defaultOutName\n    };\n};\nvar resolveVideoConfig = ({ calculateMetadata, signal, defaultProps, originalProps, compositionId, compositionDurationInFrames, compositionFps, compositionHeight, compositionWidth })=>{\n    const calculatedProm = calculateMetadata ? calculateMetadata({\n        defaultProps,\n        props: originalProps,\n        abortSignal: signal,\n        compositionId\n    }) : null;\n    if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n        return calculatedProm.then((c)=>{\n            const { height, width, durationInFrames, fps, defaultCodec, defaultOutName } = validateCalculated({\n                calculated: c,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth,\n                compositionId\n            });\n            return {\n                width,\n                height,\n                fps,\n                durationInFrames,\n                id: compositionId,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps),\n                props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n                defaultCodec: defaultCodec ?? null,\n                defaultOutName: defaultOutName ?? null\n            };\n        });\n    }\n    const data = validateCalculated({\n        calculated: calculatedProm,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n    });\n    if (calculatedProm === null) {\n        return {\n            ...data,\n            id: compositionId,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            props: serializeThenDeserializeInStudio(originalProps),\n            defaultCodec: null,\n            defaultOutName: null\n        };\n    }\n    return {\n        ...data,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n        props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n        defaultCodec: calculatedProm.defaultCodec ?? null,\n        defaultOutName: calculatedProm.defaultOutName ?? null\n    };\n};\nvar resolveVideoConfigOrCatch = (params)=>{\n    try {\n        const promiseOrReturnValue = resolveVideoConfig(params);\n        return {\n            type: \"success\",\n            result: promiseOrReturnValue\n        };\n    } catch (err) {\n        return {\n            type: \"error\",\n            error: err\n        };\n    }\n};\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition)=>{\n    return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfig = ({ children })=>{\n    const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const { fastRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[selectedComposition]\": ()=>{\n            return compositions.find({\n                \"ResolveCompositionConfig.useMemo4[selectedComposition]\": (c)=>canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id\n            }[\"ResolveCompositionConfig.useMemo4[selectedComposition]\"]);\n        }\n    }[\"ResolveCompositionConfig.useMemo4[selectedComposition]\"], [\n        canvasContent,\n        compositions\n    ]);\n    const renderModalComposition = compositions.find((c)=>c.id === currentRenderModalComposition);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[inputProps]\": ()=>{\n            return  true ? {} : 0;\n        }\n    }[\"ResolveCompositionConfig.useMemo4[inputProps]\"], []);\n    const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[selectedEditorProps]\": ()=>{\n            return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n        }\n    }[\"ResolveCompositionConfig.useMemo4[selectedEditorProps]\"], [\n        allEditorProps,\n        selectedComposition\n    ]);\n    const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[renderModalProps]\": ()=>{\n            return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n        }\n    }[\"ResolveCompositionConfig.useMemo4[renderModalProps]\"], [\n        allEditorProps,\n        renderModalComposition\n    ]);\n    const hasResolution = Boolean(currentCompositionMetadata);\n    const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ResolveCompositionConfig.useCallback3[doResolution]\": ({ calculateMetadata, combinedProps, compositionDurationInFrames, compositionFps, compositionHeight, compositionId, compositionWidth, defaultProps })=>{\n            const controller = new AbortController;\n            if (hasResolution) {\n                return controller;\n            }\n            const { signal } = controller;\n            const result = resolveVideoConfigOrCatch({\n                compositionId,\n                calculateMetadata,\n                originalProps: combinedProps,\n                signal,\n                defaultProps,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth\n            });\n            if (result.type === \"error\") {\n                setResolvedConfigs({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                            ...r,\n                            [compositionId]: {\n                                type: \"error\",\n                                error: result.error\n                            }\n                        })\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                return controller;\n            }\n            const promOrNot = result.result;\n            if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n                setResolvedConfigs({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>{\n                        const prev = r[compositionId];\n                        if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n                            return {\n                                ...r,\n                                [compositionId]: {\n                                    type: \"success-and-refreshing\",\n                                    result: prev.result\n                                }\n                            };\n                        }\n                        return {\n                            ...r,\n                            [compositionId]: {\n                                type: \"loading\"\n                            }\n                        };\n                    }\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                promOrNot.then({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (c)=>{\n                        if (controller.signal.aborted) {\n                            return;\n                        }\n                        setResolvedConfigs({\n                            \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                                    ...r,\n                                    [compositionId]: {\n                                        type: \"success\",\n                                        result: c\n                                    }\n                                })\n                        }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                    }\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]).catch({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (err)=>{\n                        if (controller.signal.aborted) {\n                            return;\n                        }\n                        setResolvedConfigs({\n                            \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                                    ...r,\n                                    [compositionId]: {\n                                        type: \"error\",\n                                        error: err\n                                    }\n                                })\n                        }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                    }\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n            } else {\n                setResolvedConfigs({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                            ...r,\n                            [compositionId]: {\n                                type: \"success\",\n                                result: promOrNot\n                            }\n                        })\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n            }\n            return controller;\n        }\n    }[\"ResolveCompositionConfig.useCallback3[doResolution]\"], [\n        hasResolution\n    ]);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, {\n        \"ResolveCompositionConfig.useImperativeHandle2\": ()=>{\n            return {\n                setCurrentRenderModalComposition: ({\n                    \"ResolveCompositionConfig.useImperativeHandle2\": (id)=>{\n                        setCurrentRenderModalComposition(id);\n                    }\n                })[\"ResolveCompositionConfig.useImperativeHandle2\"],\n                reloadCurrentlySelectedComposition: ({\n                    \"ResolveCompositionConfig.useImperativeHandle2\": ()=>{\n                        if (!currentComposition) {\n                            return;\n                        }\n                        const composition = compositions.find({\n                            \"ResolveCompositionConfig.useImperativeHandle2.composition\": (c)=>c.id === currentComposition\n                        }[\"ResolveCompositionConfig.useImperativeHandle2.composition\"]);\n                        if (!composition) {\n                            throw new Error(`Could not find composition with id ${currentComposition}`);\n                        }\n                        const editorProps = allEditorProps[currentComposition] ?? {};\n                        const defaultProps = {\n                            ...composition.defaultProps ?? {},\n                            ...editorProps ?? {}\n                        };\n                        const props = {\n                            ...defaultProps,\n                            ...inputProps ?? {}\n                        };\n                        doResolution({\n                            defaultProps,\n                            calculateMetadata: composition.calculateMetadata,\n                            combinedProps: props,\n                            compositionDurationInFrames: composition.durationInFrames ?? null,\n                            compositionFps: composition.fps ?? null,\n                            compositionHeight: composition.height ?? null,\n                            compositionWidth: composition.width ?? null,\n                            compositionId: composition.id\n                        });\n                    }\n                })[\"ResolveCompositionConfig.useImperativeHandle2\"]\n            };\n        }\n    }[\"ResolveCompositionConfig.useImperativeHandle2\"], [\n        allEditorProps,\n        compositions,\n        currentComposition,\n        doResolution,\n        inputProps\n    ]);\n    const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n    const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[currentDefaultProps]\": ()=>{\n            return {\n                ...selectedComposition?.defaultProps ?? {},\n                ...selectedEditorProps ?? {}\n            };\n        }\n    }[\"ResolveCompositionConfig.useMemo4[currentDefaultProps]\"], [\n        selectedComposition?.defaultProps,\n        selectedEditorProps\n    ]);\n    const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[originalProps]\": ()=>{\n            return {\n                ...currentDefaultProps,\n                ...inputProps ?? {}\n            };\n        }\n    }[\"ResolveCompositionConfig.useMemo4[originalProps]\"], [\n        currentDefaultProps,\n        inputProps\n    ]);\n    const canResolve = selectedComposition && needsResolution(selectedComposition);\n    const shouldIgnoreUpdate =  false && 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ResolveCompositionConfig.useEffect2\": ()=>{\n            if (shouldIgnoreUpdate) {\n                return;\n            }\n            if (canResolve) {\n                const controller = doResolution({\n                    calculateMetadata: selectedComposition.calculateMetadata,\n                    combinedProps: originalProps,\n                    compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n                    compositionFps: selectedComposition.fps ?? null,\n                    compositionHeight: selectedComposition.height ?? null,\n                    compositionWidth: selectedComposition.width ?? null,\n                    defaultProps: currentDefaultProps,\n                    compositionId: selectedComposition.id\n                });\n                return ({\n                    \"ResolveCompositionConfig.useEffect2\": ()=>{\n                        controller.abort();\n                    }\n                })[\"ResolveCompositionConfig.useEffect2\"];\n            }\n        }\n    }[\"ResolveCompositionConfig.useEffect2\"], [\n        canResolve,\n        currentDefaultProps,\n        doResolution,\n        originalProps,\n        selectedComposition?.calculateMetadata,\n        selectedComposition?.durationInFrames,\n        selectedComposition?.fps,\n        selectedComposition?.height,\n        selectedComposition?.id,\n        selectedComposition?.width,\n        shouldIgnoreUpdate\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ResolveCompositionConfig.useEffect2\": ()=>{\n            if (shouldIgnoreUpdate) {\n                return;\n            }\n            window.dispatchEvent(new CustomEvent(PROPS_UPDATED_EXTERNALLY, {\n                detail: {\n                    resetUnsaved: true\n                }\n            }));\n        }\n    }[\"ResolveCompositionConfig.useEffect2\"], [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ResolveCompositionConfig.useEffect2\": ()=>{\n            if (renderModalComposition && !isTheSame) {\n                const combinedProps = {\n                    ...renderModalComposition.defaultProps ?? {},\n                    ...renderModalProps ?? {},\n                    ...inputProps ?? {}\n                };\n                const controller = doResolution({\n                    calculateMetadata: renderModalComposition.calculateMetadata,\n                    compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n                    compositionFps: renderModalComposition.fps ?? null,\n                    compositionHeight: renderModalComposition.height ?? null,\n                    compositionId: renderModalComposition.id,\n                    compositionWidth: renderModalComposition.width ?? null,\n                    defaultProps: currentDefaultProps,\n                    combinedProps\n                });\n                return ({\n                    \"ResolveCompositionConfig.useEffect2\": ()=>{\n                        controller.abort();\n                    }\n                })[\"ResolveCompositionConfig.useEffect2\"];\n            }\n        }\n    }[\"ResolveCompositionConfig.useEffect2\"], [\n        currentDefaultProps,\n        doResolution,\n        inputProps,\n        isTheSame,\n        renderModalComposition,\n        renderModalProps\n    ]);\n    const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\": ()=>{\n            const staticComps = compositions.filter({\n                \"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes].staticComps\": (c)=>{\n                    return c.calculateMetadata === null;\n                }\n            }[\"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes].staticComps\"]);\n            return {\n                ...resolvedConfigs,\n                ...staticComps.reduce({\n                    \"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\": (acc, curr)=>{\n                        return {\n                            ...acc,\n                            [curr.id]: {\n                                type: \"success\",\n                                result: {\n                                    ...curr,\n                                    defaultProps: curr.defaultProps ?? {}\n                                }\n                            }\n                        };\n                    }\n                }[\"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\"], {})\n            };\n        }\n    }[\"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\"], [\n        compositions,\n        resolvedConfigs\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n        value: resolvedConfigsIncludingStaticOnes,\n        children\n    });\n};\nvar useResolvedVideoConfig = (preferredCompositionId)=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    const compositionId = preferredCompositionId ?? currentComposition;\n    const composition = compositions.find((c)=>c.id === compositionId);\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useResolvedVideoConfig.useMemo4[selectedEditorProps]\": ()=>{\n            return composition ? allEditorProps[composition.id] ?? {} : {};\n        }\n    }[\"useResolvedVideoConfig.useMemo4[selectedEditorProps]\"], [\n        allEditorProps,\n        composition\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useResolvedVideoConfig.useMemo4\": ()=>{\n            if (!composition) {\n                return null;\n            }\n            if (currentCompositionMetadata) {\n                return {\n                    type: \"success\",\n                    result: {\n                        ...currentCompositionMetadata,\n                        id: composition.id,\n                        defaultProps: composition.defaultProps ?? {}\n                    }\n                };\n            }\n            if (!needsResolution(composition)) {\n                validateDurationInFrames(composition.durationInFrames, {\n                    allowFloats: false,\n                    component: `in <Composition id=\"${composition.id}\">`\n                });\n                validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n                validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n                validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n                return {\n                    type: \"success\",\n                    result: {\n                        width: composition.width,\n                        height: composition.height,\n                        fps: composition.fps,\n                        id: composition.id,\n                        durationInFrames: composition.durationInFrames,\n                        defaultProps: composition.defaultProps ?? {},\n                        props: {\n                            ...composition.defaultProps ?? {},\n                            ...selectedEditorProps ?? {},\n                            ... true ? {} : 0\n                        },\n                        defaultCodec: null,\n                        defaultOutName: null\n                    }\n                };\n            }\n            if (!context[composition.id]) {\n                return null;\n            }\n            return context[composition.id];\n        }\n    }[\"useResolvedVideoConfig.useMemo4\"], [\n        composition,\n        context,\n        currentCompositionMetadata,\n        selectedEditorProps\n    ]);\n};\n// src/use-video.ts\nvar useVideo = ()=>{\n    const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selected = compositions.find((c)=>{\n        return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n    });\n    const resolved = useResolvedVideoConfig(selected?.id ?? null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useVideo.useMemo5\": ()=>{\n            if (!resolved) {\n                return null;\n            }\n            if (resolved.type === \"error\") {\n                return null;\n            }\n            if (resolved.type === \"loading\") {\n                return null;\n            }\n            if (!selected) {\n                return null;\n            }\n            return {\n                ...resolved.result,\n                defaultProps: selected.defaultProps ?? {},\n                id: selected.id,\n                ...currentCompositionMetadata ?? {},\n                component: selected.component\n            };\n        }\n    }[\"useVideo.useMemo5\"], [\n        currentCompositionMetadata,\n        resolved,\n        selected\n    ]);\n};\n// src/timeline-position-state.ts\nvar TimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    frame: {},\n    playing: false,\n    playbackRate: 1,\n    rootId: \"\",\n    imperativePlaying: {\n        current: false\n    },\n    setPlaybackRate: ()=>{\n        throw new Error(\"default\");\n    },\n    audioAndVideoTags: {\n        current: []\n    }\n});\nvar SetTimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setFrame: ()=>{\n        throw new Error(\"default\");\n    },\n    setPlaying: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar makeKey = ()=>{\n    return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time)=>{\n    localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = ()=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    return obj;\n};\nvar getFrameForComposition = (composition)=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    if (obj[composition] !== undefined) {\n        return Number(obj[composition]);\n    }\n    if (true) {\n        return 0;\n    }\n    return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = ()=>{\n    const videoConfig = useVideo();\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    if (!videoConfig) {\n        return  true ? 0 : 0;\n    }\n    const unclamped = state.frame[videoConfig.id] ?? (getRemotionEnvironment().isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n    return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = ()=>{\n    const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return setFrame;\n};\nvar usePlayingState = ()=>{\n    const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"usePlayingState.useMemo6\": ()=>[\n                playing,\n                setPlaying,\n                imperativePlaying\n            ]\n    }[\"usePlayingState.useMemo6\"], [\n        imperativePlaying,\n        playing,\n        setPlaying\n    ]);\n};\n// src/use-video-config.ts\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: true,\n        children\n    });\n};\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const ctxWidth = context?.width ?? null;\n    const ctxHeight = context?.height ?? null;\n    const ctxDuration = context?.durationInFrames ?? null;\n    const video = useVideo();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useUnsafeVideoConfig.useMemo7\": ()=>{\n            if (!video) {\n                return null;\n            }\n            const { id, durationInFrames, fps, height, width, defaultProps, props, defaultCodec, defaultOutName } = video;\n            return {\n                id,\n                width: ctxWidth ?? width,\n                height: ctxHeight ?? height,\n                fps,\n                durationInFrames: ctxDuration ?? durationInFrames,\n                defaultProps,\n                props,\n                defaultCodec,\n                defaultOutName\n            };\n        }\n    }[\"useUnsafeVideoConfig.useMemo7\"], [\n        ctxDuration,\n        ctxHeight,\n        ctxWidth,\n        video\n    ]);\n};\n// src/use-video-config.ts\nvar useVideoConfig = ()=>{\n    const videoConfig = useUnsafeVideoConfig();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const isPlayer = useIsPlayer();\n    if (!videoConfig) {\n        if ( false || isPlayer) {\n            throw new Error([\n                \"No video config found. Likely reasons:\",\n                \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n                \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n            ].join(\"-\"));\n        }\n        throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n    }\n    if (!context) {\n        throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n    }\n    return videoConfig;\n};\n// src/freeze.tsx\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = ()=>{\n    const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (!canUseRemotionHooks) {\n        if (getRemotionEnvironment().isPlayer) {\n            throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n        }\n        throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n    }\n    const frame = useTimelinePosition();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n    return frame - contextOffset;\n};\n// src/freeze.tsx\n\nvar Freeze = ({ frame: frameToFreeze, children, active = true })=>{\n    const frame = useCurrentFrame();\n    const videoConfig = useVideoConfig();\n    if (typeof frameToFreeze === \"undefined\") {\n        throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n    }\n    if (typeof frameToFreeze !== \"number\") {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n    }\n    if (Number.isNaN(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n    }\n    if (!Number.isFinite(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n    }\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Freeze.useMemo8[isActive]\": ()=>{\n            if (typeof active === \"boolean\") {\n                return active;\n            }\n            if (typeof active === \"function\") {\n                return active(frame);\n            }\n        }\n    }[\"Freeze.useMemo8[isActive]\"], [\n        active,\n        frame\n    ]);\n    const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n    const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Freeze.useMemo8[timelineValue]\": ()=>{\n            if (!isActive) {\n                return timelineContext;\n            }\n            return {\n                ...timelineContext,\n                playing: false,\n                imperativePlaying: {\n                    current: false\n                },\n                frame: {\n                    [videoConfig.id]: frameToFreeze + relativeFrom\n                }\n            };\n        }\n    }[\"Freeze.useMemo8[timelineValue]\"], [\n        isActive,\n        timelineContext,\n        videoConfig.id,\n        frameToFreeze,\n        relativeFrom\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n        value: timelineValue,\n        children\n    });\n};\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({ from = 0, durationInFrames = Infinity, children, name, height, width, showInTimeline = true, _remotionInternalLoopDisplay: loopDisplay, _remotionInternalStack: stack, _remotionInternalPremountDisplay: premountDisplay, ...other }, ref)=>{\n    const { layout = \"absolute-fill\" } = other;\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"RegularSequenceRefForwardingFunction.useState4\": ()=>String(Math.random())\n    }[\"RegularSequenceRefForwardingFunction.useState4\"]);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n    const nonce = useNonce();\n    if (layout !== \"absolute-fill\" && layout !== \"none\") {\n        throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n    }\n    if (layout === \"none\" && typeof other.style !== \"undefined\") {\n        throw new TypeError('If layout=\"none\", you may not pass a style.');\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n    }\n    if (typeof from !== \"number\") {\n        throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n    }\n    if (!Number.isFinite(from)) {\n        throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n    }\n    const absoluteFrame = useTimelinePosition();\n    const videoConfig = useVideoConfig();\n    const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n    const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[premounting]\": ()=>{\n            return parentSequence?.premounting || Boolean(other._remotionInternalIsPremounting);\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[premounting]\"], [\n        other._remotionInternalIsPremounting,\n        parentSequence?.premounting\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[contextValue]\": ()=>{\n            return {\n                cumulatedFrom,\n                relativeFrom: from,\n                durationInFrames: actualDurationInFrames,\n                parentFrom: parentSequence?.relativeFrom ?? 0,\n                id,\n                height: height ?? parentSequence?.height ?? null,\n                width: width ?? parentSequence?.width ?? null,\n                premounting\n            };\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[contextValue]\"], [\n        cumulatedFrom,\n        from,\n        actualDurationInFrames,\n        parentSequence,\n        id,\n        height,\n        width,\n        premounting\n    ]);\n    const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[timelineClipName]\": ()=>{\n            return name ?? \"\";\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[timelineClipName]\"], [\n        name\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"RegularSequenceRefForwardingFunction.useEffect3\": ()=>{\n            if (!getRemotionEnvironment().isStudio) {\n                return;\n            }\n            registerSequence({\n                from,\n                duration: actualDurationInFrames,\n                id,\n                displayName: timelineClipName,\n                parent: parentSequence?.id ?? null,\n                type: \"sequence\",\n                rootId,\n                showInTimeline,\n                nonce,\n                loopDisplay,\n                stack: stack ?? null,\n                premountDisplay: premountDisplay ?? null\n            });\n            return ({\n                \"RegularSequenceRefForwardingFunction.useEffect3\": ()=>{\n                    unregisterSequence(id);\n                }\n            })[\"RegularSequenceRefForwardingFunction.useEffect3\"];\n        }\n    }[\"RegularSequenceRefForwardingFunction.useEffect3\"], [\n        durationInFrames,\n        id,\n        name,\n        registerSequence,\n        timelineClipName,\n        unregisterSequence,\n        parentSequence?.id,\n        actualDurationInFrames,\n        rootId,\n        from,\n        showInTimeline,\n        nonce,\n        loopDisplay,\n        stack,\n        premountDisplay\n    ]);\n    const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n    const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n    const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n    const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[defaultStyle]\": ()=>{\n            return {\n                flexDirection: undefined,\n                ...width ? {\n                    width\n                } : {},\n                ...height ? {\n                    height\n                } : {},\n                ...styleIfThere ?? {}\n            };\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[defaultStyle]\"], [\n        height,\n        styleIfThere,\n        width\n    ]);\n    if (ref !== null && layout === \"none\") {\n        throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n    }\n    const isSequenceHidden = hidden[id] ?? false;\n    if (isSequenceHidden) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n        value: contextValue,\n        children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n            ref,\n            style: defaultStyle,\n            className: other.className,\n            children: content\n        })\n    });\n};\nvar RegularSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedSequenceRefForwardingFunction = (props, ref)=>{\n    const frame = useCurrentFrame();\n    if (props.layout === \"none\") {\n        throw new Error('`<Sequence>` with `premountFor` prop does not support layout=\"none\"');\n    }\n    const { style: passedStyle, from = 0, premountFor = 0, styleWhilePremounted, ...otherProps } = props;\n    const premountingActive = frame < from && frame >= from - premountFor;\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PremountedSequenceRefForwardingFunction.useMemo9[style]\": ()=>{\n            return {\n                ...passedStyle,\n                opacity: premountingActive ? 0 : 1,\n                pointerEvents: premountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined,\n                ...premountingActive ? styleWhilePremounted : {}\n            };\n        }\n    }[\"PremountedSequenceRefForwardingFunction.useMemo9[style]\"], [\n        passedStyle,\n        premountingActive,\n        styleWhilePremounted\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n        frame: from,\n        active: premountingActive,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            ref,\n            from,\n            style,\n            _remotionInternalPremountDisplay: premountFor,\n            _remotionInternalIsPremounting: premountingActive,\n            ...otherProps\n        })\n    });\n};\nvar PremountedSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref)=>{\n    if (props.layout !== \"none\" && props.premountFor && !getRemotionEnvironment().isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedSequence, {\n            ...props,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n        ...props,\n        ref\n    });\n};\nvar Sequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/animated-image/AnimatedImage.tsx\n\n// src/cancel-render.ts\nvar isErrorLike = (err)=>{\n    if (err instanceof Error) {\n        return true;\n    }\n    if (err === null) {\n        return false;\n    }\n    if (typeof err !== \"object\") {\n        return false;\n    }\n    if (!(\"stack\" in err)) {\n        return false;\n    }\n    if (typeof err.stack !== \"string\") {\n        return false;\n    }\n    if (!(\"message\" in err)) {\n        return false;\n    }\n    if (typeof err.message !== \"string\") {\n        return false;\n    }\n    return true;\n};\nfunction cancelRender(err) {\n    let error;\n    if (isErrorLike(err)) {\n        error = err;\n        if (!error.stack) {\n            error.stack = new Error(error.message).stack;\n        }\n    } else if (typeof err === \"string\") {\n        error = Error(err);\n    } else {\n        error = Error(\"Rendering was cancelled\");\n    }\n    window.remotion_cancelledError = error.stack;\n    throw error;\n}\n// src/log.ts\nvar logLevels = [\n    \"trace\",\n    \"verbose\",\n    \"info\",\n    \"warn\",\n    \"error\"\n];\nvar getNumberForLogLevel = (level)=>{\n    return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level)=>{\n    return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar Log = {\n    trace: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"trace\")) {\n            return console.log(...args);\n        }\n    },\n    verbose: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"verbose\")) {\n            return console.log(...args);\n        }\n    },\n    info: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"info\")) {\n            return console.log(...args);\n        }\n    },\n    warn: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"warn\")) {\n            return console.warn(...args);\n        }\n    },\n    error: (...args)=>{\n        return console.error(...args);\n    }\n};\n// src/delay-render.ts\nif (false) {}\nvar handles = [];\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\nvar defaultTimeout = 30000;\nvar delayRender = (label, options)=>{\n    if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n        throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n    }\n    const handle = Math.random();\n    handles.push(handle);\n    const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n    if (getRemotionEnvironment().isRendering) {\n        const timeoutToUse = (options?.timeoutInMilliseconds ?? ( true ? defaultTimeout : 0)) - 2000;\n        if (false) {}\n    }\n    if (false) {}\n    return handle;\n};\nvar continueRender = (handle)=>{\n    if (typeof handle === \"undefined\") {\n        throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n    }\n    if (typeof handle !== \"number\") {\n        throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n    }\n    handles = handles.filter((h)=>{\n        if (h === handle) {\n            if (getRemotionEnvironment().isRendering) {\n                if (!window.remotion_delayRenderTimeouts[handle]) {\n                    return false;\n                }\n                const { label, startTime, timeout } = window.remotion_delayRenderTimeouts[handle];\n                clearTimeout(timeout);\n                const message = [\n                    label ? `delayRender() \"${label}\"` : \"A delayRender()\",\n                    DELAY_RENDER_CLEAR_TOKEN,\n                    `${Date.now() - startTime}ms`\n                ].filter(truthy).join(\" \");\n                Log.verbose(window.remotion_logLevel, message);\n                delete window.remotion_delayRenderTimeouts[handle];\n            }\n            return false;\n        }\n        return true;\n    });\n    if (handles.length === 0 && \"undefined\" !== \"undefined\") {}\n};\n// src/animated-image/canvas.tsx\n\n\nvar calcArgs = (fit, frameSize, canvasSize)=>{\n    switch(fit){\n        case \"fill\":\n            {\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    0,\n                    0,\n                    canvasSize.width,\n                    canvasSize.height\n                ];\n            }\n        case \"contain\":\n            {\n                const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n                const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n                const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    centerX,\n                    centerY,\n                    frameSize.width * ratio,\n                    frameSize.height * ratio\n                ];\n            }\n        case \"cover\":\n            {\n                const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n                const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n                const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    centerX,\n                    centerY,\n                    frameSize.width * ratio,\n                    frameSize.height * ratio\n                ];\n            }\n        default:\n            throw new Error(\"Unknown fit: \" + fit);\n    }\n};\nvar CanvasRefForwardingFunction = ({ width, height, fit, className, style }, ref)=>{\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CanvasRefForwardingFunction.useCallback4[draw]\": (imageData)=>{\n            const canvas = canvasRef.current;\n            const canvasWidth = width ?? imageData.displayWidth;\n            const canvasHeight = height ?? imageData.displayHeight;\n            if (!canvas) {\n                throw new Error(\"Canvas ref is not set\");\n            }\n            const ctx = canvasRef.current?.getContext(\"2d\");\n            if (!ctx) {\n                throw new Error(\"Could not get 2d context\");\n            }\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            ctx.drawImage(imageData, ...calcArgs(fit, {\n                height: imageData.displayHeight,\n                width: imageData.displayWidth\n            }, {\n                width: canvasWidth,\n                height: canvasHeight\n            }));\n        }\n    }[\"CanvasRefForwardingFunction.useCallback4[draw]\"], [\n        fit,\n        height,\n        width\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"CanvasRefForwardingFunction.useImperativeHandle3\": ()=>{\n            return {\n                draw,\n                getCanvas: ({\n                    \"CanvasRefForwardingFunction.useImperativeHandle3\": ()=>{\n                        if (!canvasRef.current) {\n                            throw new Error(\"Canvas ref is not set\");\n                        }\n                        return canvasRef.current;\n                    }\n                })[\"CanvasRefForwardingFunction.useImperativeHandle3\"],\n                clear: ({\n                    \"CanvasRefForwardingFunction.useImperativeHandle3\": ()=>{\n                        const ctx = canvasRef.current?.getContext(\"2d\");\n                        if (!ctx) {\n                            throw new Error(\"Could not get 2d context\");\n                        }\n                        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n                    }\n                })[\"CanvasRefForwardingFunction.useImperativeHandle3\"]\n            };\n        }\n    }[\"CanvasRefForwardingFunction.useImperativeHandle3\"], [\n        draw\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        className,\n        style\n    });\n};\nvar Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CanvasRefForwardingFunction);\n// src/animated-image/decode-image.ts\nvar CACHE_SIZE = 5;\nvar getActualTime = ({ loopBehavior, durationFound, timeInSec })=>{\n    return loopBehavior === \"loop\" ? durationFound ? timeInSec % durationFound : timeInSec : Math.min(timeInSec, durationFound || Infinity);\n};\nvar decodeImage = async ({ resolvedSrc, signal, currentTime, initialLoopBehavior })=>{\n    if (typeof ImageDecoder === \"undefined\") {\n        throw new Error(\"Your browser does not support the WebCodecs ImageDecoder API.\");\n    }\n    const res = await fetch(resolvedSrc, {\n        signal\n    });\n    const { body } = res;\n    if (!body) {\n        throw new Error(\"Got no body\");\n    }\n    const decoder = new ImageDecoder({\n        data: body,\n        type: res.headers.get(\"Content-Type\") || \"image/gif\"\n    });\n    await decoder.completed;\n    const { selectedTrack } = decoder.tracks;\n    if (!selectedTrack) {\n        throw new Error(\"No selected track\");\n    }\n    const cache = [];\n    let durationFound = null;\n    const getFrameByIndex = async (frameIndex)=>{\n        const foundInCache = cache.find((c)=>c.frameIndex === frameIndex);\n        if (foundInCache && foundInCache.frame) {\n            return foundInCache;\n        }\n        const frame = await decoder.decode({\n            frameIndex,\n            completeFramesOnly: true\n        });\n        if (foundInCache) {\n            foundInCache.frame = frame.image;\n        } else {\n            cache.push({\n                frame: frame.image,\n                frameIndex,\n                timeInSeconds: frame.image.timestamp / 1e6\n            });\n        }\n        return {\n            frame: frame.image,\n            frameIndex,\n            timeInSeconds: frame.image.timestamp / 1e6\n        };\n    };\n    const clearCache = (closeToTimeInSec)=>{\n        const itemsInCache = cache.filter((c)=>c.frame);\n        const sortByClosestToCurrentTime = itemsInCache.sort((a, b)=>{\n            const aDiff = Math.abs(a.timeInSeconds - closeToTimeInSec);\n            const bDiff = Math.abs(b.timeInSeconds - closeToTimeInSec);\n            return aDiff - bDiff;\n        });\n        for(let i = 0; i < sortByClosestToCurrentTime.length; i++){\n            if (i < CACHE_SIZE) {\n                continue;\n            }\n            const item = sortByClosestToCurrentTime[i];\n            item.frame = null;\n        }\n    };\n    const ensureFrameBeforeAndAfter = async ({ timeInSec, loopBehavior })=>{\n        const actualTimeInSec = getActualTime({\n            durationFound,\n            loopBehavior,\n            timeInSec\n        });\n        const framesBefore = cache.filter((c)=>c.timeInSeconds <= actualTimeInSec);\n        const biggestIndex = framesBefore.map((c)=>c.frameIndex).reduce((a, b)=>Math.max(a, b), 0);\n        let i = biggestIndex;\n        while(true){\n            const f = await getFrameByIndex(i);\n            i++;\n            if (!f.frame) {\n                throw new Error(\"No frame found\");\n            }\n            if (!f.frame.duration) {\n                break;\n            }\n            if (i === selectedTrack.frameCount && durationFound === null) {\n                const duration = (f.frame.timestamp + f.frame.duration) / 1e6;\n                durationFound = duration;\n            }\n            if (f.timeInSeconds > actualTimeInSec || i === selectedTrack.frameCount) {\n                break;\n            }\n        }\n        if (selectedTrack.frameCount - biggestIndex < 3 && loopBehavior === \"loop\") {\n            await getFrameByIndex(0);\n        }\n        clearCache(actualTimeInSec);\n    };\n    await ensureFrameBeforeAndAfter({\n        timeInSec: currentTime,\n        loopBehavior: initialLoopBehavior\n    });\n    await ensureFrameBeforeAndAfter({\n        timeInSec: currentTime,\n        loopBehavior: initialLoopBehavior\n    });\n    const getFrame = async (timeInSec, loopBehavior)=>{\n        if (durationFound !== null && timeInSec > durationFound && loopBehavior === \"clear-after-finish\") {\n            return null;\n        }\n        const actualTimeInSec = getActualTime({\n            loopBehavior,\n            durationFound,\n            timeInSec\n        });\n        await ensureFrameBeforeAndAfter({\n            timeInSec: actualTimeInSec,\n            loopBehavior\n        });\n        const itemsInCache = cache.filter((c)=>c.frame);\n        const closest = itemsInCache.reduce((a, b)=>{\n            const aDiff = Math.abs(a.timeInSeconds - actualTimeInSec);\n            const bDiff = Math.abs(b.timeInSeconds - actualTimeInSec);\n            return aDiff < bDiff ? a : b;\n        });\n        if (!closest.frame) {\n            throw new Error(\"No frame found\");\n        }\n        return closest;\n    };\n    return {\n        getFrame,\n        frameCount: selectedTrack.frameCount\n    };\n};\n// src/animated-image/resolve-image-source.tsx\nvar resolveAnimatedImageSource = (src)=>{\n    if (true) {\n        return src;\n    }\n    return new URL(src, window.origin).href;\n};\n// src/animated-image/AnimatedImage.tsx\n\nvar AnimatedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ src, width, height, onError, loopBehavior = \"loop\", playbackRate = 1, fit = \"fill\", ...props }, canvasRef)=>{\n    const mountState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isMounted: true\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AnimatedImage.useEffect4\": ()=>{\n            const { current } = mountState;\n            current.isMounted = true;\n            return ({\n                \"AnimatedImage.useEffect4\": ()=>{\n                    current.isMounted = false;\n                }\n            })[\"AnimatedImage.useEffect4\"];\n        }\n    }[\"AnimatedImage.useEffect4\"], []);\n    const resolvedSrc = resolveAnimatedImageSource(src);\n    const [imageDecoder, setImageDecoder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [decodeHandle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"AnimatedImage.useState5\": ()=>delayRender(`Rendering <AnimatedImage/> with src=\"${resolvedSrc}\"`)\n    }[\"AnimatedImage.useState5\"]);\n    const frame = useCurrentFrame();\n    const { fps } = useVideoConfig();\n    const currentTime = frame / playbackRate / fps;\n    const currentTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentTime);\n    currentTimeRef.current = currentTime;\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(canvasRef, {\n        \"AnimatedImage.useImperativeHandle4\": ()=>{\n            const c = ref.current?.getCanvas();\n            if (!c) {\n                throw new Error(\"Canvas ref is not set\");\n            }\n            return c;\n        }\n    }[\"AnimatedImage.useImperativeHandle4\"], []);\n    const [initialLoopBehavior] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"AnimatedImage.useState5\": ()=>loopBehavior\n    }[\"AnimatedImage.useState5\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AnimatedImage.useEffect4\": ()=>{\n            const controller = new AbortController;\n            decodeImage({\n                resolvedSrc,\n                signal: controller.signal,\n                currentTime: currentTimeRef.current,\n                initialLoopBehavior\n            }).then({\n                \"AnimatedImage.useEffect4\": (d)=>{\n                    setImageDecoder(d);\n                    continueRender(decodeHandle);\n                }\n            }[\"AnimatedImage.useEffect4\"]).catch({\n                \"AnimatedImage.useEffect4\": (err)=>{\n                    if (err.name === \"AbortError\") {\n                        continueRender(decodeHandle);\n                        return;\n                    }\n                    if (onError) {\n                        onError?.(err);\n                        continueRender(decodeHandle);\n                    } else {\n                        cancelRender(err);\n                    }\n                }\n            }[\"AnimatedImage.useEffect4\"]);\n            return ({\n                \"AnimatedImage.useEffect4\": ()=>{\n                    controller.abort();\n                }\n            })[\"AnimatedImage.useEffect4\"];\n        }\n    }[\"AnimatedImage.useEffect4\"], [\n        resolvedSrc,\n        decodeHandle,\n        onError,\n        initialLoopBehavior\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"AnimatedImage.useLayoutEffect\": ()=>{\n            if (!imageDecoder) {\n                return;\n            }\n            const delay = delayRender(`Rendering frame at ${currentTime} of <AnimatedImage src=\"${src}\"/>`);\n            imageDecoder.getFrame(currentTime, loopBehavior).then({\n                \"AnimatedImage.useLayoutEffect\": (videoFrame)=>{\n                    if (mountState.current.isMounted) {\n                        if (videoFrame === null) {\n                            ref.current?.clear();\n                        } else {\n                            ref.current?.draw(videoFrame.frame);\n                        }\n                    }\n                    continueRender(delay);\n                }\n            }[\"AnimatedImage.useLayoutEffect\"]).catch({\n                \"AnimatedImage.useLayoutEffect\": (err)=>{\n                    if (onError) {\n                        onError(err);\n                        continueRender(delay);\n                    } else {\n                        cancelRender(err);\n                    }\n                }\n            }[\"AnimatedImage.useLayoutEffect\"]);\n        }\n    }[\"AnimatedImage.useLayoutEffect\"], [\n        currentTime,\n        imageDecoder,\n        loopBehavior,\n        onError,\n        src\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Canvas, {\n        ref,\n        width,\n        height,\n        fit,\n        ...props\n    });\n});\n// src/Artifact.tsx\n\n// src/RenderAssetManager.tsx\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename)=>{\n    if (typeof filename !== \"string\") {\n        throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n    }\n    if (filename.trim() === \"\") {\n        throw new Error(\"The `filename` must not be empty\");\n    }\n    if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n        throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n    }\n};\nvar validateContent = (content)=>{\n    if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n        throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n    }\n    if (typeof content === \"string\" && content.trim() === \"\") {\n        throw new Error(\"The `content` must not be empty\");\n    }\n};\nvar validateRenderAsset = (artifact)=>{\n    if (artifact.type !== \"artifact\") {\n        return;\n    }\n    validateArtifactFilename(artifact.filename);\n    if (artifact.contentType === \"thumbnail\") {\n        return;\n    }\n    validateContent(artifact.content);\n};\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerRenderAsset: ()=>{\n        return;\n    },\n    unregisterRenderAsset: ()=>{\n        return;\n    },\n    renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children })=>{\n    const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"RenderAssetManagerProvider.useCallback5[registerRenderAsset]\": (renderAsset)=>{\n            validateRenderAsset(renderAsset);\n            setRenderAssets({\n                \"RenderAssetManagerProvider.useCallback5[registerRenderAsset]\": (assets)=>{\n                    return [\n                        ...assets,\n                        renderAsset\n                    ];\n                }\n            }[\"RenderAssetManagerProvider.useCallback5[registerRenderAsset]\"]);\n        }\n    }[\"RenderAssetManagerProvider.useCallback5[registerRenderAsset]\"], []);\n    const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"RenderAssetManagerProvider.useCallback5[unregisterRenderAsset]\": (id)=>{\n            setRenderAssets({\n                \"RenderAssetManagerProvider.useCallback5[unregisterRenderAsset]\": (assts)=>{\n                    return assts.filter({\n                        \"RenderAssetManagerProvider.useCallback5[unregisterRenderAsset]\": (a)=>a.id !== id\n                    }[\"RenderAssetManagerProvider.useCallback5[unregisterRenderAsset]\"]);\n                }\n            }[\"RenderAssetManagerProvider.useCallback5[unregisterRenderAsset]\"]);\n        }\n    }[\"RenderAssetManagerProvider.useCallback5[unregisterRenderAsset]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"RenderAssetManagerProvider.useLayoutEffect2\": ()=>{\n            if (false) {}\n        }\n    }[\"RenderAssetManagerProvider.useLayoutEffect2\"], [\n        renderAssets\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RenderAssetManagerProvider.useMemo10[contextValue]\": ()=>{\n            return {\n                registerRenderAsset,\n                unregisterRenderAsset,\n                renderAssets\n            };\n        }\n    }[\"RenderAssetManagerProvider.useMemo10[contextValue]\"], [\n        renderAssets,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n        value: contextValue,\n        children\n    });\n};\n// src/Artifact.tsx\nvar ArtifactThumbnail = Symbol(\"Thumbnail\");\nvar Artifact = ({ filename, content })=>{\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"Artifact.useState7\": ()=>getRemotionEnvironment()\n    }[\"Artifact.useState7\"]);\n    const frame = useCurrentFrame();\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"Artifact.useState7\": ()=>{\n            return String(Math.random());\n        }\n    }[\"Artifact.useState7\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Artifact.useEffect5\": ()=>{\n            if (!env.isRendering) {\n                return;\n            }\n            if (content instanceof Uint8Array) {\n                registerRenderAsset({\n                    type: \"artifact\",\n                    id,\n                    content: btoa(new TextDecoder(\"utf8\").decode(content)),\n                    filename,\n                    frame,\n                    contentType: \"binary\"\n                });\n            } else if (content === ArtifactThumbnail) {\n                registerRenderAsset({\n                    type: \"artifact\",\n                    id,\n                    filename,\n                    frame,\n                    contentType: \"thumbnail\"\n                });\n            } else {\n                registerRenderAsset({\n                    type: \"artifact\",\n                    id,\n                    content,\n                    filename,\n                    frame,\n                    contentType: \"text\"\n                });\n            }\n            return ({\n                \"Artifact.useEffect5\": ()=>{\n                    return unregisterRenderAsset(id);\n                }\n            })[\"Artifact.useEffect5\"];\n        }\n    }[\"Artifact.useEffect5\"], [\n        content,\n        env.isRendering,\n        filename,\n        frame,\n        id,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return null;\n};\nArtifact.Thumbnail = ArtifactThumbnail;\n// src/audio/Audio.tsx\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/calculate-loop.ts\nvar calculateLoopDuration = ({ endAt, mediaDuration, playbackRate, startFrom })=>{\n    let duration = mediaDuration;\n    if (typeof endAt !== \"undefined\") {\n        duration = endAt;\n    }\n    if (typeof startFrom !== \"undefined\") {\n        duration -= startFrom;\n    }\n    const actualDuration = duration / playbackRate;\n    return Math.floor(actualDuration);\n};\n// src/loop/index.tsx\n\n\nvar LoopContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = ()=>{\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props })=>{\n    const currentFrame = useCurrentFrame();\n    const { durationInFrames: compDuration } = useVideoConfig();\n    validateDurationInFrames(durationInFrames, {\n        component: \"of the <Loop /> component\",\n        allowFloats: true\n    });\n    if (typeof times !== \"number\") {\n        throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n    }\n    if (times !== Infinity && times % 1 !== 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n    }\n    if (times < 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n    }\n    const maxTimes = Math.ceil(compDuration / durationInFrames);\n    const actualTimes = Math.min(maxTimes, times);\n    const style = props.layout === \"none\" ? undefined : props.style;\n    const maxFrame = durationInFrames * (actualTimes - 1);\n    const iteration = Math.floor(currentFrame / durationInFrames);\n    const start = iteration * durationInFrames;\n    const from = Math.min(start, maxFrame);\n    const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Loop.useMemo11[loopDisplay]\": ()=>{\n            return {\n                numberOfTimes: actualTimes,\n                startOffset: -from,\n                durationInFrames\n            };\n        }\n    }[\"Loop.useMemo11[loopDisplay]\"], [\n        actualTimes,\n        durationInFrames,\n        from\n    ]);\n    const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Loop.useMemo11[loopContext]\": ()=>{\n            return {\n                iteration: Math.floor(currentFrame / durationInFrames),\n                durationInFrames\n            };\n        }\n    }[\"Loop.useMemo11[loopContext]\"], [\n        currentFrame,\n        durationInFrames\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n        value: loopContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            durationInFrames,\n            from,\n            name: name ?? \"<Loop>\",\n            _remotionInternalLoopDisplay: loopDisplay,\n            layout: props.layout,\n            style,\n            children\n        })\n    });\n};\nLoop.useLoop = useLoop;\n// src/prefetch.ts\n\n// src/playback-logging.ts\nvar playbackLogging = ({ logLevel, tag, message, mountTime })=>{\n    const tags = [\n        mountTime ? Date.now() - mountTime + \"ms \" : null,\n        tag\n    ].filter(Boolean).join(\" \");\n    Log.trace(logLevel, `[${tags}]`, message);\n};\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater)=>{\n    preloads = updater(preloads);\n    updaters.forEach((u)=>u());\n};\nvar PrefetchProvider = ({ children })=>{\n    const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"PrefetchProvider.useState8\": ()=>preloads\n    }[\"PrefetchProvider.useState8\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PrefetchProvider.useEffect6\": ()=>{\n            const updaterFunction = {\n                \"PrefetchProvider.useEffect6.updaterFunction\": ()=>{\n                    _setPreloads(preloads);\n                }\n            }[\"PrefetchProvider.useEffect6.updaterFunction\"];\n            updaters.push(updaterFunction);\n            return ({\n                \"PrefetchProvider.useEffect6\": ()=>{\n                    updaters = updaters.filter({\n                        \"PrefetchProvider.useEffect6\": (u)=>u !== updaterFunction\n                    }[\"PrefetchProvider.useEffect6\"]);\n                }\n            })[\"PrefetchProvider.useEffect6\"];\n        }\n    }[\"PrefetchProvider.useEffect6\"], []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n        value: _preloads,\n        children\n    });\n};\n// src/prefetch.ts\nvar removeAndGetHashFragment = (src)=>{\n    const hashIndex = src.indexOf(\"#\");\n    if (hashIndex === -1) {\n        return null;\n    }\n    return hashIndex;\n};\nvar getSrcWithoutHash = (src)=>{\n    const hashIndex = removeAndGetHashFragment(src);\n    if (hashIndex === null) {\n        return src;\n    }\n    return src.slice(0, hashIndex);\n};\nvar usePreload = (src)=>{\n    const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n    const hashFragmentIndex = removeAndGetHashFragment(src);\n    const withoutHashFragment = getSrcWithoutHash(src);\n    if (!preloads2[withoutHashFragment]) {\n        return src;\n    }\n    if (hashFragmentIndex !== null) {\n        return preloads2[withoutHashFragment] + src.slice(hashFragmentIndex);\n    }\n    return preloads2[withoutHashFragment];\n};\nvar blobToBase64 = function(blob) {\n    const reader = new FileReader;\n    return new Promise((resolve, reject)=>{\n        reader.onload = function() {\n            const dataUrl = reader.result;\n            resolve(dataUrl);\n        };\n        reader.onerror = (err)=>{\n            return reject(err);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\nvar getBlobFromReader = async ({ reader, contentType, contentLength, onProgress })=>{\n    let receivedLength = 0;\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n        receivedLength += value.length;\n        if (onProgress) {\n            onProgress({\n                loadedBytes: receivedLength,\n                totalBytes: contentLength\n            });\n        }\n    }\n    const chunksAll = new Uint8Array(receivedLength);\n    let position = 0;\n    for (const chunk of chunks){\n        chunksAll.set(chunk, position);\n        position += chunk.length;\n    }\n    return new Blob([\n        chunksAll\n    ], {\n        type: contentType ?? undefined\n    });\n};\nvar prefetch = (src, options)=>{\n    const method = options?.method ?? \"blob-url\";\n    const logLevel = options?.logLevel ?? \"info\";\n    const srcWithoutHash = getSrcWithoutHash(src);\n    if (getRemotionEnvironment().isRendering) {\n        return {\n            free: ()=>{\n                return;\n            },\n            waitUntilDone: ()=>Promise.resolve(srcWithoutHash)\n        };\n    }\n    Log.verbose(logLevel, `[prefetch] Starting prefetch ${srcWithoutHash}`);\n    let canceled = false;\n    let objectUrl = null;\n    let resolve = ()=>{\n        return;\n    };\n    let reject = ()=>{\n        return;\n    };\n    const waitUntilDone = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    const controller = new AbortController;\n    let canBeAborted = true;\n    fetch(srcWithoutHash, {\n        signal: controller.signal,\n        credentials: options?.credentials ?? undefined\n    }).then((res)=>{\n        canBeAborted = false;\n        if (canceled) {\n            return null;\n        }\n        if (!res.ok) {\n            throw new Error(`HTTP error, status = ${res.status}`);\n        }\n        const headerContentType = res.headers.get(\"Content-Type\");\n        const contentType = options?.contentType ?? headerContentType;\n        const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n        if (!hasProperContentType) {\n            console.warn(`Called prefetch() on ${srcWithoutHash} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n        }\n        if (!res.body) {\n            throw new Error(`HTTP response of ${srcWithoutHash} has no body`);\n        }\n        const reader = res.body.getReader();\n        return getBlobFromReader({\n            reader,\n            contentType: options?.contentType ?? headerContentType ?? null,\n            contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n            onProgress: options?.onProgress\n        });\n    }).then((buf)=>{\n        if (!buf) {\n            return;\n        }\n        const actualBlob = options?.contentType ? new Blob([\n            buf\n        ], {\n            type: options.contentType\n        }) : buf;\n        if (method === \"base64\") {\n            return blobToBase64(actualBlob);\n        }\n        return URL.createObjectURL(actualBlob);\n    }).then((url)=>{\n        if (canceled) {\n            return;\n        }\n        playbackLogging({\n            logLevel,\n            tag: \"prefetch\",\n            message: `Finished prefetch ${srcWithoutHash} with method ${method}`,\n            mountTime: null\n        });\n        objectUrl = url;\n        setPreloads((p)=>({\n                ...p,\n                [srcWithoutHash]: objectUrl\n            }));\n        resolve(objectUrl);\n    }).catch((err)=>{\n        if (err?.message.includes(\"free() called\")) {\n            return;\n        }\n        reject(err);\n    });\n    return {\n        free: ()=>{\n            playbackLogging({\n                logLevel,\n                tag: \"prefetch\",\n                message: `Freeing ${srcWithoutHash}`,\n                mountTime: null\n            });\n            if (objectUrl) {\n                if (method === \"blob-url\") {\n                    URL.revokeObjectURL(objectUrl);\n                }\n                setPreloads((p)=>{\n                    const copy = {\n                        ...p\n                    };\n                    delete copy[srcWithoutHash];\n                    return copy;\n                });\n            } else {\n                canceled = true;\n                if (canBeAborted) {\n                    try {\n                        controller.abort(new Error(\"free() called\"));\n                    } catch  {}\n                }\n            }\n        },\n        waitUntilDone: ()=>{\n            return waitUntilDone;\n        }\n    };\n};\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component)=>{\n    if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n        throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n    }\n    if (typeof props.volume === \"number\" && props.volume < 0) {\n        throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n    }\n    if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n        throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n    }\n    if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n        throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n    }\n};\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt)=>{\n    if (typeof startFrom !== \"undefined\") {\n        if (typeof startFrom !== \"number\") {\n            throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n        }\n        if (isNaN(startFrom) || startFrom === Infinity) {\n            throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n        }\n        if (startFrom < 0) {\n            throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n        }\n    }\n    if (typeof endAt !== \"undefined\") {\n        if (typeof endAt !== \"number\") {\n            throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n        }\n        if (isNaN(endAt)) {\n            throw new TypeError(\"endAt prop can not be NaN.\");\n        }\n        if (endAt <= 0) {\n            throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n        }\n    }\n    if (endAt < startFrom) {\n        throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n    }\n};\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action)=>{\n    switch(action.type){\n        case \"got-duration\":\n            {\n                const absoluteSrc = getAbsoluteSrc(action.src);\n                if (state[absoluteSrc] === action.durationInSeconds) {\n                    return state;\n                }\n                return {\n                    ...state,\n                    [absoluteSrc]: action.durationInSeconds\n                };\n            }\n        default:\n            return state;\n    }\n};\nvar DurationsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    durations: {},\n    setDurations: ()=>{\n        throw new Error(\"context missing\");\n    }\n});\nvar DurationsContextProvider = ({ children })=>{\n    const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"DurationsContextProvider.useMemo12[value]\": ()=>{\n            return {\n                durations,\n                setDurations\n            };\n        }\n    }[\"DurationsContextProvider.useMemo12[value]\"], [\n        durations\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n        value,\n        children\n    });\n};\n// src/audio/AudioForPreview.tsx\n\n// src/log-level-context.tsx\n\n\nvar LogLevelContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    logLevel: \"info\",\n    mountTime: 0\n});\nvar useLogLevel = ()=>{\n    const { logLevel } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    if (logLevel === null) {\n        throw new Error(\"useLogLevel must be used within a LogLevelProvider\");\n    }\n    return logLevel;\n};\nvar useMountTime = ()=>{\n    const { mountTime } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    if (mountTime === null) {\n        throw new Error(\"useMountTime must be used within a LogLevelProvider\");\n    }\n    return mountTime;\n};\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/use-amplification.ts\n\nvar warned = false;\nvar warnOnce = (logLevel)=>{\n    if (warned) {\n        return;\n    }\n    warned = true;\n    Log.warn(logLevel, \"AudioContext is not supported in this browser\");\n};\nvar getShouldAmplify = (volume)=>{\n    return volume > 1;\n};\nvar useAmplification = ({ mediaRef, volume, logLevel })=>{\n    const shouldAmplify = getShouldAmplify(volume);\n    const audioStuffRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const currentVolumeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(volume);\n    currentVolumeRef.current = volume;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"useAmplification.useLayoutEffect3\": ()=>{\n            if (!shouldAmplify) {\n                return;\n            }\n            if (!AudioContext) {\n                warnOnce(logLevel);\n                return;\n            }\n            if (!mediaRef.current) {\n                return;\n            }\n            if (audioStuffRef.current) {\n                return;\n            }\n            const audioContext = new AudioContext({\n                latencyHint: \"interactive\"\n            });\n            const source = new MediaElementAudioSourceNode(audioContext, {\n                mediaElement: mediaRef.current\n            });\n            const gainNode = new GainNode(audioContext, {\n                gain: Math.max(currentVolumeRef.current, 1)\n            });\n            audioStuffRef.current = {\n                gainNode,\n                source,\n                audioContext\n            };\n            source.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            Log.trace(logLevel, `Starting to amplify ${mediaRef.current?.src}. Gain = ${currentVolumeRef.current}`);\n        }\n    }[\"useAmplification.useLayoutEffect3\"], [\n        logLevel,\n        mediaRef,\n        shouldAmplify\n    ]);\n    if (audioStuffRef.current) {\n        const valueToSet = Math.max(volume, 1);\n        if (audioStuffRef.current.gainNode.gain.value !== valueToSet) {\n            audioStuffRef.current.gainNode.gain.value = valueToSet;\n            Log.trace(logLevel, `Setting gain to ${valueToSet} for ${mediaRef.current?.src}`);\n        }\n    }\n    return audioStuffRef;\n};\n// src/use-media-in-timeline.ts\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = ()=>{\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n    return startsAt;\n};\nvar useFrameForVolumeProp = (behavior)=>{\n    const loop = Loop.useLoop();\n    const frame = useCurrentFrame();\n    const startsAt = useMediaStartsAt();\n    if (behavior === \"repeat\" || loop === null) {\n        return frame + startsAt;\n    }\n    return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename)=>{\n    if (/data:|blob:/.test(filename.substring(0, 5))) {\n        return \"Data URL\";\n    }\n    const splitted = filename.split(\"/\").map((s)=>s.split(\"\\\\\")).flat(1);\n    return splitted[splitted.length - 1];\n};\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = ({ mediaRef, mediaType, onAutoPlayError, logLevel, mountTime, reason })=>{\n    const { current } = mediaRef;\n    if (!current) {\n        return;\n    }\n    playbackLogging({\n        logLevel,\n        tag: \"play\",\n        message: `Attempting to play ${current.src}. Reason: ${reason}`,\n        mountTime\n    });\n    const prom = current.play();\n    if (!prom.catch) {\n        return;\n    }\n    prom.catch((err)=>{\n        if (!current) {\n            return;\n        }\n        if (err.message.includes(\"request was interrupted by a call to pause\")) {\n            return;\n        }\n        if (err.message.includes(\"The operation was aborted.\")) {\n            return;\n        }\n        if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n            return;\n        }\n        if (err.message.includes(\"request was interrupted by a new load request\")) {\n            return;\n        }\n        if (err.message.includes(\"because the media was removed from the document\")) {\n            return;\n        }\n        if (err.message.includes(\"user didn't interact with the document\") && current.muted) {\n            return;\n        }\n        console.log(`Could not play ${mediaType} due to following error: `, err);\n        if (!current.muted) {\n            if (onAutoPlayError) {\n                onAutoPlayError();\n                return;\n            }\n            console.log(`The video will be muted and we'll retry playing it.`);\n            if (mediaType === \"video\" && getRemotionEnvironment().isPlayer) {\n                console.log(\"Use onAutoPlayError() to handle this error yourself.\");\n            }\n            current.muted = true;\n            current.play();\n        }\n    });\n};\n// src/volume-prop.ts\nvar evaluateVolume = ({ frame, volume, mediaVolume = 1 })=>{\n    if (typeof volume === \"number\") {\n        return volume * mediaVolume;\n    }\n    if (typeof volume === \"undefined\") {\n        return Number(mediaVolume);\n    }\n    const evaluated = volume(frame) * mediaVolume;\n    if (typeof evaluated !== \"number\") {\n        throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n    }\n    if (Number.isNaN(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n    }\n    if (!Number.isFinite(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n    }\n    return Math.max(0, evaluated);\n};\n// src/use-media-in-timeline.ts\nvar didWarn = {};\nvar warnOnce2 = (message)=>{\n    if (didWarn[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn[message] = true;\n};\nvar useMediaInTimeline = ({ volume, mediaVolume, mediaRef, src, mediaType, playbackRate, displayName, id, stack, showInTimeline, premountDisplay, onAutoPlayError, isPremounting })=>{\n    const videoConfig = useVideoConfig();\n    const { rootId, audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const actualFrom = parentSequence ? parentSequence.relativeFrom + parentSequence.cumulatedFrom : 0;\n    const { imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const startsAt = useMediaStartsAt();\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useMediaInTimeline.useState9\": ()=>volume\n    }[\"useMediaInTimeline.useState9\"]);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const nonce = useNonce();\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, videoConfig.durationInFrames) : videoConfig.durationInFrames;\n    const doesVolumeChange = typeof volume === \"function\";\n    const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useMediaInTimeline.useMemo13[volumes]\": ()=>{\n            if (typeof volume === \"number\") {\n                return volume;\n            }\n            return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map({\n                \"useMediaInTimeline.useMemo13[volumes]\": (_, i)=>{\n                    return evaluateVolume({\n                        frame: i + startsAt,\n                        volume,\n                        mediaVolume\n                    });\n                }\n            }[\"useMediaInTimeline.useMemo13[volumes]\"]).join(\",\");\n        }\n    }[\"useMediaInTimeline.useMemo13[volumes]\"], [\n        duration,\n        startsAt,\n        volume,\n        mediaVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaInTimeline.useEffect7\": ()=>{\n            if (typeof volume === \"number\" && volume !== initialVolume) {\n                warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/audio/volume`);\n            }\n        }\n    }[\"useMediaInTimeline.useEffect7\"], [\n        initialVolume,\n        mediaType,\n        src,\n        volume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaInTimeline.useEffect7\": ()=>{\n            if (!mediaRef.current) {\n                return;\n            }\n            if (!src) {\n                throw new Error(\"No src passed\");\n            }\n            if (!getRemotionEnvironment().isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n                return;\n            }\n            if (!showInTimeline) {\n                return;\n            }\n            registerSequence({\n                type: mediaType,\n                src,\n                id,\n                duration,\n                from: 0,\n                parent: parentSequence?.id ?? null,\n                displayName: displayName ?? getAssetDisplayName(src),\n                rootId,\n                volume: volumes,\n                showInTimeline: true,\n                nonce,\n                startMediaFrom: 0 - startsAt,\n                doesVolumeChange,\n                loopDisplay: undefined,\n                playbackRate,\n                stack,\n                premountDisplay\n            });\n            return ({\n                \"useMediaInTimeline.useEffect7\": ()=>{\n                    unregisterSequence(id);\n                }\n            })[\"useMediaInTimeline.useEffect7\"];\n        }\n    }[\"useMediaInTimeline.useEffect7\"], [\n        actualFrom,\n        duration,\n        id,\n        parentSequence,\n        src,\n        registerSequence,\n        rootId,\n        unregisterSequence,\n        videoConfig,\n        volumes,\n        doesVolumeChange,\n        nonce,\n        mediaRef,\n        mediaType,\n        startsAt,\n        playbackRate,\n        displayName,\n        stack,\n        showInTimeline,\n        premountDisplay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaInTimeline.useEffect7\": ()=>{\n            const tag = {\n                id,\n                play: {\n                    \"useMediaInTimeline.useEffect7\": (reason)=>{\n                        if (!imperativePlaying.current) {\n                            return;\n                        }\n                        if (isPremounting) {\n                            return;\n                        }\n                        return playAndHandleNotAllowedError({\n                            mediaRef,\n                            mediaType,\n                            onAutoPlayError,\n                            logLevel,\n                            mountTime,\n                            reason\n                        });\n                    }\n                }[\"useMediaInTimeline.useEffect7\"]\n            };\n            audioAndVideoTags.current.push(tag);\n            return ({\n                \"useMediaInTimeline.useEffect7\": ()=>{\n                    audioAndVideoTags.current = audioAndVideoTags.current.filter({\n                        \"useMediaInTimeline.useEffect7\": (a)=>a.id !== id\n                    }[\"useMediaInTimeline.useEffect7\"]);\n                }\n            })[\"useMediaInTimeline.useEffect7\"];\n        }\n    }[\"useMediaInTimeline.useEffect7\"], [\n        audioAndVideoTags,\n        id,\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        imperativePlaying,\n        isPremounting,\n        logLevel,\n        mountTime\n    ]);\n};\n// src/use-media-playback.ts\n\n// src/buffer-until-first-frame.ts\n\n// src/use-buffer-state.ts\n\n// src/buffering.tsx\n\n\nvar useBufferManager = (logLevel, mountTime)=>{\n    const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferManager.useCallback6[addBlock]\": (block)=>{\n            setBlocks({\n                \"useBufferManager.useCallback6[addBlock]\": (b)=>[\n                        ...b,\n                        block\n                    ]\n            }[\"useBufferManager.useCallback6[addBlock]\"]);\n            return {\n                unblock: ({\n                    \"useBufferManager.useCallback6[addBlock]\": ()=>{\n                        setBlocks({\n                            \"useBufferManager.useCallback6[addBlock]\": (b)=>{\n                                const newArr = b.filter({\n                                    \"useBufferManager.useCallback6[addBlock].newArr\": (bx)=>bx !== block\n                                }[\"useBufferManager.useCallback6[addBlock].newArr\"]);\n                                if (newArr.length === b.length) {\n                                    return b;\n                                }\n                                return newArr;\n                            }\n                        }[\"useBufferManager.useCallback6[addBlock]\"]);\n                    }\n                })[\"useBufferManager.useCallback6[addBlock]\"]\n            };\n        }\n    }[\"useBufferManager.useCallback6[addBlock]\"], []);\n    const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferManager.useCallback6[listenForBuffering]\": (callback)=>{\n            setOnBufferingCallbacks({\n                \"useBufferManager.useCallback6[listenForBuffering]\": (c)=>[\n                        ...c,\n                        callback\n                    ]\n            }[\"useBufferManager.useCallback6[listenForBuffering]\"]);\n            return {\n                remove: ({\n                    \"useBufferManager.useCallback6[listenForBuffering]\": ()=>{\n                        setOnBufferingCallbacks({\n                            \"useBufferManager.useCallback6[listenForBuffering]\": (c)=>c.filter({\n                                    \"useBufferManager.useCallback6[listenForBuffering]\": (cb)=>cb !== callback\n                                }[\"useBufferManager.useCallback6[listenForBuffering]\"])\n                        }[\"useBufferManager.useCallback6[listenForBuffering]\"]);\n                    }\n                })[\"useBufferManager.useCallback6[listenForBuffering]\"]\n            };\n        }\n    }[\"useBufferManager.useCallback6[listenForBuffering]\"], []);\n    const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferManager.useCallback6[listenForResume]\": (callback)=>{\n            setOnResumeCallbacks({\n                \"useBufferManager.useCallback6[listenForResume]\": (c)=>[\n                        ...c,\n                        callback\n                    ]\n            }[\"useBufferManager.useCallback6[listenForResume]\"]);\n            return {\n                remove: ({\n                    \"useBufferManager.useCallback6[listenForResume]\": ()=>{\n                        setOnResumeCallbacks({\n                            \"useBufferManager.useCallback6[listenForResume]\": (c)=>c.filter({\n                                    \"useBufferManager.useCallback6[listenForResume]\": (cb)=>cb !== callback\n                                }[\"useBufferManager.useCallback6[listenForResume]\"])\n                        }[\"useBufferManager.useCallback6[listenForResume]\"]);\n                    }\n                })[\"useBufferManager.useCallback6[listenForResume]\"]\n            };\n        }\n    }[\"useBufferManager.useCallback6[listenForResume]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBufferManager.useEffect8\": ()=>{\n            if (blocks.length > 0) {\n                onBufferingCallbacks.forEach({\n                    \"useBufferManager.useEffect8\": (c)=>c()\n                }[\"useBufferManager.useEffect8\"]);\n                playbackLogging({\n                    logLevel,\n                    message: \"Player is entering buffer state\",\n                    mountTime,\n                    tag: \"player\"\n                });\n            }\n        }\n    }[\"useBufferManager.useEffect8\"], [\n        blocks\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"useBufferManager.useLayoutEffect4\": ()=>{\n            if (blocks.length === 0) {\n                onResumeCallbacks.forEach({\n                    \"useBufferManager.useLayoutEffect4\": (c)=>c()\n                }[\"useBufferManager.useLayoutEffect4\"]);\n                playbackLogging({\n                    logLevel,\n                    message: \"Player is exiting buffer state\",\n                    mountTime,\n                    tag: \"player\"\n                });\n            }\n        }\n    }[\"useBufferManager.useLayoutEffect4\"], [\n        blocks\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBufferManager.useMemo14\": ()=>{\n            return {\n                addBlock,\n                listenForBuffering,\n                listenForResume,\n                buffering\n            };\n        }\n    }[\"useBufferManager.useMemo14\"], [\n        addBlock,\n        buffering,\n        listenForBuffering,\n        listenForResume\n    ]);\n};\nvar BufferingContextReact = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children })=>{\n    const { logLevel, mountTime } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LogLevelContext);\n    const bufferManager = useBufferManager(logLevel ?? \"info\", mountTime);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n        value: bufferManager,\n        children\n    });\n};\nvar useIsPlayerBuffering = (bufferManager)=>{\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useIsPlayerBuffering.useEffect8\": ()=>{\n            const onBuffer = {\n                \"useIsPlayerBuffering.useEffect8.onBuffer\": ()=>{\n                    setIsBuffering(true);\n                }\n            }[\"useIsPlayerBuffering.useEffect8.onBuffer\"];\n            const onResume = {\n                \"useIsPlayerBuffering.useEffect8.onResume\": ()=>{\n                    setIsBuffering(false);\n                }\n            }[\"useIsPlayerBuffering.useEffect8.onResume\"];\n            bufferManager.listenForBuffering(onBuffer);\n            bufferManager.listenForResume(onResume);\n            return ({\n                \"useIsPlayerBuffering.useEffect8\": ()=>{\n                    bufferManager.listenForBuffering({\n                        \"useIsPlayerBuffering.useEffect8\": ()=>{\n                            return;\n                        }\n                    }[\"useIsPlayerBuffering.useEffect8\"]);\n                    bufferManager.listenForResume({\n                        \"useIsPlayerBuffering.useEffect8\": ()=>{\n                            return;\n                        }\n                    }[\"useIsPlayerBuffering.useEffect8\"]);\n                }\n            })[\"useIsPlayerBuffering.useEffect8\"];\n        }\n    }[\"useIsPlayerBuffering.useEffect8\"], [\n        bufferManager\n    ]);\n    return isBuffering;\n};\n// src/use-buffer-state.ts\nvar useBufferState = ()=>{\n    const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const addBlock = buffer ? buffer.addBlock : null;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBufferState.useMemo15\": ()=>({\n                delayPlayback: ({\n                    \"useBufferState.useMemo15\": ()=>{\n                        if (!addBlock) {\n                            throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n                        }\n                        const { unblock } = addBlock({\n                            id: String(Math.random())\n                        });\n                        return {\n                            unblock\n                        };\n                    }\n                })[\"useBufferState.useMemo15\"]\n            })\n    }[\"useBufferState.useMemo15\"], [\n        addBlock\n    ]);\n};\n// src/buffer-until-first-frame.ts\nvar isSafariWebkit = ()=>{\n    const isSafari = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);\n    return isSafari;\n};\nvar useBufferUntilFirstFrame = ({ mediaRef, mediaType, onVariableFpsVideoDetected, pauseWhenBuffering, logLevel, mountTime })=>{\n    const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { delayPlayback } = useBufferState();\n    const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame]\": (requestedTime)=>{\n            if (mediaType !== \"video\") {\n                return;\n            }\n            if (!pauseWhenBuffering) {\n                return;\n            }\n            const current = mediaRef.current;\n            if (!current) {\n                return;\n            }\n            if (current.readyState >= current.HAVE_ENOUGH_DATA && !isSafariWebkit()) {\n                playbackLogging({\n                    logLevel,\n                    message: `Not using buffer until first frame, because readyState is ${current.readyState} and is not Safari`,\n                    mountTime,\n                    tag: \"buffer\"\n                });\n                return;\n            }\n            if (!current.requestVideoFrameCallback) {\n                playbackLogging({\n                    logLevel,\n                    message: `Not using buffer until first frame, because requestVideoFrameCallback is not supported`,\n                    mountTime,\n                    tag: \"buffer\"\n                });\n                return;\n            }\n            bufferingRef.current = true;\n            playbackLogging({\n                logLevel,\n                message: `Buffering ${mediaRef.current?.src} until the first frame is received`,\n                mountTime,\n                tag: \"buffer\"\n            });\n            const playback = delayPlayback();\n            const unblock = {\n                \"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame].unblock\": ()=>{\n                    playback.unblock();\n                    current.removeEventListener(\"ended\", unblock, {\n                        once: true\n                    });\n                    current.removeEventListener(\"pause\", unblock, {\n                        once: true\n                    });\n                    bufferingRef.current = false;\n                }\n            }[\"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame].unblock\"];\n            const onEndedOrPauseOrCanPlay = {\n                \"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame].onEndedOrPauseOrCanPlay\": ()=>{\n                    unblock();\n                }\n            }[\"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame].onEndedOrPauseOrCanPlay\"];\n            current.requestVideoFrameCallback({\n                \"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame]\": (_, info)=>{\n                    const differenceFromRequested = Math.abs(info.mediaTime - requestedTime);\n                    if (differenceFromRequested > 0.5) {\n                        onVariableFpsVideoDetected();\n                    }\n                    unblock();\n                }\n            }[\"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame]\"]);\n            current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, {\n                once: true\n            });\n            current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, {\n                once: true\n            });\n            current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n                once: true\n            });\n        }\n    }[\"useBufferUntilFirstFrame.useCallback7[bufferUntilFirstFrame]\"], [\n        delayPlayback,\n        logLevel,\n        mediaRef,\n        mediaType,\n        mountTime,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBufferUntilFirstFrame.useMemo16\": ()=>{\n            return {\n                isBuffering: ({\n                    \"useBufferUntilFirstFrame.useMemo16\": ()=>bufferingRef.current\n                })[\"useBufferUntilFirstFrame.useMemo16\"],\n                bufferUntilFirstFrame\n            };\n        }\n    }[\"useBufferUntilFirstFrame.useMemo16\"], [\n        bufferUntilFirstFrame\n    ]);\n};\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps)=>{\n    return Math.round(time / fps * 100) / 100;\n};\nvar isIosSafari = ()=>{\n    if (true) {\n        return false;\n    }\n    const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n    const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n    return isIpadIPodIPhone && isAppleWebKit;\n};\nvar isIOSSafariAndBlob = (actualSrc)=>{\n    return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({ actualFrom, fps })=>{\n    return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({ duration, fps })=>{\n    return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({ actualSrc, actualFrom, duration, fps })=>{\n    if (isIOSSafariAndBlob(actualSrc)) {\n        return actualSrc;\n    }\n    if (actualSrc.startsWith(\"data:\")) {\n        return actualSrc;\n    }\n    const existingHash = Boolean(new URL(actualSrc, ( null) ?? \"http://localhost:3000\").hash);\n    if (existingHash) {\n        return actualSrc;\n    }\n    if (!Number.isFinite(actualFrom)) {\n        return actualSrc;\n    }\n    const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({\n        actualFrom,\n        fps\n    })}`;\n    if (!Number.isFinite(duration)) {\n        return withStartHash;\n    }\n    return `${withStartHash},${getVideoFragmentEnd({\n        duration,\n        fps\n    })}`;\n};\nvar isSubsetOfDuration = ({ prevStartFrom, newStartFrom, prevDuration, newDuration, fps })=>{\n    const previousFrom = getVideoFragmentStart({\n        actualFrom: prevStartFrom,\n        fps\n    });\n    const newFrom = getVideoFragmentStart({\n        actualFrom: newStartFrom,\n        fps\n    });\n    const previousEnd = getVideoFragmentEnd({\n        duration: prevDuration,\n        fps\n    });\n    const newEnd = getVideoFragmentEnd({\n        duration: newDuration,\n        fps\n    });\n    if (newFrom < previousFrom) {\n        return false;\n    }\n    if (newEnd > previousEnd) {\n        return false;\n    }\n    return true;\n};\nvar useAppendVideoFragment = ({ actualSrc: initialActualSrc, actualFrom: initialActualFrom, duration: initialDuration, fps })=>{\n    const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n    const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n    if (!isSubsetOfDuration({\n        prevStartFrom: actualFromRef.current,\n        newStartFrom: initialActualFrom,\n        prevDuration: actualDuration.current,\n        newDuration: initialDuration,\n        fps\n    }) || initialActualSrc !== actualSrc.current) {\n        actualFromRef.current = initialActualFrom;\n        actualDuration.current = initialDuration;\n        actualSrc.current = initialActualSrc;\n    }\n    const appended = appendVideoFragment({\n        actualSrc: actualSrc.current,\n        actualFrom: actualFromRef.current,\n        duration: actualDuration.current,\n        fps\n    });\n    return appended;\n};\n// src/seek.ts\nvar seek = ({ mediaRef, time, logLevel, why, mountTime })=>{\n    const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n    playbackLogging({\n        logLevel,\n        tag: \"seek\",\n        message: `Seeking from ${mediaRef.currentTime} to ${timeToSet}. src= ${mediaRef.src} Reason: ${why}`,\n        mountTime\n    });\n    mediaRef.currentTime = timeToSet;\n    return timeToSet;\n};\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({ element, shouldBuffer, isPremounting, logLevel, mountTime })=>{\n    const buffer = useBufferState();\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaBuffering.useEffect9\": ()=>{\n            let cleanupFns = [];\n            const { current } = element;\n            if (!current) {\n                return;\n            }\n            if (!shouldBuffer) {\n                return;\n            }\n            if (isPremounting) {\n                if (current.readyState < current.HAVE_FUTURE_DATA) {\n                    if (!navigator.userAgent.includes(\"Firefox/\")) {\n                        playbackLogging({\n                            logLevel,\n                            message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted`,\n                            tag: \"load\",\n                            mountTime\n                        });\n                        current.load();\n                    }\n                }\n                return;\n            }\n            const cleanup = {\n                \"useMediaBuffering.useEffect9.cleanup\": (reason)=>{\n                    let didDoSomething = false;\n                    cleanupFns.forEach({\n                        \"useMediaBuffering.useEffect9.cleanup\": (fn)=>{\n                            fn(reason);\n                            didDoSomething = true;\n                        }\n                    }[\"useMediaBuffering.useEffect9.cleanup\"]);\n                    cleanupFns = [];\n                    setIsBuffering({\n                        \"useMediaBuffering.useEffect9.cleanup\": (previous)=>{\n                            if (previous) {\n                                didDoSomething = true;\n                            }\n                            return false;\n                        }\n                    }[\"useMediaBuffering.useEffect9.cleanup\"]);\n                    if (didDoSomething) {\n                        playbackLogging({\n                            logLevel,\n                            message: `Unmarking as buffering: ${current.src}. Reason: ${reason}`,\n                            tag: \"buffer\",\n                            mountTime\n                        });\n                    }\n                }\n            }[\"useMediaBuffering.useEffect9.cleanup\"];\n            const blockMedia = {\n                \"useMediaBuffering.useEffect9.blockMedia\": (reason)=>{\n                    setIsBuffering(true);\n                    playbackLogging({\n                        logLevel,\n                        message: `Marking as buffering: ${current.src}. Reason: ${reason}`,\n                        tag: \"buffer\",\n                        mountTime\n                    });\n                    const { unblock } = buffer.delayPlayback();\n                    const onCanPlay = {\n                        \"useMediaBuffering.useEffect9.blockMedia.onCanPlay\": ()=>{\n                            cleanup('\"canplay\" was fired');\n                            init();\n                        }\n                    }[\"useMediaBuffering.useEffect9.blockMedia.onCanPlay\"];\n                    const onError = {\n                        \"useMediaBuffering.useEffect9.blockMedia.onError\": ()=>{\n                            cleanup('\"error\" event was occurred');\n                            init();\n                        }\n                    }[\"useMediaBuffering.useEffect9.blockMedia.onError\"];\n                    current.addEventListener(\"canplay\", onCanPlay, {\n                        once: true\n                    });\n                    cleanupFns.push({\n                        \"useMediaBuffering.useEffect9.blockMedia\": ()=>{\n                            current.removeEventListener(\"canplay\", onCanPlay);\n                        }\n                    }[\"useMediaBuffering.useEffect9.blockMedia\"]);\n                    current.addEventListener(\"error\", onError, {\n                        once: true\n                    });\n                    cleanupFns.push({\n                        \"useMediaBuffering.useEffect9.blockMedia\": ()=>{\n                            current.removeEventListener(\"error\", onError);\n                        }\n                    }[\"useMediaBuffering.useEffect9.blockMedia\"]);\n                    cleanupFns.push({\n                        \"useMediaBuffering.useEffect9.blockMedia\": (cleanupReason)=>{\n                            playbackLogging({\n                                logLevel,\n                                message: `Unblocking ${current.src} from buffer. Reason: ${cleanupReason}`,\n                                tag: \"buffer\",\n                                mountTime\n                            });\n                            unblock();\n                        }\n                    }[\"useMediaBuffering.useEffect9.blockMedia\"]);\n                }\n            }[\"useMediaBuffering.useEffect9.blockMedia\"];\n            const init = {\n                \"useMediaBuffering.useEffect9.init\": ()=>{\n                    if (current.readyState < current.HAVE_FUTURE_DATA) {\n                        blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);\n                        if (!navigator.userAgent.includes(\"Firefox/\")) {\n                            playbackLogging({\n                                logLevel,\n                                message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox.`,\n                                tag: \"load\",\n                                mountTime\n                            });\n                            current.load();\n                        }\n                    } else {\n                        const onWaiting = {\n                            \"useMediaBuffering.useEffect9.init.onWaiting\": ()=>{\n                                blockMedia('\"waiting\" event was fired');\n                            }\n                        }[\"useMediaBuffering.useEffect9.init.onWaiting\"];\n                        current.addEventListener(\"waiting\", onWaiting);\n                        cleanupFns.push({\n                            \"useMediaBuffering.useEffect9.init\": ()=>{\n                                current.removeEventListener(\"waiting\", onWaiting);\n                            }\n                        }[\"useMediaBuffering.useEffect9.init\"]);\n                    }\n                }\n            }[\"useMediaBuffering.useEffect9.init\"];\n            init();\n            return ({\n                \"useMediaBuffering.useEffect9\": ()=>{\n                    cleanup(\"element was unmounted or prop changed\");\n                }\n            })[\"useMediaBuffering.useEffect9\"];\n        }\n    }[\"useMediaBuffering.useEffect9\"], [\n        buffer,\n        element,\n        isPremounting,\n        logLevel,\n        shouldBuffer,\n        mountTime\n    ]);\n    return isBuffering;\n};\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({ mediaRef, mediaType, lastSeek, onVariableFpsVideoDetected })=>{\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useRequestVideoCallbackTime.useEffect10\": ()=>{\n            const { current } = mediaRef;\n            if (current) {\n                currentTime.current = current.currentTime;\n            } else {\n                currentTime.current = null;\n                return;\n            }\n            if (mediaType !== \"video\") {\n                currentTime.current = null;\n                return;\n            }\n            const videoTag = current;\n            if (!videoTag.requestVideoFrameCallback) {\n                return;\n            }\n            let cancel = {\n                \"useRequestVideoCallbackTime.useEffect10.cancel\": ()=>{\n                    return;\n                }\n            }[\"useRequestVideoCallbackTime.useEffect10.cancel\"];\n            const request = {\n                \"useRequestVideoCallbackTime.useEffect10.request\": ()=>{\n                    if (!videoTag) {\n                        return;\n                    }\n                    const cb = videoTag.requestVideoFrameCallback({\n                        \"useRequestVideoCallbackTime.useEffect10.request.cb\": (_, info)=>{\n                            if (currentTime.current !== null) {\n                                const difference = Math.abs(currentTime.current - info.mediaTime);\n                                const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info.mediaTime - lastSeek.current);\n                                if (difference > 0.5 && differenceToLastSeek > 0.5 && info.mediaTime > currentTime.current) {\n                                    onVariableFpsVideoDetected();\n                                }\n                            }\n                            currentTime.current = info.mediaTime;\n                            request();\n                        }\n                    }[\"useRequestVideoCallbackTime.useEffect10.request.cb\"]);\n                    cancel = ({\n                        \"useRequestVideoCallbackTime.useEffect10.request\": ()=>{\n                            videoTag.cancelVideoFrameCallback(cb);\n                            cancel = ({\n                                \"useRequestVideoCallbackTime.useEffect10.request\": ()=>{\n                                    return;\n                                }\n                            })[\"useRequestVideoCallbackTime.useEffect10.request\"];\n                        }\n                    })[\"useRequestVideoCallbackTime.useEffect10.request\"];\n                }\n            }[\"useRequestVideoCallbackTime.useEffect10.request\"];\n            request();\n            return ({\n                \"useRequestVideoCallbackTime.useEffect10\": ()=>{\n                    cancel();\n                }\n            })[\"useRequestVideoCallbackTime.useEffect10\"];\n        }\n    }[\"useRequestVideoCallbackTime.useEffect10\"], [\n        lastSeek,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected\n    ]);\n    return currentTime;\n};\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\nvar getMediaTime = ({ fps, frame, playbackRate, startFrom })=>{\n    const expectedFrame = getExpectedMediaFrameUncorrected({\n        frame,\n        playbackRate,\n        startFrom\n    });\n    const msPerFrame = 1000 / fps;\n    return expectedFrame * msPerFrame / 1000;\n};\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type)=>{\n    if (ref === null) {\n        return;\n    }\n    if (ref.seekable.length === 0) {\n        return;\n    }\n    if (ref.seekable.length > 1) {\n        return;\n    }\n    if (alreadyWarned[ref.src]) {\n        return;\n    }\n    const range = {\n        start: ref.seekable.start(0),\n        end: ref.seekable.end(0)\n    };\n    if (range.start === 0 && range.end === 0) {\n        const msg = [\n            `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n            \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n            \"2) The media does not support seeking.\",\n            \"3) The media was loaded with security headers prventing it from being included.\",\n            \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n        ].join(`\n`);\n        if (type === \"console-error\") {\n            console.error(msg);\n        } else if (type === \"console-warning\") {\n            console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n        } else {\n            throw new Error(msg);\n        }\n        alreadyWarned[ref.src] = true;\n    }\n};\n// src/use-media-playback.ts\nvar useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, pauseWhenBuffering, isPremounting, onAutoPlayError, userPreferredVolume })=>{\n    const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const frame = useCurrentFrame();\n    const absoluteFrame = useTimelinePosition();\n    const [playing] = usePlayingState();\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const { fps } = useVideoConfig();\n    const mediaStartsAt = useMediaStartsAt();\n    const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    if (!buffering) {\n        throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n    }\n    const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMediaPlayback.useCallback8[onVariableFpsVideoDetected]\": ()=>{\n            if (!src) {\n                return;\n            }\n            Log.verbose(logLevel, `Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n            isVariableFpsVideoMap.current[src] = true;\n        }\n    }[\"useMediaPlayback.useCallback8[onVariableFpsVideoDetected]\"], [\n        logLevel,\n        src\n    ]);\n    const currentTime = useRequestVideoCallbackTime({\n        mediaRef,\n        mediaType,\n        lastSeek,\n        onVariableFpsVideoDetected\n    });\n    const desiredUnclampedTime = getMediaTime({\n        frame,\n        playbackRate: localPlaybackRate,\n        startFrom: -mediaStartsAt,\n        fps\n    });\n    const isMediaTagBuffering = useMediaBuffering({\n        element: mediaRef,\n        shouldBuffer: pauseWhenBuffering,\n        isPremounting,\n        logLevel,\n        mountTime\n    });\n    const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering,\n        logLevel,\n        mountTime\n    });\n    const playbackRate = localPlaybackRate * globalPlaybackRate;\n    const acceptableTimeShiftButLessThanDuration = (()=>{\n        const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK = 0.45;\n        const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK + 0.2;\n        const defaultAcceptableTimeshift = getShouldAmplify(userPreferredVolume) ? DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION : DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK;\n        if (mediaRef.current?.duration) {\n            return Math.min(mediaRef.current.duration, acceptableTimeshift ?? defaultAcceptableTimeshift);\n        }\n        return acceptableTimeshift ?? defaultAcceptableTimeshift;\n    })();\n    const isPlayerBuffering = useIsPlayerBuffering(buffering);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaPlayback.useEffect11\": ()=>{\n            if (mediaRef.current?.paused) {\n                return;\n            }\n            if (!playing) {\n                playbackLogging({\n                    logLevel,\n                    tag: \"pause\",\n                    message: `Pausing ${mediaRef.current?.src} because ${isPremounting ? \"media is premounting\" : \"Player is not playing\"}`,\n                    mountTime\n                });\n                mediaRef.current?.pause();\n                return;\n            }\n            const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n            const playerBufferingNotStateButLive = buffering.buffering.current;\n            if (playerBufferingNotStateButLive && !isMediaTagBufferingOrStalled) {\n                playbackLogging({\n                    logLevel,\n                    tag: \"pause\",\n                    message: `Pausing ${mediaRef.current?.src} because player is buffering but media tag is not`,\n                    mountTime\n                });\n                mediaRef.current?.pause();\n            }\n        }\n    }[\"useMediaPlayback.useEffect11\"], [\n        isBuffering,\n        isMediaTagBuffering,\n        buffering,\n        isPlayerBuffering,\n        isPremounting,\n        logLevel,\n        mediaRef,\n        mediaType,\n        mountTime,\n        playing\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaPlayback.useEffect11\": ()=>{\n            const tagName = mediaType === \"audio\" ? \"<Audio>\" : \"<Video>\";\n            if (!mediaRef.current) {\n                throw new Error(`No ${mediaType} ref found`);\n            }\n            if (!src) {\n                throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n            }\n            const playbackRateToSet = Math.max(0, playbackRate);\n            if (mediaRef.current.playbackRate !== playbackRateToSet) {\n                mediaRef.current.playbackRate = playbackRateToSet;\n            }\n            const { duration } = mediaRef.current;\n            const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n            const mediaTagTime = mediaRef.current.currentTime;\n            const rvcTime = currentTime.current ?? null;\n            const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n            const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n            const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n            const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? timeShiftRvcTag : timeShiftMediaTag;\n            if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n                lastSeek.current = seek({\n                    mediaRef: mediaRef.current,\n                    time: shouldBeTime,\n                    logLevel,\n                    why: `because time shift is too big. shouldBeTime = ${shouldBeTime}, isTime = ${mediaTagTime}, requestVideoCallbackTime = ${rvcTime}, timeShift = ${timeShift}${isVariableFpsVideo ? \", isVariableFpsVideo = true\" : \"\"}, isPremounting = ${isPremounting}, pauseWhenBuffering = ${pauseWhenBuffering}`,\n                    mountTime\n                });\n                lastSeekDueToShift.current = lastSeek.current;\n                if (playing) {\n                    if (playbackRate > 0) {\n                        bufferUntilFirstFrame(shouldBeTime);\n                    }\n                    if (mediaRef.current.paused) {\n                        playAndHandleNotAllowedError({\n                            mediaRef,\n                            mediaType,\n                            onAutoPlayError,\n                            logLevel,\n                            mountTime,\n                            reason: \"player is playing but media tag is paused, and just seeked\"\n                        });\n                    }\n                }\n                if (!onlyWarnForMediaSeekingError) {\n                    warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n                }\n                return;\n            }\n            const seekThreshold = playing ? 0.15 : 0.01;\n            const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n            const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n            const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n            if (!playing || isSomethingElseBuffering) {\n                if (makesSenseToSeek) {\n                    lastSeek.current = seek({\n                        mediaRef: mediaRef.current,\n                        time: shouldBeTime,\n                        logLevel,\n                        why: `not playing or something else is buffering. time offset is over seek threshold (${seekThreshold})`,\n                        mountTime\n                    });\n                }\n                return;\n            }\n            if (!playing || buffering.buffering.current) {\n                return;\n            }\n            const pausedCondition = mediaRef.current.paused && !mediaRef.current.ended;\n            const firstFrameCondition = absoluteFrame === 0;\n            if (pausedCondition || firstFrameCondition) {\n                const reason = pausedCondition ? \"media tag is paused\" : \"absolute frame is 0\";\n                if (makesSenseToSeek) {\n                    lastSeek.current = seek({\n                        mediaRef: mediaRef.current,\n                        time: shouldBeTime,\n                        logLevel,\n                        why: `is over timeshift threshold (threshold = ${seekThreshold}) and ${reason}`,\n                        mountTime\n                    });\n                }\n                playAndHandleNotAllowedError({\n                    mediaRef,\n                    mediaType,\n                    onAutoPlayError,\n                    logLevel,\n                    mountTime,\n                    reason: `player is playing and ${reason}`\n                });\n                if (!isVariableFpsVideo && playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n            }\n        }\n    }[\"useMediaPlayback.useEffect11\"], [\n        absoluteFrame,\n        acceptableTimeShiftButLessThanDuration,\n        bufferUntilFirstFrame,\n        buffering.buffering,\n        currentTime,\n        logLevel,\n        desiredUnclampedTime,\n        isBuffering,\n        isMediaTagBuffering,\n        mediaRef,\n        mediaType,\n        onlyWarnForMediaSeekingError,\n        playbackRate,\n        playing,\n        src,\n        onAutoPlayError,\n        isPremounting,\n        pauseWhenBuffering,\n        mountTime\n    ]);\n};\n// src/use-sync-volume-with-media-tag.ts\n\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2)=>{\n    return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n// src/use-sync-volume-with-media-tag.ts\nvar useSyncVolumeWithMediaTag = ({ volumePropFrame, volume, mediaVolume, mediaRef })=>{\n    const adjustVolume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSyncVolumeWithMediaTag.useCallback9[adjustVolume]\": ()=>{\n            if (!mediaRef.current) {\n                return;\n            }\n            const userPreferredVolume = evaluateVolume({\n                frame: volumePropFrame,\n                volume,\n                mediaVolume\n            });\n            if (!isApproximatelyTheSame(userPreferredVolume, mediaRef.current.volume)) {\n                mediaRef.current.volume = Math.min(userPreferredVolume, 1);\n            }\n        }\n    }[\"useSyncVolumeWithMediaTag.useCallback9[adjustVolume]\"], [\n        mediaRef,\n        mediaVolume,\n        volume,\n        volumePropFrame\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncVolumeWithMediaTag.useEffect12\": ()=>{\n            adjustVolume();\n        }\n    }[\"useSyncVolumeWithMediaTag.useEffect12\"], [\n        adjustVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSyncVolumeWithMediaTag.useEffect12\": ()=>{\n            const media = mediaRef.current;\n            if (!media) {\n                return;\n            }\n            const handleVolumeChange = {\n                \"useSyncVolumeWithMediaTag.useEffect12.handleVolumeChange\": ()=>{\n                    adjustVolume();\n                }\n            }[\"useSyncVolumeWithMediaTag.useEffect12.handleVolumeChange\"];\n            media.addEventListener(\"volumechange\", handleVolumeChange);\n            return ({\n                \"useSyncVolumeWithMediaTag.useEffect12\": ()=>{\n                    media.removeEventListener(\"volumechange\", handleVolumeChange);\n                }\n            })[\"useSyncVolumeWithMediaTag.useEffect12\"];\n        }\n    }[\"useSyncVolumeWithMediaTag.useEffect12\"], [\n        adjustVolume,\n        mediaRef\n    ]);\n};\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    mediaMuted: false,\n    mediaVolume: 1\n});\nvar SetMediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setMediaMuted: ()=>{\n        throw new Error(\"default\");\n    },\n    setMediaVolume: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar useMediaVolumeState = ()=>{\n    const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useMediaVolumeState.useMemo17\": ()=>{\n            return [\n                mediaVolume,\n                setMediaVolume\n            ];\n        }\n    }[\"useMediaVolumeState.useMemo17\"], [\n        mediaVolume,\n        setMediaVolume\n    ]);\n};\nvar useMediaMutedState = ()=>{\n    const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useMediaMutedState.useMemo17\": ()=>{\n            return [\n                mediaMuted,\n                setMediaMuted\n            ];\n        }\n    }[\"useMediaMutedState.useMemo17\"], [\n        mediaMuted,\n        setMediaMuted\n    ]);\n};\n// src/audio/shared-audio-tags.tsx\n\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2)=>{\n    const keysA = Object.keys(obj1).sort();\n    const keysB = Object.keys(obj2).sort();\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for(let i = 0; i < keysA.length; i++){\n        if (keysA[i] !== keysB[i]) {\n            return false;\n        }\n        if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n            return false;\n        }\n    }\n    return true;\n};\nvar didPropChange = (key, newProp, prevProp)=>{\n    if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n        return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n    }\n    if (prevProp === newProp) {\n        return false;\n    }\n    return true;\n};\nvar SharedAudioContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, component })=>{\n    const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n    if (numberOfAudioTags !== initialNumberOfAudioTags) {\n        throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n    }\n    const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SharedAudioContextProvider.useMemo18[refs]\": ()=>{\n            return new Array(numberOfAudioTags).fill(true).map({\n                \"SharedAudioContextProvider.useMemo18[refs]\": ()=>{\n                    return {\n                        id: Math.random(),\n                        ref: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n                    };\n                }\n            }[\"SharedAudioContextProvider.useMemo18[refs]\"]);\n        }\n    }[\"SharedAudioContextProvider.useMemo18[refs]\"], [\n        numberOfAudioTags\n    ]);\n    const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n    const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback10[rerenderAudios]\": ()=>{\n            refs.forEach({\n                \"SharedAudioContextProvider.useCallback10[rerenderAudios]\": ({ ref, id })=>{\n                    const data = audios.current?.find({\n                        \"SharedAudioContextProvider.useCallback10[rerenderAudios]\": (a)=>a.id === id\n                    }[\"SharedAudioContextProvider.useCallback10[rerenderAudios]\"]);\n                    const { current } = ref;\n                    if (!current) {\n                        return;\n                    }\n                    if (data === undefined) {\n                        current.src = EMPTY_AUDIO;\n                        return;\n                    }\n                    if (!data) {\n                        throw new TypeError(\"Expected audio data to be there\");\n                    }\n                    Object.keys(data.props).forEach({\n                        \"SharedAudioContextProvider.useCallback10[rerenderAudios]\": (key)=>{\n                            if (didPropChange(key, data.props[key], current[key])) {\n                                current[key] = data.props[key];\n                            }\n                        }\n                    }[\"SharedAudioContextProvider.useCallback10[rerenderAudios]\"]);\n                }\n            }[\"SharedAudioContextProvider.useCallback10[rerenderAudios]\"]);\n        }\n    }[\"SharedAudioContextProvider.useCallback10[rerenderAudios]\"], [\n        refs\n    ]);\n    const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback10[registerAudio]\": (aud, audioId)=>{\n            const found = audios.current?.find({\n                \"SharedAudioContextProvider.useCallback10[registerAudio]\": (a)=>a.audioId === audioId\n            }[\"SharedAudioContextProvider.useCallback10[registerAudio]\"]);\n            if (found) {\n                return found;\n            }\n            const firstFreeAudio = takenAudios.current.findIndex({\n                \"SharedAudioContextProvider.useCallback10[registerAudio].firstFreeAudio\": (a)=>a === false\n            }[\"SharedAudioContextProvider.useCallback10[registerAudio].firstFreeAudio\"]);\n            if (firstFreeAudio === -1) {\n                throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#using-the-numberofsharedaudiotags-prop for more information on how to increase this limit.`);\n            }\n            const { id, ref } = refs[firstFreeAudio];\n            const cloned = [\n                ...takenAudios.current\n            ];\n            cloned[firstFreeAudio] = id;\n            takenAudios.current = cloned;\n            const newElem = {\n                props: aud,\n                id,\n                el: ref,\n                audioId\n            };\n            audios.current?.push(newElem);\n            rerenderAudios();\n            return newElem;\n        }\n    }[\"SharedAudioContextProvider.useCallback10[registerAudio]\"], [\n        numberOfAudioTags,\n        refs,\n        rerenderAudios\n    ]);\n    const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback10[unregisterAudio]\": (id)=>{\n            const cloned = [\n                ...takenAudios.current\n            ];\n            const index = refs.findIndex({\n                \"SharedAudioContextProvider.useCallback10[unregisterAudio].index\": (r)=>r.id === id\n            }[\"SharedAudioContextProvider.useCallback10[unregisterAudio].index\"]);\n            if (index === -1) {\n                throw new TypeError(\"Error occured in \");\n            }\n            cloned[index] = false;\n            takenAudios.current = cloned;\n            audios.current = audios.current?.filter({\n                \"SharedAudioContextProvider.useCallback10[unregisterAudio]\": (a)=>a.id !== id\n            }[\"SharedAudioContextProvider.useCallback10[unregisterAudio]\"]);\n            rerenderAudios();\n        }\n    }[\"SharedAudioContextProvider.useCallback10[unregisterAudio]\"], [\n        refs,\n        rerenderAudios\n    ]);\n    const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback10[updateAudio]\": ({ aud, audioId, id })=>{\n            let changed = false;\n            audios.current = audios.current?.map({\n                \"SharedAudioContextProvider.useCallback10[updateAudio]\": (prevA)=>{\n                    if (prevA.id === id) {\n                        const isTheSame = compareProps(aud, prevA.props);\n                        if (isTheSame) {\n                            return prevA;\n                        }\n                        changed = true;\n                        return {\n                            ...prevA,\n                            props: aud,\n                            audioId\n                        };\n                    }\n                    return prevA;\n                }\n            }[\"SharedAudioContextProvider.useCallback10[updateAudio]\"]);\n            if (changed) {\n                rerenderAudios();\n            }\n        }\n    }[\"SharedAudioContextProvider.useCallback10[updateAudio]\"], [\n        rerenderAudios\n    ]);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback10[playAllAudios]\": ()=>{\n            refs.forEach({\n                \"SharedAudioContextProvider.useCallback10[playAllAudios]\": (ref)=>{\n                    playAndHandleNotAllowedError({\n                        mediaRef: ref.ref,\n                        mediaType: \"audio\",\n                        onAutoPlayError: null,\n                        logLevel,\n                        mountTime,\n                        reason: \"playing all audios\"\n                    });\n                }\n            }[\"SharedAudioContextProvider.useCallback10[playAllAudios]\"]);\n        }\n    }[\"SharedAudioContextProvider.useCallback10[playAllAudios]\"], [\n        logLevel,\n        mountTime,\n        refs\n    ]);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SharedAudioContextProvider.useMemo18[value]\": ()=>{\n            return {\n                registerAudio,\n                unregisterAudio,\n                updateAudio,\n                playAllAudios,\n                numberOfAudioTags\n            };\n        }\n    }[\"SharedAudioContextProvider.useMemo18[value]\"], [\n        numberOfAudioTags,\n        playAllAudios,\n        registerAudio,\n        unregisterAudio,\n        updateAudio\n    ]);\n    const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback10[resetAudio]\": ()=>{\n            takenAudios.current = new Array(numberOfAudioTags).fill(false);\n            audios.current = [];\n            rerenderAudios();\n        }\n    }[\"SharedAudioContextProvider.useCallback10[resetAudio]\"], [\n        numberOfAudioTags,\n        rerenderAudios\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"SharedAudioContextProvider.useEffect13\": ()=>{\n            return ({\n                \"SharedAudioContextProvider.useEffect13\": ()=>{\n                    resetAudio();\n                }\n            })[\"SharedAudioContextProvider.useEffect13\"];\n        }\n    }[\"SharedAudioContextProvider.useEffect13\"], [\n        component,\n        resetAudio\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n        value,\n        children: [\n            refs.map(({ id, ref })=>{\n                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n                    ref,\n                    preload: \"metadata\",\n                    src: EMPTY_AUDIO\n                }, id);\n            }),\n            children\n        ]\n    });\n};\nvar useSharedAudio = (aud, audioId)=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useSharedAudio.useState12\": ()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                return ctx.registerAudio(aud, audioId);\n            }\n            return {\n                el: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                id: Math.random(),\n                props: aud,\n                audioId\n            };\n        }\n    }[\"useSharedAudio.useState12\"]);\n    const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n    if (typeof document !== \"undefined\") {\n        effectToUse(()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                ctx.updateAudio({\n                    id: elem.id,\n                    aud,\n                    audioId\n                });\n            }\n        }, [\n            aud,\n            ctx,\n            elem.id,\n            audioId\n        ]);\n        effectToUse(()=>{\n            return ()=>{\n                if (ctx && ctx.numberOfAudioTags > 0) {\n                    ctx.unregisterAudio(elem.id);\n                }\n            };\n        }, [\n            ctx,\n            elem.id\n        ]);\n    }\n    return elem;\n};\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref)=>{\n    const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n    if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n        throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n    }\n    const logLevel = useLogLevel();\n    const { volume, muted, playbackRate, shouldPreMountAudioTags, src, onDuration, acceptableTimeShiftInSeconds, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, _remotionInternalStack, allowAmplificationDuringRender, name, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, stack, ...nativeProps } = props;\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    if (!src) {\n        throw new TypeError(\"No 'src' was passed to <Audio>.\");\n    }\n    const preloadedSrc = usePreload(src);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"AudioForDevelopmentForwardRefFunction.useState13\": ()=>String(Math.random())\n    }[\"AudioForDevelopmentForwardRefFunction.useState13\"]);\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume\n    });\n    const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AudioForDevelopmentForwardRefFunction.useMemo19[propsToPass]\": ()=>{\n            return {\n                muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n                src: preloadedSrc,\n                loop: _remotionInternalNativeLoopPassed,\n                ...nativeProps\n            };\n        }\n    }[\"AudioForDevelopmentForwardRefFunction.useMemo19[propsToPass]\"], [\n        _remotionInternalNativeLoopPassed,\n        isSequenceHidden,\n        mediaMuted,\n        muted,\n        nativeProps,\n        preloadedSrc,\n        userPreferredVolume\n    ]);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AudioForDevelopmentForwardRefFunction.useMemo19[id]\": ()=>`audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`\n    }[\"AudioForDevelopmentForwardRefFunction.useMemo19[id]\"], [\n        src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames,\n        props.muted,\n        props.loop\n    ]);\n    const audioRef = useSharedAudio(propsToPass, id).el;\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        volume,\n        mediaVolume,\n        mediaRef: audioRef\n    });\n    useMediaInTimeline({\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: null,\n        isPremounting: Boolean(sequenceContext?.premounting)\n    });\n    useAmplification({\n        logLevel,\n        mediaRef: audioRef,\n        volume: userPreferredVolume\n    });\n    useMediaPlayback({\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        onlyWarnForMediaSeekingError: false,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n        isPremounting: Boolean(sequenceContext?.premounting),\n        pauseWhenBuffering,\n        onAutoPlayError: null,\n        userPreferredVolume\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"AudioForDevelopmentForwardRefFunction.useImperativeHandle5\": ()=>{\n            return audioRef.current;\n        }\n    }[\"AudioForDevelopmentForwardRefFunction.useImperativeHandle5\"], [\n        audioRef\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AudioForDevelopmentForwardRefFunction.useEffect14\": ()=>{\n            const { current } = audioRef;\n            if (!current) {\n                return;\n            }\n            if (current.duration) {\n                currentOnDurationCallback.current?.(current.src, current.duration);\n                return;\n            }\n            const onLoadedMetadata = {\n                \"AudioForDevelopmentForwardRefFunction.useEffect14.onLoadedMetadata\": ()=>{\n                    currentOnDurationCallback.current?.(current.src, current.duration);\n                }\n            }[\"AudioForDevelopmentForwardRefFunction.useEffect14.onLoadedMetadata\"];\n            current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n            return ({\n                \"AudioForDevelopmentForwardRefFunction.useEffect14\": ()=>{\n                    current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n                }\n            })[\"AudioForDevelopmentForwardRefFunction.useEffect14\"];\n        }\n    }[\"AudioForDevelopmentForwardRefFunction.useEffect14\"], [\n        audioRef,\n        src\n    ]);\n    if (initialShouldPreMountAudioElements) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        ...propsToPass\n    });\n};\nvar AudioForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n// src/audio/AudioForRendering.tsx\n\n\nvar AudioForRenderingRefForwardingFunction = (props, ref)=>{\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume: volumeProp, playbackRate, allowAmplificationDuringRender, onDuration, toneFrequency, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, acceptableTimeShiftInSeconds, name, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, pauseWhenBuffering, ...nativeProps } = props;\n    const absoluteFrame = useTimelinePosition();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const frame = useCurrentFrame();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AudioForRenderingRefForwardingFunction.useMemo20[id]\": ()=>`audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`\n    }[\"AudioForRenderingRefForwardingFunction.useMemo20[id]\"], [\n        props.src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"AudioForRenderingRefForwardingFunction.useImperativeHandle6\": ()=>{\n            return audioRef.current;\n        }\n    }[\"AudioForRenderingRefForwardingFunction.useImperativeHandle6\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AudioForRenderingRefForwardingFunction.useEffect15\": ()=>{\n            if (!props.src) {\n                throw new Error(\"No src passed\");\n            }\n            if (!window.remotion_audioEnabled) {\n                return;\n            }\n            if (props.muted) {\n                return;\n            }\n            if (volume <= 0) {\n                return;\n            }\n            registerRenderAsset({\n                type: \"audio\",\n                src: getAbsoluteSrc(props.src),\n                id,\n                frame: absoluteFrame,\n                volume,\n                mediaFrame: frame,\n                playbackRate: props.playbackRate ?? 1,\n                toneFrequency: toneFrequency ?? null,\n                audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n            });\n            return ({\n                \"AudioForRenderingRefForwardingFunction.useEffect15\": ()=>unregisterRenderAsset(id)\n            })[\"AudioForRenderingRefForwardingFunction.useEffect15\"];\n        }\n    }[\"AudioForRenderingRefForwardingFunction.useEffect15\"], [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        absoluteFrame,\n        id,\n        unregisterRenderAsset,\n        volume,\n        volumePropFrame,\n        frame,\n        playbackRate,\n        props.playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const { src } = props;\n    const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"AudioForRenderingRefForwardingFunction.useLayoutEffect5\": ()=>{\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                return;\n            }\n            if (!needsToRenderAudioTag) {\n                return;\n            }\n            const newHandle = delayRender(\"Loading <Audio> duration with src=\" + src, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const { current } = audioRef;\n            const didLoad = {\n                \"AudioForRenderingRefForwardingFunction.useLayoutEffect5.didLoad\": ()=>{\n                    if (current?.duration) {\n                        onDuration(current.src, current.duration);\n                    }\n                    continueRender(newHandle);\n                }\n            }[\"AudioForRenderingRefForwardingFunction.useLayoutEffect5.didLoad\"];\n            if (current?.duration) {\n                onDuration(current.src, current.duration);\n                continueRender(newHandle);\n            } else {\n                current?.addEventListener(\"loadedmetadata\", didLoad, {\n                    once: true\n                });\n            }\n            return ({\n                \"AudioForRenderingRefForwardingFunction.useLayoutEffect5\": ()=>{\n                    current?.removeEventListener(\"loadedmetadata\", didLoad);\n                    continueRender(newHandle);\n                }\n            })[\"AudioForRenderingRefForwardingFunction.useLayoutEffect5\"];\n        }\n    }[\"AudioForRenderingRefForwardingFunction.useLayoutEffect5\"], [\n        src,\n        onDuration,\n        needsToRenderAudioTag,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds\n    ]);\n    if (!needsToRenderAudioTag) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        ...nativeProps\n    });\n};\nvar AudioForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref)=>{\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const { startFrom, endAt, name, stack, pauseWhenBuffering, showInTimeline, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof props.src !== \"string\") {\n        throw new TypeError(`The \\`<Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props.src);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"AudioRefForwardingFunction.useCallback11[onError]\": (e)=>{\n            console.log(e.currentTarget.error);\n            const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n            if (loop) {\n                cancelRender(new Error(errMessage));\n            } else {\n                console.warn(errMessage);\n            }\n        }\n    }[\"AudioRefForwardingFunction.useCallback11[onError]\"], [\n        loop,\n        preloadedSrc\n    ]);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"AudioRefForwardingFunction.useCallback11[onDuration]\": (src, durationInSeconds)=>{\n            setDurations({\n                type: \"got-duration\",\n                durationInSeconds,\n                src\n            });\n        }\n    }[\"AudioRefForwardingFunction.useCallback11[onDuration]\"], [\n        setDurations\n    ]);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n    if (loop && durationFetched !== undefined) {\n        if (!Number.isFinite(durationFetched)) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            });\n        }\n        const duration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            layout: \"none\",\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration: duration,\n                playbackRate: props.playbackRate ?? 1,\n                startFrom\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                _remotionInternalNeedsDurationCalculation: Boolean(loop),\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props, \"Audio\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n            onDuration,\n            ...props,\n            ref,\n            onError,\n            _remotionInternalNeedsDurationCalculation: Boolean(loop)\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n        _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n        _remotionInternalStack: stack ?? null,\n        shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n        ...props,\n        ref,\n        onError,\n        onDuration,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        showInTimeline: showInTimeline ?? true\n    });\n};\nvar Audio = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Audio);\n// src/Composition.tsx\n\n\n// src/Folder.tsx\n\n// src/validation/validate-folder-name.ts\nvar getRegex = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name)=>name.match(getRegex());\nvar validateFolderName = (name)=>{\n    if (name === undefined || name === null) {\n        throw new TypeError(\"You must pass a name to a <Folder />.\");\n    }\n    if (typeof name !== \"string\") {\n        throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n    }\n    if (!isFolderNameValid(name)) {\n        throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n    }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n// src/Folder.tsx\n\nvar FolderContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    folderName: null,\n    parentName: null\n});\nvar Folder = ({ name, children })=>{\n    const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    validateFolderName(name);\n    const parentNameArr = [\n        parent.parentName,\n        parent.folderName\n    ].filter(truthy);\n    const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Folder.useMemo21[value]\": ()=>{\n            return {\n                folderName: name,\n                parentName\n            };\n        }\n    }[\"Folder.useMemo21[value]\"], [\n        name,\n        parentName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Folder.useEffect16\": ()=>{\n            registerFolder(name, parentName);\n            return ({\n                \"Folder.useEffect16\": ()=>{\n                    unregisterFolder(name, parentName);\n                }\n            })[\"Folder.useEffect16\"];\n        }\n    }[\"Folder.useEffect16\"], [\n        name,\n        parent.folderName,\n        parentName,\n        registerFolder,\n        unregisterFolder\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n        value,\n        children\n    });\n};\n// src/loading-indicator.tsx\n\nvar rotate = {\n    transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n    color: \"white\",\n    fontSize: 14,\n    fontFamily: \"sans-serif\"\n};\nvar container = {\n    justifyContent: \"center\",\n    alignItems: \"center\"\n};\nvar Loading = ()=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n        style: container,\n        id: \"remotion-comp-loading\",\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n                type: \"text/css\",\n                children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                width: ICON_SIZE,\n                height: ICON_SIZE,\n                viewBox: \"-100 -100 400 400\",\n                style: rotate,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                    fill: \"#555\",\n                    stroke: \"#555\",\n                    strokeWidth: \"100\",\n                    strokeLinejoin: \"round\",\n                    d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n                })\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n                style: label,\n                children: [\n                    \"Resolving \",\n                    \"<Suspense>\",\n                    \"...\"\n                ]\n            })\n        ]\n    });\n};\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = ()=>{\n    if (!_portalNode) {\n        if (typeof document === \"undefined\") {\n            throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n        }\n        _portalNode = document.createElement(\"div\");\n        _portalNode.style.position = \"absolute\";\n        _portalNode.style.top = \"0px\";\n        _portalNode.style.left = \"0px\";\n        _portalNode.style.right = \"0px\";\n        _portalNode.style.bottom = \"0px\";\n        _portalNode.style.width = \"100%\";\n        _portalNode.style.height = \"100%\";\n        _portalNode.style.display = \"flex\";\n        _portalNode.style.flexDirection = \"column\";\n        const containerNode = document.createElement(\"div\");\n        containerNode.style.position = \"fixed\";\n        containerNode.style.top = -999999 + \"px\";\n        containerNode.appendChild(_portalNode);\n        document.body.appendChild(containerNode);\n    }\n    return _portalNode;\n};\n// src/use-lazy-component.ts\n\nvar useLazyComponent = ({ compProps, componentName, noSuspense })=>{\n    const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useLazyComponent.useMemo22[lazy]\": ()=>{\n            if (\"component\" in compProps) {\n                if (typeof document === \"undefined\" || noSuspense) {\n                    return compProps.component;\n                }\n                if (typeof compProps.component === \"undefined\") {\n                    throw new Error(`A value of \\`undefined\\` was passed to the \\`component\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy({\n                    \"useLazyComponent.useMemo22[lazy]\": ()=>Promise.resolve({\n                            default: compProps.component\n                        })\n                }[\"useLazyComponent.useMemo22[lazy]\"]);\n            }\n            if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n                if (typeof compProps.lazyComponent === \"undefined\") {\n                    throw new Error(`A value of \\`undefined\\` was passed to the \\`lazyComponent\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n            }\n            throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n        }\n    }[\"useLazyComponent.useMemo22[lazy]\"], [\n        compProps.component,\n        compProps.lazyComponent\n    ]);\n    return lazy;\n};\n// src/validation/validate-composition-id.ts\nvar getRegex2 = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id)=>id.match(getRegex2());\nvar validateCompositionId = (id)=>{\n    if (!isCompositionIdValid(id)) {\n        throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n    }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/Composition.tsx\n\nvar Fallback = ()=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Fallback.useEffect17\": ()=>{\n            const fallback = delayRender(\"Waiting for Root component to unsuspend\");\n            return ({\n                \"Fallback.useEffect17\": ()=>continueRender(fallback)\n            })[\"Fallback.useEffect17\"];\n        }\n    }[\"Fallback.useEffect17\"], []);\n    return null;\n};\nvar InnerComposition = ({ width, height, fps, durationInFrames, id, defaultProps, schema, ...compProps })=>{\n    const compManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    const { registerComposition, unregisterComposition } = compManager;\n    const video = useVideo();\n    const lazy = useLazyComponent({\n        compProps,\n        componentName: \"Composition\",\n        noSuspense: false\n    });\n    const nonce = useNonce();\n    const isPlayer = useIsPlayer();\n    const environment = getRemotionEnvironment();\n    const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (canUseComposition) {\n        if (isPlayer) {\n            throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n        }\n        throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"InnerComposition.useEffect17\": ()=>{\n            if (!id) {\n                throw new Error(\"No id for composition passed.\");\n            }\n            validateCompositionId(id);\n            validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n            registerComposition({\n                durationInFrames: durationInFrames ?? undefined,\n                fps: fps ?? undefined,\n                height: height ?? undefined,\n                width: width ?? undefined,\n                id,\n                folderName,\n                component: lazy,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n                nonce,\n                parentFolderName: parentName,\n                schema: schema ?? null,\n                calculateMetadata: compProps.calculateMetadata ?? null\n            });\n            return ({\n                \"InnerComposition.useEffect17\": ()=>{\n                    unregisterComposition(id);\n                }\n            })[\"InnerComposition.useEffect17\"];\n        }\n    }[\"InnerComposition.useEffect17\"], [\n        durationInFrames,\n        fps,\n        height,\n        lazy,\n        id,\n        folderName,\n        defaultProps,\n        width,\n        nonce,\n        parentName,\n        schema,\n        compProps.calculateMetadata,\n        registerComposition,\n        unregisterComposition\n    ]);\n    const resolved = useResolvedVideoConfig(id);\n    if (environment.isStudio && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    if (environment.isRendering && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    return null;\n};\nvar Composition = (props2)=>{\n    const { onlyRenderComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    if (onlyRenderComposition && onlyRenderComposition !== props2.id) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerComposition, {\n        ...props2\n    });\n};\n// src/bezier.ts\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction a(aA1, aA2) {\n    return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n    return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n    return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n    return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n    return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({ aX, _aA, _aB, mX1, mX2 }) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    let aA = _aA;\n    let aB = _aB;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n    let aGuessT = _aGuessT;\n    for(let i = 0; i < NEWTON_ITERATIONS; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n        throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n    const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    if (mX1 !== mY1 || mX2 !== mY2) {\n        for(let i = 0; i < kSplineTableSize; ++i){\n            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function getTForX(aX) {\n        let intervalStart = 0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        if (initialSlope === 0) {\n            return guessForT;\n        }\n        return binarySubdivide({\n            aX,\n            _aA: intervalStart,\n            _aB: intervalStart + kSampleStepSize,\n            mX1,\n            mX2\n        });\n    }\n    return function(x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n            return x;\n        }\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\n// src/easing.ts\nclass Easing {\n    static step0(n) {\n        return n > 0 ? 1 : 0;\n    }\n    static step1(n) {\n        return n >= 1 ? 1 : 0;\n    }\n    static linear(t) {\n        return t;\n    }\n    static ease(t) {\n        return Easing.bezier(0.42, 0, 1, 1)(t);\n    }\n    static quad(t) {\n        return t * t;\n    }\n    static cubic(t) {\n        return t * t * t;\n    }\n    static poly(n) {\n        return (t)=>t ** n;\n    }\n    static sin(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    static circle(t) {\n        return 1 - Math.sqrt(1 - t * t);\n    }\n    static exp(t) {\n        return 2 ** (10 * (t - 1));\n    }\n    static elastic(bounciness = 1) {\n        const p = bounciness * Math.PI;\n        return (t)=>1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n    }\n    static back(s = 1.70158) {\n        return (t)=>t * t * ((s + 1) * t - s);\n    }\n    static bounce(t) {\n        if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        if (t < 2 / 2.75) {\n            const t2_ = t - 1.5 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.75;\n        }\n        if (t < 2.5 / 2.75) {\n            const t2_ = t - 2.25 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.9375;\n        }\n        const t2 = t - 2.625 / 2.75;\n        return 7.5625 * t2 * t2 + 0.984375;\n    }\n    static bezier(x1, y1, x2, y2) {\n        return bezier(x1, y1, x2, y2);\n    }\n    static in(easing) {\n        return easing;\n    }\n    static out(easing) {\n        return (t)=>1 - easing(1 - t);\n    }\n    static inOut(easing) {\n        return (t)=>{\n            if (t < 0.5) {\n                return easing(t * 2) / 2;\n            }\n            return 1 - easing((1 - t) * 2) / 2;\n        };\n    }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = ()=>{\n    if (warnedServer) {\n        return;\n    }\n    warnedServer = true;\n    console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = ()=>{\n    if (warnedPlayer) {\n        return;\n    }\n    warnedPlayer = true;\n    console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = ()=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (typeof document === \"undefined\") {\n        warnServerOnce();\n        return [];\n    }\n    if (window.remotion_isPlayer) {\n        warnPlayerOnce();\n        return [];\n    }\n    return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({ onLoad, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...props2 }, ref)=>{\n    const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"IFrameRefForwarding.useState14\": ()=>delayRender(`Loading <IFrame> with source ${props2.src}`, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            })\n    }[\"IFrameRefForwarding.useState14\"]);\n    const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"IFrameRefForwarding.useCallback12[didLoad]\": (e)=>{\n            continueRender(handle);\n            onLoad?.(e);\n        }\n    }[\"IFrameRefForwarding.useCallback12[didLoad]\"], [\n        handle,\n        onLoad\n    ]);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"IFrameRefForwarding.useCallback12[didGetError]\": (e)=>{\n            continueRender(handle);\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n            }\n        }\n    }[\"IFrameRefForwarding.useCallback12[didGetError]\"], [\n        handle,\n        onError\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n        ...props2,\n        ref,\n        onError: didGetError,\n        onLoad: didLoad\n    });\n};\nvar IFrame = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\n\nfunction exponentialBackoff(errorCount) {\n    return 1000 * 2 ** (errorCount - 1);\n}\nvar ImgRefForwarding = ({ onError, maxRetries = 2, src, pauseWhenLoading, delayRenderRetries, delayRenderTimeoutInMilliseconds, onImageFrame, ...props2 }, ref)=>{\n    const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const { delayPlayback } = useBufferState();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    if (!src) {\n        throw new Error('No \"src\" prop was passed to <Img>.');\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"ImgRefForwarding.useImperativeHandle7\": ()=>{\n            return imageRef.current;\n        }\n    }[\"ImgRefForwarding.useImperativeHandle7\"], []);\n    const actualSrc = usePreload(src);\n    const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ImgRefForwarding.useCallback13[retryIn]\": (timeout)=>{\n            if (!imageRef.current) {\n                return;\n            }\n            const currentSrc = imageRef.current.src;\n            setTimeout({\n                \"ImgRefForwarding.useCallback13[retryIn]\": ()=>{\n                    if (!imageRef.current) {\n                        return;\n                    }\n                    const newSrc = imageRef.current?.src;\n                    if (newSrc !== currentSrc) {\n                        return;\n                    }\n                    imageRef.current.removeAttribute(\"src\");\n                    imageRef.current.setAttribute(\"src\", newSrc);\n                }\n            }[\"ImgRefForwarding.useCallback13[retryIn]\"], timeout);\n        }\n    }[\"ImgRefForwarding.useCallback13[retryIn]\"], []);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ImgRefForwarding.useCallback13[didGetError]\": (e)=>{\n            if (!errors.current) {\n                return;\n            }\n            errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n            if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n                onError(e);\n                return;\n            }\n            if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n                const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n                console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n                retryIn(backoff);\n                return;\n            }\n            cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n        }\n    }[\"ImgRefForwarding.useCallback13[didGetError]\"], [\n        maxRetries,\n        onError,\n        retryIn\n    ]);\n    if (false) {}\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n        ...props2,\n        ref: imageRef,\n        onError: didGetError\n    });\n};\nvar Img = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/internals.ts\n\n// src/CompositionManager.tsx\n\n\nvar compositionsRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar CompositionManagerProvider = ({ children, numberOfAudioTags, onlyRenderComposition, currentCompositionMetadata })=>{\n    const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[updateCompositions]\": (updateComps)=>{\n            setCompositions({\n                \"CompositionManagerProvider.useCallback14[updateCompositions]\": (comps)=>{\n                    const updated = updateComps(comps);\n                    currentcompositionsRef.current = updated;\n                    return updated;\n                }\n            }[\"CompositionManagerProvider.useCallback14[updateCompositions]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[updateCompositions]\"], []);\n    const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[registerComposition]\": (comp)=>{\n            updateCompositions({\n                \"CompositionManagerProvider.useCallback14[registerComposition]\": (comps)=>{\n                    if (comps.find({\n                        \"CompositionManagerProvider.useCallback14[registerComposition]\": (c2)=>c2.id === comp.id\n                    }[\"CompositionManagerProvider.useCallback14[registerComposition]\"])) {\n                        throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n                    }\n                    const value = [\n                        ...comps,\n                        comp\n                    ].slice().sort({\n                        \"CompositionManagerProvider.useCallback14[registerComposition].value\": (a2, b2)=>a2.nonce - b2.nonce\n                    }[\"CompositionManagerProvider.useCallback14[registerComposition].value\"]);\n                    return value;\n                }\n            }[\"CompositionManagerProvider.useCallback14[registerComposition]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[registerComposition]\"], [\n        updateCompositions\n    ]);\n    const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[unregisterComposition]\": (id)=>{\n            setCompositions({\n                \"CompositionManagerProvider.useCallback14[unregisterComposition]\": (comps)=>{\n                    return comps.filter({\n                        \"CompositionManagerProvider.useCallback14[unregisterComposition]\": (c2)=>c2.id !== id\n                    }[\"CompositionManagerProvider.useCallback14[unregisterComposition]\"]);\n                }\n            }[\"CompositionManagerProvider.useCallback14[unregisterComposition]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[unregisterComposition]\"], []);\n    const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[registerFolder]\": (name, parent)=>{\n            setFolders({\n                \"CompositionManagerProvider.useCallback14[registerFolder]\": (prevFolders)=>{\n                    return [\n                        ...prevFolders,\n                        {\n                            name,\n                            parent\n                        }\n                    ];\n                }\n            }[\"CompositionManagerProvider.useCallback14[registerFolder]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[registerFolder]\"], []);\n    const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[unregisterFolder]\": (name, parent)=>{\n            setFolders({\n                \"CompositionManagerProvider.useCallback14[unregisterFolder]\": (prevFolders)=>{\n                    return prevFolders.filter({\n                        \"CompositionManagerProvider.useCallback14[unregisterFolder]\": (p)=>!(p.name === name && p.parent === parent)\n                    }[\"CompositionManagerProvider.useCallback14[unregisterFolder]\"]);\n                }\n            }[\"CompositionManagerProvider.useCallback14[unregisterFolder]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[unregisterFolder]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, {\n        \"CompositionManagerProvider.useImperativeHandle8\": ()=>{\n            return {\n                getCompositions: ({\n                    \"CompositionManagerProvider.useImperativeHandle8\": ()=>currentcompositionsRef.current\n                })[\"CompositionManagerProvider.useImperativeHandle8\"]\n            };\n        }\n    }[\"CompositionManagerProvider.useImperativeHandle8\"], []);\n    const composition = compositions.find((c2)=>canvasContent?.type === \"composition\" ? c2.id === canvasContent.compositionId : null);\n    const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\": (id, newDefaultProps)=>{\n            setCompositions({\n                \"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\": (comps)=>{\n                    const updated = comps.map({\n                        \"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps].updated\": (c2)=>{\n                            if (c2.id === id) {\n                                return {\n                                    ...c2,\n                                    defaultProps: newDefaultProps\n                                };\n                            }\n                            return c2;\n                        }\n                    }[\"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps].updated\"]);\n                    return updated;\n                }\n            }[\"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\"], []);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CompositionManagerProvider.useMemo23[contextValue]\": ()=>{\n            return {\n                compositions,\n                folders,\n                currentCompositionMetadata,\n                canvasContent\n            };\n        }\n    }[\"CompositionManagerProvider.useMemo23[contextValue]\"], [\n        compositions,\n        folders,\n        currentCompositionMetadata,\n        canvasContent\n    ]);\n    const setters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CompositionManagerProvider.useMemo23[setters]\": ()=>{\n            return {\n                registerComposition,\n                unregisterComposition,\n                registerFolder,\n                unregisterFolder,\n                setCanvasContent,\n                updateCompositionDefaultProps,\n                onlyRenderComposition\n            };\n        }\n    }[\"CompositionManagerProvider.useMemo23[setters]\"], [\n        registerComposition,\n        registerFolder,\n        unregisterComposition,\n        unregisterFolder,\n        updateCompositionDefaultProps,\n        onlyRenderComposition\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n        value: contextValue,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionSetters.Provider, {\n            value: setters,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n                            numberOfAudioTags,\n                            component: composition?.component ?? null,\n                            children\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n    makeDefaultPreviewCSS: ()=>makeDefaultPreviewCSS,\n    injectCSS: ()=>injectCSS,\n    OFFTHREAD_VIDEO_CLASS_NAME: ()=>OFFTHREAD_VIDEO_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css)=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    if (injected[css]) {\n        return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    head.prepend(style);\n    injected[css] = true;\n};\nvar OFFTHREAD_VIDEO_CLASS_NAME = \"__remotion_offthreadvideo\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor)=>{\n    if (!scope) {\n        return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n    }\n    return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = ()=>{\n    return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp)=>{\n    if (!comp) {\n        throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n    }\n    if (Root) {\n        throw new Error(\"registerRoot() was called more than once.\");\n    }\n    Root = comp;\n    listeners.forEach((l)=>{\n        l(comp);\n    });\n};\nvar getRoot = ()=>{\n    return Root;\n};\nvar waitForRoot = (fn)=>{\n    if (Root) {\n        fn(Root);\n        return ()=>{\n            return;\n        };\n    }\n    listeners.push(fn);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== fn);\n    };\n};\n// src/RemotionRoot.tsx\n\n\nvar RemotionRoot = ({ children, numberOfAudioTags, logLevel, onlyRenderComposition, currentCompositionMetadata })=>{\n    const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"RemotionRoot.useState16\": ()=>String(random(null))\n    }[\"RemotionRoot.useState16\"]);\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"RemotionRoot.useState16\": ()=>getInitialFrameState()\n    }[\"RemotionRoot.useState16\"]);\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    if (false) {}\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo24[timelineContextValue]\": ()=>{\n            return {\n                frame,\n                playing,\n                imperativePlaying,\n                rootId: remotionRootId,\n                playbackRate,\n                setPlaybackRate,\n                audioAndVideoTags\n            };\n        }\n    }[\"RemotionRoot.useMemo24[timelineContextValue]\"], [\n        frame,\n        playbackRate,\n        playing,\n        remotionRootId\n    ]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo24[setTimelineContextValue]\": ()=>{\n            return {\n                setFrame,\n                setPlaying\n            };\n        }\n    }[\"RemotionRoot.useMemo24[setTimelineContextValue]\"], []);\n    const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo24[nonceContext]\": ()=>{\n            let counter = 0;\n            return {\n                getNonce: ({\n                    \"RemotionRoot.useMemo24[nonceContext]\": ()=>counter++\n                })[\"RemotionRoot.useMemo24[nonceContext]\"],\n                fastRefreshes\n            };\n        }\n    }[\"RemotionRoot.useMemo24[nonceContext]\"], [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"RemotionRoot.useEffect18\": ()=>{\n            if (true) {\n                if (__webpack_module__.hot) {\n                    __webpack_module__.hot.addStatusHandler({\n                        \"RemotionRoot.useEffect18\": (status)=>{\n                            if (status === \"idle\") {\n                                setFastRefreshes({\n                                    \"RemotionRoot.useEffect18\": (i)=>i + 1\n                                }[\"RemotionRoot.useEffect18\"]);\n                            }\n                        }\n                    }[\"RemotionRoot.useEffect18\"]);\n                }\n            }\n        }\n    }[\"RemotionRoot.useEffect18\"], []);\n    const logging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo24[logging]\": ()=>{\n            return {\n                logLevel,\n                mountTime: Date.now()\n            };\n        }\n    }[\"RemotionRoot.useMemo24[logging]\"], [\n        logLevel\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n        value: logging,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n            value: nonceContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                value: timelineContextValue,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                    value: setTimelineContextValue,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, {\n                                numberOfAudioTags,\n                                onlyRenderComposition,\n                                currentCompositionMetadata,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                                        children\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/setup-env-variables.ts\nvar getEnvVariables = ()=>{\n    if (getRemotionEnvironment().isRendering) {\n        const param = window.remotion_envVariables;\n        if (!param) {\n            return {};\n        }\n        return {\n            ...JSON.parse(param),\n            NODE_ENV: \"production\"\n        };\n    }\n    if (false) {}\n    return {\n        NODE_ENV: \"production\"\n    };\n};\nvar setupEnvVariables = ()=>{\n    const env = getEnvVariables();\n    if (!window.process) {\n        window.process = {};\n    }\n    if (!window.process.env) {\n        window.process.env = {};\n    }\n    Object.keys(env).forEach((key)=>{\n        window.process.env[key] = env[key];\n    });\n};\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setSize: ()=>{\n        return;\n    },\n    size: {\n        size: \"auto\",\n        translation: {\n            x: 0,\n            y: 0\n        }\n    }\n});\nvar calculateScale = ({ canvasSize, compositionHeight, compositionWidth, previewSize })=>{\n    const heightRatio = canvasSize.height / compositionHeight;\n    const widthRatio = canvasSize.width / compositionWidth;\n    const ratio = Math.min(heightRatio, widthRatio);\n    return previewSize === \"auto\" ? ratio : Number(previewSize);\n};\nvar useCurrentScale = (options)=>{\n    const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n    const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n    const config = useUnsafeVideoConfig();\n    if (hasContext === null || config === null || zoomContext === null) {\n        if (options?.dontThrowIfOutsideOfRemotion) {\n            return 1;\n        }\n        if (getRemotionEnvironment().isRendering) {\n            return 1;\n        }\n        throw new Error([\n            \"useCurrentScale() was called outside of a Remotion context.\",\n            \"This hook can only be called in a component that is being rendered by Remotion.\",\n            \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n            \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n        ].join(`\n`));\n    }\n    if (hasContext.type === \"scale\") {\n        return hasContext.scale;\n    }\n    return calculateScale({\n        canvasSize: hasContext.canvasSize,\n        compositionHeight: config.height,\n        compositionWidth: config.width,\n        previewSize: zoomContext.size.size\n    });\n};\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback)=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (!getRemotionEnvironment().isStudio) {\n        console.warn(\"The watchStaticFile() API is only available while using the Remotion Studio.\");\n        return {\n            cancel: ()=>{\n                return;\n            }\n        };\n    }\n    const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n    const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n    let prevFileData = window.remotion_staticFiles.find((file)=>file.name === withoutLeadingSlash);\n    const checkFile = (event)=>{\n        const staticFiles = event.detail.files;\n        const newFileData = staticFiles.find((file)=>file.name === withoutLeadingSlash);\n        if (!newFileData) {\n            if (prevFileData !== undefined) {\n                callback(null);\n            }\n            prevFileData = undefined;\n            return;\n        }\n        if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n            callback(newFileData);\n            prevFileData = newFileData;\n        }\n    };\n    window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    const cancel = ()=>{\n        return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    };\n    return {\n        cancel\n    };\n};\n// src/wrap-remotion-context.tsx\n\n\nfunction useRemotionContexts() {\n    const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n    const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n    const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n    const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n    const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n    const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n    const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n    const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n    const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n    const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n    const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n    const logLevelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useRemotionContexts.useMemo25\": ()=>({\n                compositionManagerCtx,\n                timelineContext,\n                setTimelineContext,\n                sequenceContext,\n                nonceContext,\n                canUseRemotionHooksContext,\n                preloadContext,\n                resolveCompositionContext,\n                renderAssetManagerContext,\n                sequenceManagerContext,\n                bufferManagerContext,\n                logLevelContext\n            })\n    }[\"useRemotionContexts.useMemo25\"], [\n        compositionManagerCtx,\n        nonceContext,\n        sequenceContext,\n        setTimelineContext,\n        timelineContext,\n        canUseRemotionHooksContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n        bufferManagerContext,\n        logLevelContext\n    ]);\n}\nvar RemotionContextProvider = (props2)=>{\n    const { children, contexts } = props2;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n        value: contexts.logLevelContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n            value: contexts.canUseRemotionHooksContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n                value: contexts.nonceContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n                    value: contexts.preloadContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n                        value: contexts.compositionManagerCtx,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n                            value: contexts.sequenceManagerContext,\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                                value: contexts.renderAssetManagerContext,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                                    value: contexts.resolveCompositionContext,\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                                        value: contexts.timelineContext,\n                                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                                            value: contexts.setTimelineContext,\n                                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                                                value: contexts.sequenceContext,\n                                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                                                    value: contexts.bufferManagerContext,\n                                                    children\n                                                })\n                                            })\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/internals.ts\nvar compositionSelectorRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar Internals = {\n    useUnsafeVideoConfig,\n    Timeline: exports_timeline_position_state,\n    CompositionManager,\n    CompositionSetters,\n    SequenceManager,\n    SequenceVisibilityToggleContext,\n    RemotionRoot,\n    useVideo,\n    getRoot,\n    useMediaVolumeState,\n    useMediaMutedState,\n    useLazyComponent,\n    truthy,\n    SequenceContext,\n    useRemotionContexts,\n    RemotionContextProvider,\n    CSSUtils: exports_default_css,\n    setupEnvVariables,\n    MediaVolumeContext,\n    SetMediaVolumeContext,\n    getRemotionEnvironment,\n    SharedAudioContext,\n    SharedAudioContextProvider,\n    invalidCompositionErrorMessage,\n    isCompositionIdValid,\n    getPreviewDomElement,\n    compositionsRef,\n    portalNode,\n    waitForRoot,\n    CanUseRemotionHooksProvider,\n    CanUseRemotionHooks,\n    PrefetchProvider,\n    DurationsContextProvider,\n    IsPlayerContextProvider,\n    useIsPlayer,\n    EditorPropsProvider,\n    EditorPropsContext,\n    usePreload,\n    NonceContext,\n    resolveVideoConfig,\n    useResolvedVideoConfig,\n    resolveCompositionsRef,\n    ResolveCompositionConfig,\n    REMOTION_STUDIO_CONTAINER_ELEMENT,\n    RenderAssetManager,\n    persistCurrentFrame,\n    useTimelineSetFrame,\n    isIosSafari,\n    WATCH_REMOTION_STATIC_FILES,\n    addSequenceStackTraces,\n    useMediaStartsAt,\n    BufferingProvider,\n    BufferingContextReact,\n    enableSequenceStackTraces,\n    CurrentScaleContext,\n    PreviewSizeContext,\n    calculateScale,\n    editorPropsProviderRef,\n    PROPS_UPDATED_EXTERNALLY,\n    validateRenderAsset,\n    Log,\n    LogLevelContext,\n    useLogLevel,\n    playbackLogging,\n    timeValueRef,\n    compositionSelectorRef\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b2 = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nvar opacity = (c2)=>{\n    return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2)=>{\n    return c2 >> 16 & 255;\n};\nvar green = (c2)=>{\n    return c2 >> 8 & 255;\n};\nvar blue = (c2)=>{\n    return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha)=>{\n    return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar interpolateColorsRGB = (value, inputRange, colors)=>{\n    const [r, g, b2, a2] = [\n        red,\n        green,\n        blue,\n        opacity\n    ].map((f)=>{\n        const unrounded = interpolate(value, inputRange, colors.map((c2)=>f(c2)), {\n            extrapolateLeft: \"clamp\",\n            extrapolateRight: \"clamp\"\n        });\n        if (f === opacity) {\n            return Number(unrounded.toFixed(3));\n        }\n        return Math.round(unrounded);\n    });\n    return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange)=>{\n    if (typeof input === \"undefined\") {\n        throw new TypeError(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new TypeError(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new TypeError(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n    }\n    const processedOutputRange = outputRange.map((c2)=>processColor(c2));\n    return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/series/index.tsx\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children)=>{\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n    return childrenArray.reduce((flatChildren, child)=>{\n        if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            return flatChildren.concat(flattenChildren(child.props.children));\n        }\n        flatChildren.push(child);\n        return flatChildren;\n    }, []);\n};\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar IsNotInsideSeriesProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: false,\n        children\n    });\n};\nvar useRequireToBeInsideSeries = ()=>{\n    const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n    if (!isInsideSeries) {\n        throw new Error(\"This component must be inside a <Series /> component.\");\n    }\n};\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref)=>{\n    useRequireToBeInsideSeries();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n        children\n    });\n};\nvar SeriesSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2)=>{\n    const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Series.useMemo26[childrenValue]\": ()=>{\n            let startFrame = 0;\n            const flattenedChildren = flattenChildren(props2.children);\n            return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, {\n                \"Series.useMemo26[childrenValue]\": (child, i)=>{\n                    const castedChild = child;\n                    if (typeof castedChild === \"string\") {\n                        if (castedChild.trim() === \"\") {\n                            return null;\n                        }\n                        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n                    }\n                    if (castedChild.type !== SeriesSequence) {\n                        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n                    }\n                    const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n                    if (!castedChild?.props.children) {\n                        throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n                    }\n                    const durationInFramesProp = castedChild.props.durationInFrames;\n                    const { durationInFrames, children: _children, from, name, ...passedProps } = castedChild.props;\n                    if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n                        validateDurationInFrames(durationInFramesProp, {\n                            component: `of a <Series.Sequence /> component`,\n                            allowFloats: true\n                        });\n                    }\n                    const offset = castedChild.props.offset ?? 0;\n                    if (Number.isNaN(offset)) {\n                        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n                    }\n                    if (!Number.isFinite(offset)) {\n                        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n                    }\n                    if (offset % 1 !== 0) {\n                        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n                    }\n                    const currentStartFrame = startFrame + offset;\n                    startFrame += durationInFramesProp + offset;\n                    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                        name: name || \"<Series.Sequence>\",\n                        from: currentStartFrame,\n                        durationInFrames: durationInFramesProp,\n                        ...passedProps,\n                        ref: castedChild.ref,\n                        children: child\n                    });\n                }\n            }[\"Series.useMemo26[childrenValue]\"]);\n        }\n    }[\"Series.useMemo26[childrenValue]\"], [\n        props2.children\n    ]);\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                ...props2,\n                children: childrenValue\n            })\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n        children: childrenValue\n    });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur)=>{\n    if (typeof dur === \"undefined\") {\n        return;\n    }\n    if (typeof dur !== \"number\") {\n        throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n    }\n    if (Number.isNaN(dur)) {\n        throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n    }\n    if (!Number.isFinite(dur)) {\n        throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n    }\n    if (dur <= 0) {\n        throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n    }\n};\n// src/spring/spring-utils.ts\nvar defaultSpringConfig = {\n    damping: 10,\n    mass: 1,\n    stiffness: 100,\n    overshootClamping: false\n};\nvar advanceCache = {};\nfunction advance({ animation, now, config }) {\n    const { toValue, lastTimestamp, current, velocity } = animation;\n    const deltaTime = Math.min(now - lastTimestamp, 64);\n    if (config.damping <= 0) {\n        throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n    }\n    const c2 = config.damping;\n    const m = config.mass;\n    const k = config.stiffness;\n    const cacheKey = [\n        toValue,\n        lastTimestamp,\n        current,\n        velocity,\n        c2,\n        m,\n        k,\n        now\n    ].join(\"-\");\n    if (advanceCache[cacheKey]) {\n        return advanceCache[cacheKey];\n    }\n    const v0 = -velocity;\n    const x0 = toValue - current;\n    const zeta = c2 / (2 * Math.sqrt(k * m));\n    const omega0 = Math.sqrt(k / m);\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n    const t = deltaTime / 1000;\n    const sin1 = Math.sin(omega1 * t);\n    const cos1 = Math.cos(omega1 * t);\n    const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n    const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n    const underDampedPosition = toValue - underDampedFrag1;\n    const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n    const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n    const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n    const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n    const animationNode = {\n        toValue,\n        prevPosition: current,\n        lastTimestamp: now,\n        current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n        velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n    };\n    advanceCache[cacheKey] = animationNode;\n    return animationNode;\n}\nvar calculationCache = {};\nfunction springCalculation({ frame, fps, config = {} }) {\n    const from = 0;\n    const to = 1;\n    const cacheKey = [\n        frame,\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness\n    ].join(\"-\");\n    if (calculationCache[cacheKey]) {\n        return calculationCache[cacheKey];\n    }\n    let animation = {\n        lastTimestamp: 0,\n        current: from,\n        toValue: to,\n        velocity: 0,\n        prevPosition: 0\n    };\n    const frameClamped = Math.max(0, frame);\n    const unevenRest = frameClamped % 1;\n    for(let f = 0; f <= Math.floor(frameClamped); f++){\n        if (f === Math.floor(frameClamped)) {\n            f += unevenRest;\n        }\n        const time = f / fps * 1000;\n        animation = advance({\n            animation,\n            now: time,\n            config: {\n                ...defaultSpringConfig,\n                ...config\n            }\n        });\n    }\n    calculationCache[cacheKey] = animation;\n    return animation;\n}\n// src/spring/measure-spring.ts\nvar cache = new Map;\nfunction measureSpring({ fps, config = {}, threshold = 0.005 }) {\n    if (typeof threshold !== \"number\") {\n        throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n    }\n    if (threshold === 0) {\n        return Infinity;\n    }\n    if (threshold === 1) {\n        return 0;\n    }\n    if (isNaN(threshold)) {\n        throw new TypeError(\"Threshold is NaN\");\n    }\n    if (!Number.isFinite(threshold)) {\n        throw new TypeError(\"Threshold is not finite\");\n    }\n    if (threshold < 0) {\n        throw new TypeError(\"Threshold is below 0\");\n    }\n    const cacheKey = [\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness,\n        threshold\n    ].join(\"-\");\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    }\n    validateFps(fps, \"to the measureSpring() function\", false);\n    let frame = 0;\n    let finishedFrame = 0;\n    const calc = ()=>{\n        return springCalculation({\n            fps,\n            frame,\n            config\n        });\n    };\n    let animation = calc();\n    const calcDifference = ()=>{\n        return Math.abs(animation.current - animation.toValue);\n    };\n    let difference = calcDifference();\n    while(difference >= threshold){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n    }\n    finishedFrame = frame;\n    for(let i = 0; i < 20; i++){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n        if (difference >= threshold) {\n            i = 0;\n            finishedFrame = frame + 1;\n        }\n    }\n    cache.set(cacheKey, finishedFrame);\n    return finishedFrame;\n}\n// src/spring/index.ts\nfunction spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false }) {\n    validateSpringDuration(passedDurationInFrames);\n    validateFrame({\n        frame: passedFrame,\n        durationInFrames: Infinity,\n        allowFloats: true\n    });\n    validateFps(fps, \"to spring()\", false);\n    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n    const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n        fps,\n        config,\n        threshold: durationRestThreshold\n    }) : undefined;\n    const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n        get: ()=>naturalDuration\n    } : {\n        get: ()=>{\n            throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n        }\n    };\n    const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n    const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n    const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n    if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n        return to;\n    }\n    const spr = springCalculation({\n        fps,\n        frame: durationProcessed,\n        config\n    });\n    const inner = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n    const interpolated = from === 0 && to === 1 ? inner : interpolate(inner, [\n        0,\n        1\n    ], [\n        from,\n        to\n    ]);\n    return interpolated;\n}\n// src/static-file.ts\nvar problematicCharacters = {\n    \"%3A\": \":\",\n    \"%2F\": \"/\",\n    \"%3F\": \"?\",\n    \"%23\": \"#\",\n    \"%5B\": \"[\",\n    \"%5D\": \"]\",\n    \"%40\": \"@\",\n    \"%21\": \"!\",\n    \"%24\": \"$\",\n    \"%26\": \"&\",\n    \"%27\": \"'\",\n    \"%28\": \"(\",\n    \"%29\": \")\",\n    \"%2A\": \"*\",\n    \"%2B\": \"+\",\n    \"%2C\": \",\",\n    \"%3B\": \";\"\n};\nvar didWarn2 = {};\nvar warnOnce3 = (message)=>{\n    if (didWarn2[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn2[message] = true;\n};\nvar includesHexOfUnsafeChar = (path)=>{\n    for (const key of Object.keys(problematicCharacters)){\n        if (path.includes(key)) {\n            return {\n                containsHex: true,\n                hexCode: key\n            };\n        }\n    }\n    return {\n        containsHex: false\n    };\n};\nvar trimLeadingSlash = (path)=>{\n    if (path.startsWith(\"/\")) {\n        return trimLeadingSlash(path.substring(1));\n    }\n    return path;\n};\nvar inner = (path)=>{\n    if (false) {}\n    return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path)=>{\n    const splitBySlash = path.split(\"/\");\n    const encodedArray = splitBySlash.map((element)=>{\n        return encodeURIComponent(element);\n    });\n    const merged = encodedArray.join(\"/\");\n    return merged;\n};\nvar staticFile = (path)=>{\n    if (path === null) {\n        throw new TypeError(\"null was passed to staticFile()\");\n    }\n    if (typeof path === \"undefined\") {\n        throw new TypeError(\"undefined was passed to staticFile()\");\n    }\n    if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n        throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n    }\n    if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n        throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n        throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"public/\")) {\n        throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    const includesHex = includesHexOfUnsafeChar(path);\n    if (includesHex.containsHex) {\n        warnOnce3(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n    }\n    const preprocessed = encodeBySplitting(path);\n    const preparsed = inner(preprocessed);\n    if (!preparsed.startsWith(\"/\")) {\n        return `/${preparsed}`;\n    }\n    return preparsed;\n};\n// src/Still.tsx\n\nvar Still = (props2)=>{\n    const newProps = {\n        ...props2,\n        durationInFrames: 1,\n        fps: 1\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/OffthreadVideo.tsx\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\nvar OffthreadVideoForRendering = ({ onError, volume: volumeProp, playbackRate, src, muted, allowAmplificationDuringRender, transparent = false, toneMapped = true, toneFrequency, name, loopVolumeCurveBehavior, delayRenderRetries, delayRenderTimeoutInMilliseconds, onVideoFrame, crossOrigin, ...props2 })=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    if (!src) {\n        throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n    }\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo27[id]\": ()=>`offthreadvideo-${random(src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`\n    }[\"OffthreadVideoForRendering.useMemo27[id]\"], [\n        src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"OffthreadVideoForRendering.useEffect19\": ()=>{\n            if (!src) {\n                throw new Error(\"No src passed\");\n            }\n            if (!window.remotion_audioEnabled) {\n                return;\n            }\n            if (muted) {\n                return;\n            }\n            if (volume <= 0) {\n                return;\n            }\n            registerRenderAsset({\n                type: \"video\",\n                src: getAbsoluteSrc(src),\n                id,\n                frame: absoluteFrame,\n                volume,\n                mediaFrame: frame,\n                playbackRate: playbackRate ?? 1,\n                toneFrequency: toneFrequency ?? null,\n                audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n            });\n            return ({\n                \"OffthreadVideoForRendering.useEffect19\": ()=>unregisterRenderAsset(id)\n            })[\"OffthreadVideoForRendering.useEffect19\"];\n        }\n    }[\"OffthreadVideoForRendering.useEffect19\"], [\n        muted,\n        src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo27[currentTime]\": ()=>{\n            return getExpectedMediaFrameUncorrected({\n                frame,\n                playbackRate: playbackRate || 1,\n                startFrom: -mediaStartsAt\n            }) / videoConfig.fps;\n        }\n    }[\"OffthreadVideoForRendering.useMemo27[currentTime]\"], [\n        frame,\n        mediaStartsAt,\n        playbackRate,\n        videoConfig.fps\n    ]);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo27[actualSrc]\": ()=>{\n            return getOffthreadVideoSource({\n                src,\n                currentTime,\n                transparent,\n                toneMapped\n            });\n        }\n    }[\"OffthreadVideoForRendering.useMemo27[actualSrc]\"], [\n        toneMapped,\n        currentTime,\n        src,\n        transparent\n    ]);\n    const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"OffthreadVideoForRendering.useLayoutEffect8\": ()=>{\n            if (!window.remotion_videoEnabled) {\n                return;\n            }\n            const cleanup = [];\n            setImageSrc(null);\n            const controller = new AbortController;\n            const newHandle = delayRender(`Fetching ${actualSrc} from server`, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const execute = {\n                \"OffthreadVideoForRendering.useLayoutEffect8.execute\": async ()=>{\n                    try {\n                        const res = await fetch(actualSrc, {\n                            signal: controller.signal,\n                            cache: \"no-store\"\n                        });\n                        if (res.status !== 200) {\n                            if (res.status === 500) {\n                                const json = await res.json();\n                                if (json.error) {\n                                    const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n                                    throw new Error(cleanedUpErrorMessage);\n                                }\n                            }\n                            throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n                        }\n                        const blob = await res.blob();\n                        const url = URL.createObjectURL(blob);\n                        cleanup.push({\n                            \"OffthreadVideoForRendering.useLayoutEffect8.execute\": ()=>URL.revokeObjectURL(url)\n                        }[\"OffthreadVideoForRendering.useLayoutEffect8.execute\"]);\n                        setImageSrc({\n                            src: url,\n                            handle: newHandle\n                        });\n                    } catch (err) {\n                        if (err.message.includes(\"aborted\")) {\n                            continueRender(newHandle);\n                            return;\n                        }\n                        if (controller.signal.aborted) {\n                            continueRender(newHandle);\n                            return;\n                        }\n                        if (err.message.includes(\"Failed to fetch\")) {\n                            err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, {\n                                cause: err\n                            });\n                        }\n                        if (onError) {\n                            onError(err);\n                        } else {\n                            cancelRender(err);\n                        }\n                    }\n                }\n            }[\"OffthreadVideoForRendering.useLayoutEffect8.execute\"];\n            execute();\n            cleanup.push({\n                \"OffthreadVideoForRendering.useLayoutEffect8\": ()=>{\n                    if (controller.signal.aborted) {\n                        return;\n                    }\n                    controller.abort();\n                }\n            }[\"OffthreadVideoForRendering.useLayoutEffect8\"]);\n            return ({\n                \"OffthreadVideoForRendering.useLayoutEffect8\": ()=>{\n                    cleanup.forEach({\n                        \"OffthreadVideoForRendering.useLayoutEffect8\": (c2)=>c2()\n                    }[\"OffthreadVideoForRendering.useLayoutEffect8\"]);\n                }\n            })[\"OffthreadVideoForRendering.useLayoutEffect8\"];\n        }\n    }[\"OffthreadVideoForRendering.useLayoutEffect8\"], [\n        actualSrc,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onError\n    ]);\n    const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"OffthreadVideoForRendering.useCallback15[onErr]\": ()=>{\n            if (onError) {\n                onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n            } else {\n                cancelRender(\"Failed to load image with src \" + imageSrc);\n            }\n        }\n    }[\"OffthreadVideoForRendering.useCallback15[onErr]\"], [\n        imageSrc,\n        onError\n    ]);\n    const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo27[className]\": ()=>{\n            return [\n                OFFTHREAD_VIDEO_CLASS_NAME,\n                props2.className\n            ].filter(truthy).join(\" \");\n        }\n    }[\"OffthreadVideoForRendering.useMemo27[className]\"], [\n        props2.className\n    ]);\n    const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"OffthreadVideoForRendering.useCallback15[onImageFrame]\": (img)=>{\n            if (onVideoFrame) {\n                onVideoFrame(img);\n            }\n        }\n    }[\"OffthreadVideoForRendering.useCallback15[onImageFrame]\"], [\n        onVideoFrame\n    ]);\n    if (!imageSrc || !window.remotion_videoEnabled) {\n        return null;\n    }\n    continueRender(imageSrc.handle);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n        src: imageSrc.src,\n        className,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onImageFrame,\n        ...props2,\n        onError: onErr\n    });\n};\n// src/video/VideoForPreview.tsx\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({ ref, onVideoFrame })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useEmitVideoFrame.useEffect20\": ()=>{\n            const { current } = ref;\n            if (!current) {\n                return;\n            }\n            if (!onVideoFrame) {\n                return;\n            }\n            let handle = 0;\n            const callback = {\n                \"useEmitVideoFrame.useEffect20.callback\": ()=>{\n                    if (!ref.current) {\n                        return;\n                    }\n                    onVideoFrame(ref.current);\n                    handle = ref.current.requestVideoFrameCallback(callback);\n                }\n            }[\"useEmitVideoFrame.useEffect20.callback\"];\n            callback();\n            return ({\n                \"useEmitVideoFrame.useEffect20\": ()=>{\n                    current.cancelVideoFrameCallback(handle);\n                }\n            })[\"useEmitVideoFrame.useEffect20\"];\n        }\n    }[\"useEmitVideoFrame.useEffect20\"], [\n        onVideoFrame,\n        ref\n    ]);\n};\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref)=>{\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume, muted, playbackRate, onlyWarnForMediaSeekingError, src, onDuration, acceptableTimeShift, acceptableTimeShiftInSeconds, toneFrequency, name, _remotionInternalNativeLoopPassed, _remotionInternalStack, style, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, onError, onAutoPlayError, onVideoFrame, crossOrigin, ...nativeProps } = props2;\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { fps, durationInFrames } = useVideoConfig();\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"VideoForDevelopmentRefForwardingFunction.useState18\": ()=>String(Math.random())\n    }[\"VideoForDevelopmentRefForwardingFunction.useState18\"]);\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    if (typeof acceptableTimeShift !== \"undefined\") {\n        throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n    }\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume\n    });\n    useMediaInTimeline({\n        mediaRef: videoRef,\n        volume,\n        mediaVolume,\n        mediaType: \"video\",\n        src,\n        playbackRate: props2.playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: onAutoPlayError ?? null,\n        isPremounting: Boolean(parentSequence?.premounting)\n    });\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        volume,\n        mediaVolume,\n        mediaRef: videoRef\n    });\n    useAmplification({\n        logLevel,\n        mediaRef: videoRef,\n        volume: userPreferredVolume\n    });\n    useMediaPlayback({\n        mediaRef: videoRef,\n        src,\n        mediaType: \"video\",\n        playbackRate: props2.playbackRate ?? 1,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n        isPremounting: Boolean(parentSequence?.premounting),\n        pauseWhenBuffering,\n        onAutoPlayError: onAutoPlayError ?? null,\n        userPreferredVolume\n    });\n    const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n    const preloadedSrc = usePreload(src);\n    const actualSrc = useAppendVideoFragment({\n        actualSrc: preloadedSrc,\n        actualFrom,\n        duration,\n        fps\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"VideoForDevelopmentRefForwardingFunction.useImperativeHandle9\": ()=>{\n            return videoRef.current;\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useImperativeHandle9\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"VideoForDevelopmentRefForwardingFunction.useState18\": ()=>playbackLogging({\n                logLevel,\n                message: `Mounting video with source = ${actualSrc}, v=${VERSION}, user agent=${typeof navigator === \"undefined\" ? \"server\" : navigator.userAgent}`,\n                tag: \"video\",\n                mountTime\n            })\n    }[\"VideoForDevelopmentRefForwardingFunction.useState18\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForDevelopmentRefForwardingFunction.useEffect21\": ()=>{\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            const errorHandler = {\n                \"VideoForDevelopmentRefForwardingFunction.useEffect21.errorHandler\": ()=>{\n                    if (current.error) {\n                        console.error(\"Error occurred in video\", current?.error);\n                        if (onError) {\n                            const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n                            onError(err);\n                            return;\n                        }\n                        throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n                    } else {\n                        if (onError) {\n                            const err = new Error(`The browser threw an error while playing the video ${src}`);\n                            onError(err);\n                            return;\n                        }\n                        throw new Error(\"The browser threw an error while playing the video\");\n                    }\n                }\n            }[\"VideoForDevelopmentRefForwardingFunction.useEffect21.errorHandler\"];\n            current.addEventListener(\"error\", errorHandler, {\n                once: true\n            });\n            return ({\n                \"VideoForDevelopmentRefForwardingFunction.useEffect21\": ()=>{\n                    current.removeEventListener(\"error\", errorHandler);\n                }\n            })[\"VideoForDevelopmentRefForwardingFunction.useEffect21\"];\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useEffect21\"], [\n        onError,\n        src\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n    currentOnDurationCallback.current = onDuration;\n    useEmitVideoFrame({\n        ref: videoRef,\n        onVideoFrame\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForDevelopmentRefForwardingFunction.useEffect21\": ()=>{\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            if (current.duration) {\n                currentOnDurationCallback.current?.(src, current.duration);\n                return;\n            }\n            const onLoadedMetadata = {\n                \"VideoForDevelopmentRefForwardingFunction.useEffect21.onLoadedMetadata\": ()=>{\n                    currentOnDurationCallback.current?.(src, current.duration);\n                }\n            }[\"VideoForDevelopmentRefForwardingFunction.useEffect21.onLoadedMetadata\"];\n            current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n            return ({\n                \"VideoForDevelopmentRefForwardingFunction.useEffect21\": ()=>{\n                    current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n                }\n            })[\"VideoForDevelopmentRefForwardingFunction.useEffect21\"];\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useEffect21\"], [\n        src\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForDevelopmentRefForwardingFunction.useEffect21\": ()=>{\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            if (isIosSafari()) {\n                current.preload = \"metadata\";\n            } else {\n                current.preload = \"auto\";\n            }\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useEffect21\"], []);\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"VideoForDevelopmentRefForwardingFunction.useMemo28[actualStyle]\": ()=>{\n            return {\n                ...style,\n                opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n            };\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useMemo28[actualStyle]\"], [\n        isSequenceHidden,\n        style\n    ]);\n    const crossOriginValue = crossOrigin ?? (onVideoFrame ? \"anonymous\" : undefined);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n        playsInline: true,\n        src: actualSrc,\n        loop: _remotionInternalNativeLoopPassed,\n        style: actualStyle,\n        disableRemotePlayback: true,\n        crossOrigin: crossOriginValue,\n        ...nativeProps\n    });\n};\nvar VideoForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n// src/video/OffthreadVideo.tsx\n\nvar OffthreadVideo = (props2)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, showInTimeline, ...otherProps } = props2;\n    const environment = getRemotionEnvironment();\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"OffthreadVideo.useCallback16[onDuration]\": ()=>{\n            return;\n        }\n    }[\"OffthreadVideo.useCallback16[onDuration]\"], []);\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    if (props2.imageFormat) {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideo, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n            ...otherProps\n        });\n    }\n    const { transparent, toneMapped, onAutoPlayError, onVideoFrame, crossOrigin, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...propsForPreview } = otherProps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: false,\n        onDuration,\n        onlyWarnForMediaSeekingError: true,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined,\n        onVideoFrame: onVideoFrame ?? null,\n        crossOrigin,\n        ...propsForPreview\n    });\n};\n// src/video/Video.tsx\n\n// src/video/VideoForRendering.tsx\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num)=>{\n    return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = ({ element, desiredTime, logLevel, mountTime })=>{\n    if (isApproximatelyTheSame(element.currentTime, desiredTime)) {\n        return {\n            wait: Promise.resolve(desiredTime),\n            cancel: ()=>{}\n        };\n    }\n    seek({\n        logLevel,\n        mediaRef: element,\n        time: desiredTime,\n        why: \"Seeking during rendering\",\n        mountTime\n    });\n    let cancel;\n    let cancelSeeked = null;\n    const prom = new Promise((resolve)=>{\n        cancel = element.requestVideoFrameCallback((now, metadata)=>{\n            const displayIn = metadata.expectedDisplayTime - now;\n            if (displayIn <= 0) {\n                resolve(metadata.mediaTime);\n                return;\n            }\n            setTimeout(()=>{\n                resolve(metadata.mediaTime);\n            }, displayIn + 150);\n        });\n    });\n    const waitForSeekedEvent = new Promise((resolve)=>{\n        const onDone = ()=>{\n            resolve();\n        };\n        element.addEventListener(\"seeked\", onDone, {\n            once: true\n        });\n        cancelSeeked = ()=>{\n            element.removeEventListener(\"seeked\", onDone);\n        };\n    });\n    return {\n        wait: Promise.all([\n            prom,\n            waitForSeekedEvent\n        ]).then(([time])=>time),\n        cancel: ()=>{\n            cancelSeeked?.();\n            element.cancelVideoFrameCallback(cancel);\n        }\n    };\n};\nvar seekToTimeMultipleUntilRight = ({ element, desiredTime, fps, logLevel, mountTime })=>{\n    const threshold = 1 / fps / 2;\n    let currentCancel = ()=>{\n        return;\n    };\n    if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n        return {\n            prom: Promise.resolve(),\n            cancel: ()=>{}\n        };\n    }\n    const prom = new Promise((resolve, reject)=>{\n        const firstSeek = seekToTime({\n            element,\n            desiredTime: desiredTime + threshold,\n            logLevel,\n            mountTime\n        });\n        firstSeek.wait.then((seekedTo)=>{\n            const difference = Math.abs(desiredTime - seekedTo);\n            if (difference <= threshold) {\n                return resolve();\n            }\n            const sign = desiredTime > seekedTo ? 1 : -1;\n            const newSeek = seekToTime({\n                element,\n                desiredTime: seekedTo + threshold * sign,\n                logLevel,\n                mountTime\n            });\n            currentCancel = newSeek.cancel;\n            newSeek.wait.then((newTime)=>{\n                const newDifference = Math.abs(desiredTime - newTime);\n                if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n                    return resolve();\n                }\n                const thirdSeek = seekToTime({\n                    element,\n                    desiredTime: desiredTime + threshold,\n                    logLevel,\n                    mountTime\n                });\n                currentCancel = thirdSeek.cancel;\n                return thirdSeek.wait.then(()=>{\n                    resolve();\n                }).catch((err)=>{\n                    reject(err);\n                });\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n        currentCancel = firstSeek.cancel;\n    });\n    return {\n        prom,\n        cancel: ()=>{\n            currentCancel();\n        }\n    };\n};\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({ onError, volume: volumeProp, allowAmplificationDuringRender, playbackRate, onDuration, toneFrequency, name, acceptableTimeShiftInSeconds, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, ...props2 }, ref)=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const environment = getRemotionEnvironment();\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"VideoForRenderingForwardFunction.useMemo29[id]\": ()=>`video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`\n    }[\"VideoForRenderingForwardFunction.useMemo29[id]\"], [\n        props2.src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForRenderingForwardFunction.useEffect22\": ()=>{\n            if (!props2.src) {\n                throw new Error(\"No src passed\");\n            }\n            if (props2.muted) {\n                return;\n            }\n            if (volume <= 0) {\n                return;\n            }\n            if (!window.remotion_audioEnabled) {\n                return;\n            }\n            registerRenderAsset({\n                type: \"video\",\n                src: getAbsoluteSrc(props2.src),\n                id,\n                frame: absoluteFrame,\n                volume,\n                mediaFrame: frame,\n                playbackRate: playbackRate ?? 1,\n                toneFrequency: toneFrequency ?? null,\n                audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n            });\n            return ({\n                \"VideoForRenderingForwardFunction.useEffect22\": ()=>unregisterRenderAsset(id)\n            })[\"VideoForRenderingForwardFunction.useEffect22\"];\n        }\n    }[\"VideoForRenderingForwardFunction.useEffect22\"], [\n        props2.muted,\n        props2.src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"VideoForRenderingForwardFunction.useImperativeHandle10\": ()=>{\n            return videoRef.current;\n        }\n    }[\"VideoForRenderingForwardFunction.useImperativeHandle10\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForRenderingForwardFunction.useEffect22\": ()=>{\n            if (!window.remotion_videoEnabled) {\n                return;\n            }\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            const currentTime = getMediaTime({\n                frame,\n                playbackRate: playbackRate || 1,\n                startFrom: -mediaStartsAt,\n                fps: videoConfig.fps\n            });\n            const handle = delayRender(`Rendering <Video /> with src=\"${props2.src}\" at time ${currentTime}`, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                continueRender(handle);\n                return;\n            }\n            if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n                if (current.readyState >= 2) {\n                    continueRender(handle);\n                    return;\n                }\n                const loadedDataHandler = {\n                    \"VideoForRenderingForwardFunction.useEffect22.loadedDataHandler\": ()=>{\n                        continueRender(handle);\n                    }\n                }[\"VideoForRenderingForwardFunction.useEffect22.loadedDataHandler\"];\n                current.addEventListener(\"loadeddata\", loadedDataHandler, {\n                    once: true\n                });\n                return ({\n                    \"VideoForRenderingForwardFunction.useEffect22\": ()=>{\n                        current.removeEventListener(\"loadeddata\", loadedDataHandler);\n                    }\n                })[\"VideoForRenderingForwardFunction.useEffect22\"];\n            }\n            const endedHandler = {\n                \"VideoForRenderingForwardFunction.useEffect22.endedHandler\": ()=>{\n                    continueRender(handle);\n                }\n            }[\"VideoForRenderingForwardFunction.useEffect22.endedHandler\"];\n            const seek2 = seekToTimeMultipleUntilRight({\n                element: current,\n                desiredTime: currentTime,\n                fps: videoConfig.fps,\n                logLevel,\n                mountTime\n            });\n            seek2.prom.then({\n                \"VideoForRenderingForwardFunction.useEffect22\": ()=>{\n                    continueRender(handle);\n                }\n            }[\"VideoForRenderingForwardFunction.useEffect22\"]);\n            current.addEventListener(\"ended\", endedHandler, {\n                once: true\n            });\n            const errorHandler = {\n                \"VideoForRenderingForwardFunction.useEffect22.errorHandler\": ()=>{\n                    if (current?.error) {\n                        console.error(\"Error occurred in video\", current?.error);\n                        if (onError) {\n                            return;\n                        }\n                        throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n                    } else {\n                        throw new Error(\"The browser threw an error\");\n                    }\n                }\n            }[\"VideoForRenderingForwardFunction.useEffect22.errorHandler\"];\n            current.addEventListener(\"error\", errorHandler, {\n                once: true\n            });\n            return ({\n                \"VideoForRenderingForwardFunction.useEffect22\": ()=>{\n                    seek2.cancel();\n                    current.removeEventListener(\"ended\", endedHandler);\n                    current.removeEventListener(\"error\", errorHandler);\n                    continueRender(handle);\n                }\n            })[\"VideoForRenderingForwardFunction.useEffect22\"];\n        }\n    }[\"VideoForRenderingForwardFunction.useEffect22\"], [\n        volumePropsFrame,\n        props2.src,\n        playbackRate,\n        videoConfig.fps,\n        frame,\n        mediaStartsAt,\n        onError,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        logLevel,\n        mountTime\n    ]);\n    const { src } = props2;\n    if (environment.isRendering) {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n            \"VideoForRenderingForwardFunction.useLayoutEffect9\": ()=>{\n                if (window.process?.env?.NODE_ENV === \"test\") {\n                    return;\n                }\n                const newHandle = delayRender(\"Loading <Video> duration with src=\" + src, {\n                    retries: delayRenderRetries ?? undefined,\n                    timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n                });\n                const { current } = videoRef;\n                const didLoad = {\n                    \"VideoForRenderingForwardFunction.useLayoutEffect9.didLoad\": ()=>{\n                        if (current?.duration) {\n                            onDuration(src, current.duration);\n                        }\n                        continueRender(newHandle);\n                    }\n                }[\"VideoForRenderingForwardFunction.useLayoutEffect9.didLoad\"];\n                if (current?.duration) {\n                    onDuration(src, current.duration);\n                    continueRender(newHandle);\n                } else {\n                    current?.addEventListener(\"loadedmetadata\", didLoad, {\n                        once: true\n                    });\n                }\n                return ({\n                    \"VideoForRenderingForwardFunction.useLayoutEffect9\": ()=>{\n                        current?.removeEventListener(\"loadedmetadata\", didLoad);\n                        continueRender(newHandle);\n                    }\n                })[\"VideoForRenderingForwardFunction.useLayoutEffect9\"];\n            }\n        }[\"VideoForRenderingForwardFunction.useLayoutEffect9\"], [\n            src,\n            onDuration,\n            delayRenderRetries,\n            delayRenderTimeoutInMilliseconds\n        ]);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        disableRemotePlayback: true,\n        ...props2\n    });\n};\nvar VideoForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, _remotionInternalNativeLoopPassed, showInTimeline, onAutoPlayError, ...otherProps } = props2;\n    const { loop, ...propsOtherThanLoop } = props2;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof ref === \"string\") {\n        throw new Error(\"string refs are not supported\");\n    }\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props2.src);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"VideoForwardingFunction.useCallback17[onDuration]\": (src, durationInSeconds)=>{\n            setDurations({\n                type: \"got-duration\",\n                durationInSeconds,\n                src\n            });\n        }\n    }[\"VideoForwardingFunction.useCallback17[onDuration]\"], [\n        setDurations\n    ]);\n    const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"VideoForwardingFunction.useCallback17[onVideoFrame]\": ()=>{}\n    }[\"VideoForwardingFunction.useCallback17[onVideoFrame]\"], []);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n    if (loop && durationFetched !== undefined) {\n        if (!Number.isFinite(durationFetched)) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            });\n        }\n        const mediaDuration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration,\n                playbackRate: props2.playbackRate ?? 1,\n                startFrom\n            }),\n            layout: \"none\",\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n            onDuration,\n            onVideoFrame: onVideoFrame ?? null,\n            ...otherProps,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        onlyWarnForMediaSeekingError: false,\n        ...otherProps,\n        ref,\n        onVideoFrame: null,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        onDuration,\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined\n    });\n};\nvar Video = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Video);\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n    Clipper,\n    Null,\n    useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n    get (_, prop) {\n        if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n            return Config;\n        }\n        return ()=>{\n            console.warn(\"  The CLI configuration has been extracted from Remotion Core.\");\n            console.warn(\"Update the import from the config file:\");\n            console.warn();\n            console.warn(\"- Delete:\");\n            console.warn('import {Config} from \"remotion\";');\n            console.warn(\"+ Replace:\");\n            console.warn('import {Config} from \"@remotion/cli/config\";');\n            console.warn();\n            console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n            process.exit(1);\n        };\n    }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JlbW90aW9uL2Rpc3QvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZkwsVUFBVUksUUFBUUUsTUFBTTtRQUN0QkMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQ2RFLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxLQUFLLENBQUNDLFdBQWFOLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHLElBQU1LO0lBQ3ZDO0FBQ0o7QUFFQSxvQkFBb0I7QUFDa0I7QUFDdEMsSUFBSSxPQUFPQyxnREFBYUEsS0FBSyxZQUFZO0lBQ3ZDLE1BQU1DLE1BQU07UUFDVjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUNELE1BQU0sSUFBSUMsTUFBTUQsSUFBSUUsSUFBSSxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQUNEO0FBRUEsa0JBQWtCO0FBQ2xCLElBQUlDLFVBQVU7SUFDWixNQUFNLElBQUlGLE1BQU07QUFDbEI7QUFFQSxzQ0FBc0M7QUFDWjtBQUUxQixrQ0FBa0M7QUFDbEMsU0FBU0k7SUFDUCxPQUFPO1FBQUM7UUFBTztRQUFRO0tBQUksQ0FBQ0gsSUFBSSxDQUFDO0FBQ25DO0FBQ0EsSUFBSUksZUFBZTtJQUNqQixPQUFPO1FBQUM7UUFBSztLQUFLLENBQUNKLElBQUksQ0FBQztBQUMxQjtBQUNBLElBQUlLLHlCQUF5QjtJQUMzQixNQUFNQyxXQUFXLE1BQTZCLElBQUlDLENBQXdCO0lBQzFFLE1BQU1FLGNBQWMsTUFBbUgsSUFBS0YsQ0FBQUEsQ0FBK047SUFDM1csTUFBTU0sV0FBVyxNQUE2QixJQUFJTixDQUF3QjtJQUMxRSxNQUFNUSxtQkFBbUIsTUFBNkIsSUFBSVIs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UUMsSUFBSSxDQUFDO1lBQ2JsTSxRQUFRa3RELElBQUksQ0FBQztRQUNmO0lBQ0Y7QUFDRjtBQUNBM3JELHVCQUF1Qm9XO0FBMENyQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmt1c2hvZ25lL0RvY3VtZW50cy9BUFBTL2JhemFhci12aWQvYmF6YWFyLXZpZC9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwge1xuICAgICAgZ2V0OiBhbGxbbmFtZV0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiAobmV3VmFsdWUpID0+IGFsbFtuYW1lXSA9ICgpID0+IG5ld1ZhbHVlXG4gICAgfSk7XG59O1xuXG4vLyBzcmMvX2NoZWNrLXJzYy50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaWYgKHR5cGVvZiBjcmVhdGVDb250ZXh0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgY29uc3QgZXJyID0gW1xuICAgICdSZW1vdGlvbiByZXF1aXJlcyBSZWFjdC5jcmVhdGVDb250ZXh0LCBidXQgaXQgaXMgXCJ1bmRlZmluZWRcIi4nLFxuICAgICdJZiB5b3UgYXJlIGluIGEgUmVhY3QgU2VydmVyIENvbXBvbmVudCwgdHVybiBpdCBpbnRvIGEgY2xpZW50IGNvbXBvbmVudCBieSBhZGRpbmcgXCJ1c2UgY2xpZW50XCIgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZS4nLFxuICAgIFwiXCIsXG4gICAgXCJCZWZvcmU6XCIsXG4gICAgJyAgaW1wb3J0IHt1c2VDdXJyZW50RnJhbWV9IGZyb20gXCJyZW1vdGlvblwiOycsXG4gICAgXCJcIixcbiAgICBcIkFmdGVyOlwiLFxuICAgICcgIFwidXNlIGNsaWVudFwiOycsXG4gICAgJyAgaW1wb3J0IHt1c2VDdXJyZW50RnJhbWV9IGZyb20gXCJyZW1vdGlvblwiOydcbiAgXTtcbiAgdGhyb3cgbmV3IEVycm9yKGVyci5qb2luKGBcbmApKTtcbn1cblxuLy8gc3JjL0NsaXBwZXIudHN4XG52YXIgQ2xpcHBlciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiPENsaXBwZXI+IGhhcyBiZWVuIHJlbW92ZWQgYXMgb2YgUmVtb3Rpb24gdjQuMC4yMjguIFRoZSBuYXRpdmUgY2xpcHBpbmcgQVBJcyB3ZXJlIGV4cGVyaW1lbnRhbCBhbmQgc3ViamVjdCB0byByZW1vdmFsIGF0IGFueSB0aW1lLiBXZSByZW1vdmVkIHRoZW0gYmVjYXVzZSB0aGV5IHdlcmUgc3BhcmluZ2x5IHVzZWQgYW5kIG1hZGUgcmVuZGVyaW5nIG9mdGVuIHNsb3dlciByYXRoZXIgdGhhbiBmYXN0ZXIuXCIpO1xufTtcblxuLy8gc3JjL2VuYWJsZS1zZXF1ZW5jZS1zdGFjay10cmFjZXMudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2dldC1yZW1vdGlvbi1lbnZpcm9ubWVudC50c1xuZnVuY3Rpb24gZ2V0Tm9kZUVudlN0cmluZygpIHtcbiAgcmV0dXJuIFtcIk5PRFwiLCBcIkVfRU5cIiwgXCJWXCJdLmpvaW4oXCJcIik7XG59XG52YXIgZ2V0RW52U3RyaW5nID0gKCkgPT4ge1xuICByZXR1cm4gW1wiZVwiLCBcIm52XCJdLmpvaW4oXCJcIik7XG59O1xudmFyIGdldFJlbW90aW9uRW52aXJvbm1lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGlzUGxheWVyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXI7XG4gIGNvbnN0IGlzUmVuZGVyaW5nID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5wcm9jZXNzLmVudiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAod2luZG93LnByb2Nlc3NbZ2V0RW52U3RyaW5nKCldW2dldE5vZGVFbnZTdHJpbmcoKV0gPT09IFwidGVzdFwiIHx8IHdpbmRvdy5wcm9jZXNzW2dldEVudlN0cmluZygpXVtnZXROb2RlRW52U3RyaW5nKCldID09PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucmVtb3Rpb25fcHVwcGV0ZWVyVGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIGNvbnN0IGlzU3R1ZGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNTdHVkaW87XG4gIGNvbnN0IGlzUmVhZE9ubHlTdHVkaW8gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1JlYWRPbmx5U3R1ZGlvO1xuICByZXR1cm4ge1xuICAgIGlzU3R1ZGlvLFxuICAgIGlzUmVuZGVyaW5nLFxuICAgIGlzUGxheWVyLFxuICAgIGlzUmVhZE9ubHlTdHVkaW9cbiAgfTtcbn07XG5cbi8vIHNyYy9lbmFibGUtc2VxdWVuY2Utc3RhY2stdHJhY2VzLnRzXG52YXIgb3JpZ2luYWxDcmVhdGVFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudDtcbnZhciBjb21wb25lbnRzVG9BZGRTdGFja3NUbyA9IFtdO1xudmFyIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMgPSAoKSA9PiB7XG4gIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG9yaWdpbmFsQ3JlYXRlRWxlbWVudCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGlmIChjb21wb25lbnRzVG9BZGRTdGFja3NUby5pbmNsdWRlcyhhcmdBcnJheVswXSkpIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBwcm9wcywgLi4ucmVzdF0gPSBhcmdBcnJheTtcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgLi4ucHJvcHMgPz8ge30sXG4gICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgW2ZpcnN0LCBuZXdQcm9wcywgLi4ucmVzdF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QuY3JlYXRlRWxlbWVudCA9IHByb3h5O1xufTtcbnZhciBhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzID0gKGNvbXBvbmVudCkgPT4ge1xuICBjb21wb25lbnRzVG9BZGRTdGFja3NUby5wdXNoKGNvbXBvbmVudCk7XG4gIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMoKTtcbn07XG5cbi8vIHNyYy9pcy1wbGF5ZXIudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyLCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJc1BsYXllckNvbnRleHQgPSBjcmVhdGVDb250ZXh0MihmYWxzZSk7XG52YXIgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlblxufSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJc1BsYXllckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlSXNQbGF5ZXIgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KElzUGxheWVyQ29udGV4dCk7XG59O1xuXG4vLyBzcmMvdHJ1dGh5LnRzXG5mdW5jdGlvbiB0cnV0aHkodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufVxuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFZFUlNJT04gPSBcIjQuMC4yOTBcIjtcblxuLy8gc3JjL211bHRpcGxlLXZlcnNpb25zLXdhcm5pbmcudHNcbnZhciBjaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNldCA9ICgpID0+IHtcbiAgICBnbG9iYWxUaGlzLnJlbW90aW9uX2ltcG9ydGVkID0gVkVSU0lPTjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LnJlbW90aW9uX2ltcG9ydGVkID0gVkVSU0lPTjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFscmVhZHlJbXBvcnRlZCA9IGdsb2JhbFRoaXMucmVtb3Rpb25faW1wb3J0ZWQgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faW1wb3J0ZWQ7XG4gIGlmIChhbHJlYWR5SW1wb3J0ZWQpIHtcbiAgICBpZiAoYWxyZWFkeUltcG9ydGVkID09PSBWRVJTSU9OKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWxyZWFkeUltcG9ydGVkID09PSBcInN0cmluZ1wiICYmIGFscmVhZHlJbXBvcnRlZC5pbmNsdWRlcyhcIndlYmNvZGVjc1wiKSkge1xuICAgICAgc2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcdUQ4M0RcXHVERUE4IE11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGRldGVjdGVkOiAke1tcbiAgICAgIFZFUlNJT04sXG4gICAgICB0eXBlb2YgYWxyZWFkeUltcG9ydGVkID09PSBcInN0cmluZ1wiID8gYWxyZWFkeUltcG9ydGVkIDogXCJhbiBvbGRlciB2ZXJzaW9uXCJcbiAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgYW5kIFwiKX0uIFRoaXMgd2lsbCBjYXVzZSB0aGluZ3MgdG8gYnJlYWsgaW4gYW4gdW5leHBlY3RlZCB3YXkuXG5DaGVjayB0aGF0IGFsbCB5b3VyIFJlbW90aW9uIHBhY2thZ2VzIGFyZSBvbiB0aGUgc2FtZSB2ZXJzaW9uLiBJZiB5b3VyIGRlcGVuZGVuY2llcyBkZXBlbmQgb24gUmVtb3Rpb24sIG1ha2UgdGhlbSBwZWVyIGRlcGVuZGVuY2llcy4gWW91IGNhbiBhbHNvIHJ1biBcXGBucHggcmVtb3Rpb24gdmVyc2lvbnNcXGAgZnJvbSB5b3VyIHRlcm1pbmFsIHRvIHNlZSB3aGljaCB2ZXJzaW9ucyBhcmUgbWlzbWF0Y2hpbmcuYCk7XG4gIH1cbiAgc2V0KCk7XG59O1xuXG4vLyBzcmMvTnVsbC50c3hcbnZhciBOdWxsID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCI8TnVsbD4gaGFzIGJlZW4gcmVtb3ZlZCBhcyBvZiBSZW1vdGlvbiB2NC4wLjIyOC4gVGhlIG5hdGl2ZSBjbGlwcGluZyBBUElzIHdlcmUgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIHJlbW92YWwgYXQgYW55IHRpbWUuIFdlIHJlbW92ZWQgdGhlbSBiZWNhdXNlIHRoZXkgd2VyZSBzcGFyaW5nbHkgdXNlZCBhbmQgbWFkZSByZW5kZXJpbmcgb2Z0ZW4gc2xvd2VyIHJhdGhlciB0aGFuIGZhc3Rlci5cIik7XG59O1xuXG4vLyBzcmMvU2VxdWVuY2UudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYyLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzksXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0Fic29sdXRlRmlsbC50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgaGFzVGFpbHdpbmRDbGFzc05hbWUgPSAoY2xhc3NOYW1lLCBjbGFzc1ByZWZpeCkgPT4ge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2xhc3NQcmVmaXguc29tZSgocHJlZml4KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5zdGFydHNXaXRoKHByZWZpeCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGAgJHtwcmVmaXh9YCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGA6JHtwcmVmaXh9YCk7XG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgeyBzdHlsZSwgLi4ub3RoZXIgfSA9IHByb3BzO1xuICBjb25zdCBhY3R1YWxTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdG9wOiBoYXNUYWlsd2luZENsYXNzTmFtZShvdGhlci5jbGFzc05hbWUsIFtcInRvcC1cIiwgXCJpbnNldC1cIl0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIGxlZnQ6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKG90aGVyLmNsYXNzTmFtZSwgW1wibGVmdC1cIiwgXCJpbnNldC1cIl0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIHJpZ2h0OiBoYXNUYWlsd2luZENsYXNzTmFtZShvdGhlci5jbGFzc05hbWUsIFtcInJpZ2h0LVwiLCBcImluc2V0LVwiXSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgYm90dG9tOiBoYXNUYWlsd2luZENsYXNzTmFtZShvdGhlci5jbGFzc05hbWUsIFtcImJvdHRvbS1cIiwgXCJpbnNldC1cIl0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIHdpZHRoOiBoYXNUYWlsd2luZENsYXNzTmFtZShvdGhlci5jbGFzc05hbWUsIFtcInctXCJdKSA/IHVuZGVmaW5lZCA6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBoYXNUYWlsd2luZENsYXNzTmFtZShvdGhlci5jbGFzc05hbWUsIFtcImgtXCJdKSA/IHVuZGVmaW5lZCA6IFwiMTAwJVwiLFxuICAgICAgZGlzcGxheTogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXG4gICAgICAgIFwiYmxvY2tcIixcbiAgICAgICAgXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgXCJpbmxpbmVcIixcbiAgICAgICAgXCJmbGV4XCIsXG4gICAgICAgIFwiaW5saW5lLWZsZXhcIixcbiAgICAgICAgXCJmbG93LXJvb3RcIixcbiAgICAgICAgXCJncmlkXCIsXG4gICAgICAgIFwiaW5saW5lLWdyaWRcIixcbiAgICAgICAgXCJjb250ZW50c1wiLFxuICAgICAgICBcImxpc3QtaXRlbVwiLFxuICAgICAgICBcImhpZGRlblwiXG4gICAgICBdKSA/IHVuZGVmaW5lZCA6IFwiZmxleFwiLFxuICAgICAgZmxleERpcmVjdGlvbjogaGFzVGFpbHdpbmRDbGFzc05hbWUob3RoZXIuY2xhc3NOYW1lLCBbXG4gICAgICAgIFwiZmxleC1yb3dcIixcbiAgICAgICAgXCJmbGV4LWNvbFwiLFxuICAgICAgICBcImZsZXgtcm93LXJldmVyc2VcIixcbiAgICAgICAgXCJmbGV4LWNvbC1yZXZlcnNlXCJcbiAgICAgIF0pID8gdW5kZWZpbmVkIDogXCJjb2x1bW5cIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfTtcbiAgfSwgW290aGVyLmNsYXNzTmFtZSwgc3R5bGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHtcbiAgICByZWYsXG4gICAgc3R5bGU6IGFjdHVhbFN0eWxlLFxuICAgIC4uLm90aGVyXG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGwgPSBmb3J3YXJkUmVmKEFic29sdXRlRmlsbFJlZkZvcndhcmRpbmcpO1xuXG4vLyBzcmMvU2VxdWVuY2VDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFNlcXVlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQzKG51bGwpO1xuXG4vLyBzcmMvU2VxdWVuY2VNYW5hZ2VyLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2VxdWVuY2VNYW5hZ2VyID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQoe1xuICByZWdpc3RlclNlcXVlbmNlOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VNYW5hZ2VyQ29udGV4dCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH0sXG4gIHVucmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkXCIpO1xuICB9LFxuICBzZXF1ZW5jZXM6IFtdXG59KTtcbnZhciBTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0ID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQoe1xuICBoaWRkZW46IHt9LFxuICBzZXRIaWRkZW46ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGUgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG59KTtcbnZhciBTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3NlcXVlbmNlcywgc2V0U2VxdWVuY2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgcmVnaXN0ZXJTZXF1ZW5jZSA9IHVzZUNhbGxiYWNrKChzZXEpID0+IHtcbiAgICBzZXRTZXF1ZW5jZXMoKHNlcXMpID0+IHtcbiAgICAgIHJldHVybiBbLi4uc2Vxcywgc2VxXTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiBzZXFzLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc2VxKSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgICAgc2VxdWVuY2VzLFxuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlXG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyU2VxdWVuY2UsIHNlcXVlbmNlcywgdW5yZWdpc3RlclNlcXVlbmNlXSk7XG4gIGNvbnN0IGhpZGRlbkNvbnRleHQgPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGRlbixcbiAgICAgIHNldEhpZGRlblxuICAgIH07XG4gIH0sIFtoaWRkZW5dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzZXF1ZW5jZUNvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBoaWRkZW5Db250ZXh0LFxuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9ub25jZS50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NCwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xudmFyIE5vbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ0KHtcbiAgZ2V0Tm9uY2U6ICgpID0+IDAsXG4gIGZhc3RSZWZyZXNoZXM6IDBcbn0pO1xudmFyIHVzZU5vbmNlID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDIoTm9uY2VDb250ZXh0KTtcbiAgY29uc3QgW25vbmNlLCBzZXROb25jZV0gPSB1c2VTdGF0ZTIoKCkgPT4gY29udGV4dC5nZXROb25jZSgpKTtcbiAgY29uc3QgbGFzdENvbnRleHQgPSB1c2VSZWYoY29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxhc3RDb250ZXh0LmN1cnJlbnQgPT09IGNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdENvbnRleHQuY3VycmVudCA9IGNvbnRleHQ7XG4gICAgc2V0Tm9uY2UoY29udGV4dC5nZXROb25jZSk7XG4gIH0sIFtjb250ZXh0XSk7XG4gIHJldHVybiBub25jZTtcbn07XG5cbi8vIHNyYy90aW1lbGluZS1wb3NpdGlvbi1zdGF0ZS50c1xudmFyIGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUsIHtcbiAgdXNlVGltZWxpbmVTZXRGcmFtZTogKCkgPT4gdXNlVGltZWxpbmVTZXRGcmFtZSxcbiAgdXNlVGltZWxpbmVQb3NpdGlvbjogKCkgPT4gdXNlVGltZWxpbmVQb3NpdGlvbixcbiAgdXNlUGxheWluZ1N0YXRlOiAoKSA9PiB1c2VQbGF5aW5nU3RhdGUsXG4gIHBlcnNpc3RDdXJyZW50RnJhbWU6ICgpID0+IHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gIGdldEluaXRpYWxGcmFtZVN0YXRlOiAoKSA9PiBnZXRJbml0aWFsRnJhbWVTdGF0ZSxcbiAgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbjogKCkgPT4gZ2V0RnJhbWVGb3JDb21wb3NpdGlvbixcbiAgVGltZWxpbmVDb250ZXh0OiAoKSA9PiBUaW1lbGluZUNvbnRleHQsXG4gIFNldFRpbWVsaW5lQ29udGV4dDogKCkgPT4gU2V0VGltZWxpbmVDb250ZXh0XG59KTtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDgsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDUsIHVzZU1lbW8gYXMgdXNlTWVtbzYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS12aWRlby50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NCwgdXNlTWVtbyBhcyB1c2VNZW1vNSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvQ29tcG9zaXRpb25NYW5hZ2VyQ29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBDb21wb3NpdGlvbk1hbmFnZXIgPSBjcmVhdGVDb250ZXh0NSh7XG4gIGNvbXBvc2l0aW9uczogW10sXG4gIGZvbGRlcnM6IFtdLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YTogbnVsbCxcbiAgY2FudmFzQ29udGVudDogbnVsbFxufSk7XG52YXIgQ29tcG9zaXRpb25TZXR0ZXJzID0gY3JlYXRlQ29udGV4dDUoe1xuICByZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlZ2lzdGVyRm9sZGVyOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyRm9sZGVyOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBzZXRDYW52YXNDb250ZW50OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wczogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uOiBudWxsXG59KTtcblxuLy8gc3JjL1Jlc29sdmVDb21wb3NpdGlvbkNvbmZpZy50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDcsXG4gIGNyZWF0ZVJlZixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlMixcbiAgdXNlTWVtbyBhcyB1c2VNZW1vNCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUzXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvRWRpdG9yUHJvcHMudHN4XG5pbXBvcnQgUmVhY3Q0LCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDYsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vM1xufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRWRpdG9yUHJvcHNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDYoe1xuICBwcm9wczoge30sXG4gIHVwZGF0ZVByb3BzOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9LFxuICByZXNldFVuc2F2ZWQ6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn0pO1xudmFyIGVkaXRvclByb3BzUHJvdmlkZXJSZWYgPSBSZWFjdDQuY3JlYXRlUmVmKCk7XG52YXIgdGltZVZhbHVlUmVmID0gUmVhY3Q0LmNyZWF0ZVJlZigpO1xudmFyIEVkaXRvclByb3BzUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtwcm9wcywgc2V0UHJvcHNdID0gUmVhY3Q0LnVzZVN0YXRlKHt9KTtcbiAgY29uc3QgdXBkYXRlUHJvcHMgPSB1c2VDYWxsYmFjazIoKHtcbiAgICBkZWZhdWx0UHJvcHMsXG4gICAgaWQsXG4gICAgbmV3UHJvcHNcbiAgfSkgPT4ge1xuICAgIHNldFByb3BzKChwcmV2KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbaWRdOiB0eXBlb2YgbmV3UHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IG5ld1Byb3BzKHByZXZbaWRdID8/IGRlZmF1bHRQcm9wcykgOiBuZXdQcm9wc1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCByZXNldFVuc2F2ZWQgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIHNldFByb3BzKHt9KTtcbiAgfSwgW10pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGVkaXRvclByb3BzUHJvdmlkZXJSZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UHJvcHM6ICgpID0+IHByb3BzLFxuICAgICAgc2V0UHJvcHNcbiAgICB9O1xuICB9LCBbcHJvcHNdKTtcbiAgY29uc3QgY3R4ID0gdXNlTWVtbzMoKCkgPT4ge1xuICAgIHJldHVybiB7IHByb3BzLCB1cGRhdGVQcm9wcywgcmVzZXRVbnNhdmVkIH07XG4gIH0sIFtwcm9wcywgcmVzZXRVbnNhdmVkLCB1cGRhdGVQcm9wc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDQoRWRpdG9yUHJvcHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eCxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9pbnB1dC1wcm9wcy1zZXJpYWxpemF0aW9uLnRzXG52YXIgREFURV9UT0tFTiA9IFwicmVtb3Rpb24tZGF0ZTpcIjtcbnZhciBGSUxFX1RPS0VOID0gXCJyZW1vdGlvbi1maWxlOlwiO1xudmFyIHNlcmlhbGl6ZUpTT05XaXRoRGF0ZSA9ICh7XG4gIGRhdGEsXG4gIGluZGVudCxcbiAgc3RhdGljQmFzZVxufSkgPT4ge1xuICBsZXQgY3VzdG9tRGF0ZVVzZWQgPSBmYWxzZTtcbiAgbGV0IGN1c3RvbUZpbGVVc2VkID0gZmFsc2U7XG4gIGxldCBtYXBVc2VkID0gZmFsc2U7XG4gIGxldCBzZXRVc2VkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tleV07XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY3VzdG9tRGF0ZVVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7REFURV9UT0tFTn0ke2l0ZW0udG9JU09TdHJpbmcoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgbWFwVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHNldFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgJiYgc3RhdGljQmFzZSAhPT0gbnVsbCAmJiBpdGVtLnN0YXJ0c1dpdGgoc3RhdGljQmFzZSkpIHtcbiAgICAgICAgY3VzdG9tRmlsZVVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7RklMRV9UT0tFTn0ke2l0ZW0ucmVwbGFjZShzdGF0aWNCYXNlICsgXCIvXCIsIFwiXCIpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgaW5kZW50KTtcbiAgICByZXR1cm4geyBzZXJpYWxpemVkU3RyaW5nLCBjdXN0b21EYXRlVXNlZCwgY3VzdG9tRmlsZVVzZWQsIG1hcFVzZWQsIHNldFVzZWQgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHNlcmlhbGl6ZSB0aGUgcGFzc2VkIGlucHV0IHByb3BzIHRvIEpTT046IFwiICsgZXJyLm1lc3NhZ2UpO1xuICB9XG59O1xudmFyIGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMgPSAoZGF0YSkgPT4ge1xuICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLCAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoREFURV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5yZXBsYWNlKERBVEVfVE9LRU4sIFwiXCIpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKEZJTEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gYCR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LyR7dmFsdWUucmVwbGFjZShGSUxFX1RPS0VOLCBcIlwiKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufTtcbnZhciBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemUgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMoc2VyaWFsaXplSlNPTldpdGhEYXRlKHtcbiAgICBkYXRhOiBwcm9wcyxcbiAgICBpbmRlbnQ6IDIsXG4gICAgc3RhdGljQmFzZTogd2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2VcbiAgfSkuc2VyaWFsaXplZFN0cmluZyk7XG59O1xudmFyIHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvID0gKHByb3BzKSA9PiB7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm4gc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplKHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59O1xuXG4vLyBzcmMvY29uZmlnL2lucHV0LXByb3BzLnRzXG52YXIgZGlkV2FyblNTUkltcG9ydCA9IGZhbHNlO1xudmFyIHdhcm5PbmNlU1NSSW1wb3J0ID0gKCkgPT4ge1xuICBpZiAoZGlkV2FyblNTUkltcG9ydCkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuU1NSSW1wb3J0ID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGBnZXRJbnB1dFByb3BzKClgIG9uIHRoZSBzZXJ2ZXIuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBzZXJ2ZXItc2lkZSBhbmQgaGFzIHJldHVybmVkIGFuIGVtcHR5IG9iamVjdC5cIik7XG4gIGNvbnNvbGUud2FybihcIlRvIGhpZGUgdGhpcyB3YXJuaW5nLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb24gdGhlIHNlcnZlcjpcIik7XG4gIGNvbnNvbGUud2FybihcIiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGdldElucHV0UHJvcHMoKVwiKTtcbn07XG52YXIgZ2V0SW5wdXRQcm9wcyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3YXJuT25jZVNTUkltcG9ydCgpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsIGBnZXRJbnB1dFByb3BzKClgIGZyb20gYSA8UGxheWVyPi4gSW5zdGVhZCwgdGhlIHByb3BzIGFyZSBhdmFpbGFibGUgYXMgUmVhY3QgcHJvcHMgZnJvbSBjb21wb25lbnQgdGhhdCB5b3UgcGFzc2VkIGFzIGBjb21wb25lbnRgIHByb3AuXCIpO1xuICB9XG4gIGNvbnN0IHBhcmFtID0gd2luZG93LnJlbW90aW9uX2lucHV0UHJvcHM7XG4gIGlmICghcGFyYW0pIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcGFyc2VkID0gZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyhwYXJhbSk7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBzcmMvY29kZWMudHNcbnZhciB2YWxpZENvZGVjcyA9IFtcbiAgXCJoMjY0XCIsXG4gIFwiaDI2NVwiLFxuICBcInZwOFwiLFxuICBcInZwOVwiLFxuICBcIm1wM1wiLFxuICBcImFhY1wiLFxuICBcIndhdlwiLFxuICBcInByb3Jlc1wiLFxuICBcImgyNjQtbWt2XCIsXG4gIFwiaDI2NC10c1wiLFxuICBcImdpZlwiXG5dO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LWNvZGVjLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURlZmF1bHRDb2RlYyhkZWZhdWx0Q29kZWMsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgZGVmYXVsdENvZGVjID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdENvZGVjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZGVmYXVsdENvZGVjXCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdENvZGVjfS5gKTtcbiAgfVxuICBpZiAoIXZhbGlkQ29kZWNzLmluY2x1ZGVzKGRlZmF1bHRDb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImRlZmF1bHRDb2RlY1wiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBvbmUgb2YgJHt2YWxpZENvZGVjcy5qb2luKFwiLCBcIil9LCBidXQgeW91IHBhc3NlZCAke2RlZmF1bHRDb2RlY30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGltZW5zaW9ucy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb24oYW1vdW50LCBuYW1lT2ZQcm9wLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGFtb3VudCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFtb3VudH1gKTtcbiAgfVxuICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3Qgbm90IGJlIE5hTiwgYnV0IGlzIE5hTi5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gIH1cbiAgaWYgKGFtb3VudCAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gIH1cbiAgaWYgKGFtb3VudCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Ftb3VudH0uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZHVyYXRpb24taW4tZnJhbWVzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lcywgb3B0aW9ucykge1xuICBjb25zdCB7IGFsbG93RmxvYXRzLCBjb21wb25lbnQgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IGlzIG1pc3NpbmcuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGR1cmF0aW9uSW5GcmFtZXMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFhbGxvd0Zsb2F0cyAmJiBkdXJhdGlvbkluRnJhbWVzICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbkluRnJhbWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWZwcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVGcHMoZnBzLCBsb2NhdGlvbiwgaXNHaWYpIHtcbiAgaWYgKHR5cGVvZiBmcHMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGZwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBmaW5pdGUsIGJ1dCB5b3UgcGFzc2VkICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc05hTihmcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3Qgbm90IGJlIE5hTiwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoZnBzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImZwc1wiIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzR2lmICYmIGZwcyA+IDUwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIEZQUyBmb3IgYSBHSUYgY2Fubm90IGJlIGhpZ2hlciB0aGFuIDUwLiBVc2UgdGhlIC0tZXZlcnktbnRoLWZyYW1lIG9wdGlvbiB0byBsb3dlciB0aGUgRlBTOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3JlbmRlci1hcy1naWZgKTtcbiAgfVxufVxuXG4vLyBzcmMvcmVzb2x2ZS12aWRlby1jb25maWcudHNcbnZhciB2YWxpZGF0ZUNhbGN1bGF0ZWQgPSAoe1xuICBjYWxjdWxhdGVkLFxuICBjb21wb3NpdGlvbklkLFxuICBjb21wb3NpdGlvbkZwcyxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGgsXG4gIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lc1xufSkgPT4ge1xuICBjb25zdCBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gPSBgY2FsY3VsYXRlZCBieSBjYWxjdWxhdGVNZXRhZGF0YSgpIGZvciB0aGUgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgO1xuICBjb25zdCBkZWZhdWx0RXJyb3JMb2NhdGlvbiA9IGBvZiB0aGUgXCI8Q29tcG9zaXRpb24gLz5cIiBjb21wb25lbnQgd2l0aCB0aGUgaWQgXCIke2NvbXBvc2l0aW9uSWR9XCJgO1xuICBjb25zdCB3aWR0aCA9IGNhbGN1bGF0ZWQ/LndpZHRoID8/IGNvbXBvc2l0aW9uV2lkdGggPz8gdW5kZWZpbmVkO1xuICB2YWxpZGF0ZURpbWVuc2lvbih3aWR0aCwgXCJ3aWR0aFwiLCBjYWxjdWxhdGVkPy53aWR0aCA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uKTtcbiAgY29uc3QgaGVpZ2h0ID0gY2FsY3VsYXRlZD8uaGVpZ2h0ID8/IGNvbXBvc2l0aW9uSGVpZ2h0ID8/IHVuZGVmaW5lZDtcbiAgdmFsaWRhdGVEaW1lbnNpb24oaGVpZ2h0LCBcImhlaWdodFwiLCBjYWxjdWxhdGVkPy5oZWlnaHQgPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbik7XG4gIGNvbnN0IGZwcyA9IGNhbGN1bGF0ZWQ/LmZwcyA/PyBjb21wb3NpdGlvbkZwcyA/PyBudWxsO1xuICB2YWxpZGF0ZUZwcyhmcHMsIGNhbGN1bGF0ZWQ/LmZwcyA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uLCBmYWxzZSk7XG4gIGNvbnN0IGR1cmF0aW9uSW5GcmFtZXMgPSBjYWxjdWxhdGVkPy5kdXJhdGlvbkluRnJhbWVzID8/IGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyA/PyBudWxsO1xuICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lcywge1xuICAgIGFsbG93RmxvYXRzOiBmYWxzZSxcbiAgICBjb21wb25lbnQ6IGBvZiB0aGUgXCI8Q29tcG9zaXRpb24gLz5cIiBjb21wb25lbnQgd2l0aCB0aGUgaWQgXCIke2NvbXBvc2l0aW9uSWR9XCJgXG4gIH0pO1xuICBjb25zdCBkZWZhdWx0Q29kZWMgPSBjYWxjdWxhdGVkPy5kZWZhdWx0Q29kZWM7XG4gIHZhbGlkYXRlRGVmYXVsdENvZGVjKGRlZmF1bHRDb2RlYywgY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uKTtcbiAgY29uc3QgZGVmYXVsdE91dE5hbWUgPSBjYWxjdWxhdGVkPy5kZWZhdWx0T3V0TmFtZTtcbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgZnBzLCBkdXJhdGlvbkluRnJhbWVzLCBkZWZhdWx0Q29kZWMsIGRlZmF1bHRPdXROYW1lIH07XG59O1xudmFyIHJlc29sdmVWaWRlb0NvbmZpZyA9ICh7XG4gIGNhbGN1bGF0ZU1ldGFkYXRhLFxuICBzaWduYWwsXG4gIGRlZmF1bHRQcm9wcyxcbiAgb3JpZ2luYWxQcm9wcyxcbiAgY29tcG9zaXRpb25JZCxcbiAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICBjb21wb3NpdGlvbkZwcyxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGhcbn0pID0+IHtcbiAgY29uc3QgY2FsY3VsYXRlZFByb20gPSBjYWxjdWxhdGVNZXRhZGF0YSA/IGNhbGN1bGF0ZU1ldGFkYXRhKHtcbiAgICBkZWZhdWx0UHJvcHMsXG4gICAgcHJvcHM6IG9yaWdpbmFsUHJvcHMsXG4gICAgYWJvcnRTaWduYWw6IHNpZ25hbCxcbiAgICBjb21wb3NpdGlvbklkXG4gIH0pIDogbnVsbDtcbiAgaWYgKGNhbGN1bGF0ZWRQcm9tICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVkUHJvbSA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiBjYWxjdWxhdGVkUHJvbSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVkUHJvbS50aGVuKChjKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGZwcyxcbiAgICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgICBkZWZhdWx0T3V0TmFtZVxuICAgICAgfSA9IHZhbGlkYXRlQ2FsY3VsYXRlZCh7XG4gICAgICAgIGNhbGN1bGF0ZWQ6IGMsXG4gICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgY29tcG9zaXRpb25GcHMsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgICAgICBjb21wb3NpdGlvbklkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZwcyxcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgaWQ6IGNvbXBvc2l0aW9uSWQsXG4gICAgICAgIGRlZmF1bHRQcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oZGVmYXVsdFByb3BzKSxcbiAgICAgICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGMucHJvcHMgPz8gb3JpZ2luYWxQcm9wcyksXG4gICAgICAgIGRlZmF1bHRDb2RlYzogZGVmYXVsdENvZGVjID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRPdXROYW1lOiBkZWZhdWx0T3V0TmFtZSA/PyBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGRhdGEgPSB2YWxpZGF0ZUNhbGN1bGF0ZWQoe1xuICAgIGNhbGN1bGF0ZWQ6IGNhbGN1bGF0ZWRQcm9tLFxuICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICBjb21wb3NpdGlvbkZwcyxcbiAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgIGNvbXBvc2l0aW9uSWRcbiAgfSk7XG4gIGlmIChjYWxjdWxhdGVkUHJvbSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgaWQ6IGNvbXBvc2l0aW9uSWQsXG4gICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgICBwcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8ob3JpZ2luYWxQcm9wcyksXG4gICAgICBkZWZhdWx0Q29kZWM6IG51bGwsXG4gICAgICBkZWZhdWx0T3V0TmFtZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgIGRlZmF1bHRQcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oZGVmYXVsdFByb3BzID8/IHt9KSxcbiAgICBwcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oY2FsY3VsYXRlZFByb20ucHJvcHMgPz8gb3JpZ2luYWxQcm9wcyksXG4gICAgZGVmYXVsdENvZGVjOiBjYWxjdWxhdGVkUHJvbS5kZWZhdWx0Q29kZWMgPz8gbnVsbCxcbiAgICBkZWZhdWx0T3V0TmFtZTogY2FsY3VsYXRlZFByb20uZGVmYXVsdE91dE5hbWUgPz8gbnVsbFxuICB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWdPckNhdGNoID0gKHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb21pc2VPclJldHVyblZhbHVlID0gcmVzb2x2ZVZpZGVvQ29uZmlnKHBhcmFtcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgcmVzdWx0OiBwcm9taXNlT3JSZXR1cm5WYWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvcjogZXJyXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL1Jlc29sdmVDb21wb3NpdGlvbkNvbmZpZy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ3KG51bGwpO1xudmFyIHJlc29sdmVDb21wb3NpdGlvbnNSZWYgPSBjcmVhdGVSZWYoKTtcbnZhciBuZWVkc1Jlc29sdXRpb24gPSAoY29tcG9zaXRpb24pID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEpO1xufTtcbnZhciBQUk9QU19VUERBVEVEX0VYVEVSTkFMTFkgPSBcInJlbW90aW9uLnByb3BzVXBkYXRlZEV4dGVybmFsbHlcIjtcbnZhciBSZXNvbHZlQ29tcG9zaXRpb25Db25maWcgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtjdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbiwgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb25dID0gdXNlU3RhdGUzKG51bGwpO1xuICBjb25zdCB7IGNvbXBvc2l0aW9ucywgY2FudmFzQ29udGVudCwgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQzKENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHsgZmFzdFJlZnJlc2hlcyB9ID0gdXNlQ29udGV4dDMoTm9uY2VDb250ZXh0KTtcbiAgY29uc3Qgc2VsZWN0ZWRDb21wb3NpdGlvbiA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGNhbnZhc0NvbnRlbnQgJiYgY2FudmFzQ29udGVudC50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgJiYgY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkID09PSBjLmlkKTtcbiAgfSwgW2NhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9uc10pO1xuICBjb25zdCByZW5kZXJNb2RhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uKTtcbiAgY29uc3QgeyBwcm9wczogYWxsRWRpdG9yUHJvcHMgfSA9IHVzZUNvbnRleHQzKEVkaXRvclByb3BzQ29udGV4dCk7XG4gIGNvbnN0IGlucHV0UHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyID8ge30gOiBnZXRJbnB1dFByb3BzKCkgPz8ge307XG4gIH0sIFtdKTtcbiAgY29uc3QgW3Jlc29sdmVkQ29uZmlncywgc2V0UmVzb2x2ZWRDb25maWdzXSA9IHVzZVN0YXRlMyh7fSk7XG4gIGNvbnN0IHNlbGVjdGVkRWRpdG9yUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdGVkQ29tcG9zaXRpb24gPyBhbGxFZGl0b3JQcm9wc1tzZWxlY3RlZENvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIHNlbGVjdGVkQ29tcG9zaXRpb25dKTtcbiAgY29uc3QgcmVuZGVyTW9kYWxQcm9wcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4gcmVuZGVyTW9kYWxDb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW3JlbmRlck1vZGFsQ29tcG9zaXRpb24uaWRdID8/IHt9IDoge307XG4gIH0sIFthbGxFZGl0b3JQcm9wcywgcmVuZGVyTW9kYWxDb21wb3NpdGlvbl0pO1xuICBjb25zdCBoYXNSZXNvbHV0aW9uID0gQm9vbGVhbihjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSk7XG4gIGNvbnN0IGRvUmVzb2x1dGlvbiA9IHVzZUNhbGxiYWNrMygoe1xuICAgIGNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgIGNvbWJpbmVkUHJvcHMsXG4gICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgIGNvbXBvc2l0aW9uSWQsXG4gICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICBkZWZhdWx0UHJvcHNcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICAgIGlmIChoYXNSZXNvbHV0aW9uKSB7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gICAgY29uc3QgeyBzaWduYWwgfSA9IGNvbnRyb2xsZXI7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZVZpZGVvQ29uZmlnT3JDYXRjaCh7XG4gICAgICBjb21wb3NpdGlvbklkLFxuICAgICAgY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgICBvcmlnaW5hbFByb3BzOiBjb21iaW5lZFByb3BzLFxuICAgICAgc2lnbmFsLFxuICAgICAgZGVmYXVsdFByb3BzLFxuICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICAgICAgY29tcG9zaXRpb25GcHMsXG4gICAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICAgIGNvbXBvc2l0aW9uV2lkdGhcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAuLi5yLFxuICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gICAgY29uc3QgcHJvbU9yTm90ID0gcmVzdWx0LnJlc3VsdDtcbiAgICBpZiAodHlwZW9mIHByb21Pck5vdCA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiBwcm9tT3JOb3QpIHtcbiAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4ge1xuICAgICAgICBjb25zdCBwcmV2ID0gcltjb21wb3NpdGlvbklkXTtcbiAgICAgICAgaWYgKHByZXY/LnR5cGUgPT09IFwic3VjY2Vzc1wiIHx8IHByZXY/LnR5cGUgPT09IFwic3VjY2Vzcy1hbmQtcmVmcmVzaGluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzLWFuZC1yZWZyZXNoaW5nXCIsXG4gICAgICAgICAgICAgIHJlc3VsdDogcHJldi5yZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBwcm9tT3JOb3QudGhlbigoYykgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgcmVzdWx0OiBjXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgLi4ucixcbiAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgcmVzdWx0OiBwcm9tT3JOb3RcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgfSwgW2hhc1Jlc29sdXRpb25dKTtcbiAgY29uc3QgY3VycmVudENvbXBvc2l0aW9uID0gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiID8gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkIDogbnVsbDtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTIocmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbjogKGlkKSA9PiB7XG4gICAgICAgIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uKGlkKTtcbiAgICAgIH0sXG4gICAgICByZWxvYWRDdXJyZW50bHlTZWxlY3RlZENvbXBvc2l0aW9uOiAoKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICAgIGlmICghY29tcG9zaXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGNvbXBvc2l0aW9uIHdpdGggaWQgJHtjdXJyZW50Q29tcG9zaXRpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRpdG9yUHJvcHMgPSBhbGxFZGl0b3JQcm9wc1tjdXJyZW50Q29tcG9zaXRpb25dID8/IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgLi4uY29tcG9zaXRpb24uZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgICAgIC4uLmVkaXRvclByb3BzID8/IHt9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAuLi5pbnB1dFByb3BzID8/IHt9XG4gICAgICAgIH07XG4gICAgICAgIGRvUmVzb2x1dGlvbih7XG4gICAgICAgICAgZGVmYXVsdFByb3BzLFxuICAgICAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBjb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgICBjb21iaW5lZFByb3BzOiBwcm9wcyxcbiAgICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXM6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbkZwczogY29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IGNvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IGNvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25JZDogY29tcG9zaXRpb24uaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW1xuICAgIGFsbEVkaXRvclByb3BzLFxuICAgIGNvbXBvc2l0aW9ucyxcbiAgICBjdXJyZW50Q29tcG9zaXRpb24sXG4gICAgZG9SZXNvbHV0aW9uLFxuICAgIGlucHV0UHJvcHNcbiAgXSk7XG4gIGNvbnN0IGlzVGhlU2FtZSA9IHNlbGVjdGVkQ29tcG9zaXRpb24/LmlkID09PSByZW5kZXJNb2RhbENvbXBvc2l0aW9uPy5pZDtcbiAgY29uc3QgY3VycmVudERlZmF1bHRQcm9wcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2VsZWN0ZWRDb21wb3NpdGlvbj8uZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgLi4uc2VsZWN0ZWRFZGl0b3JQcm9wcyA/PyB7fVxuICAgIH07XG4gIH0sIFtzZWxlY3RlZENvbXBvc2l0aW9uPy5kZWZhdWx0UHJvcHMsIHNlbGVjdGVkRWRpdG9yUHJvcHNdKTtcbiAgY29uc3Qgb3JpZ2luYWxQcm9wcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgIC4uLmlucHV0UHJvcHMgPz8ge31cbiAgICB9O1xuICB9LCBbY3VycmVudERlZmF1bHRQcm9wcywgaW5wdXRQcm9wc10pO1xuICBjb25zdCBjYW5SZXNvbHZlID0gc2VsZWN0ZWRDb21wb3NpdGlvbiAmJiBuZWVkc1Jlc29sdXRpb24oc2VsZWN0ZWRDb21wb3NpdGlvbik7XG4gIGNvbnN0IHNob3VsZElnbm9yZVVwZGF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lnbm9yZUZhc3RSZWZyZXNoVXBkYXRlICYmIGZhc3RSZWZyZXNoZXMgPD0gd2luZG93LnJlbW90aW9uX2lnbm9yZUZhc3RSZWZyZXNoVXBkYXRlO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAoc2hvdWxkSWdub3JlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYW5SZXNvbHZlKSB7XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gZG9SZXNvbHV0aW9uKHtcbiAgICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IHNlbGVjdGVkQ29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgICAgIGNvbWJpbmVkUHJvcHM6IG9yaWdpbmFsUHJvcHMsXG4gICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lczogc2VsZWN0ZWRDb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uRnBzOiBzZWxlY3RlZENvbXBvc2l0aW9uLmZwcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogc2VsZWN0ZWRDb21wb3NpdGlvbi5oZWlnaHQgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25XaWR0aDogc2VsZWN0ZWRDb21wb3NpdGlvbi53aWR0aCA/PyBudWxsLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgICAgIGNvbXBvc2l0aW9uSWQ6IHNlbGVjdGVkQ29tcG9zaXRpb24uaWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtcbiAgICBjYW5SZXNvbHZlLFxuICAgIGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgZG9SZXNvbHV0aW9uLFxuICAgIG9yaWdpbmFsUHJvcHMsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uZHVyYXRpb25JbkZyYW1lcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5mcHMsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uaGVpZ2h0LFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmlkLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LndpZHRoLFxuICAgIHNob3VsZElnbm9yZVVwZGF0ZVxuICBdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHNob3VsZElnbm9yZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZLCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgcmVzZXRVbnNhdmVkOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVuZGVyTW9kYWxDb21wb3NpdGlvbiAmJiAhaXNUaGVTYW1lKSB7XG4gICAgICBjb25zdCBjb21iaW5lZFByb3BzID0ge1xuICAgICAgICAuLi5yZW5kZXJNb2RhbENvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4ucmVuZGVyTW9kYWxQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbklkOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tYmluZWRQcm9wc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgZG9SZXNvbHV0aW9uLFxuICAgIGlucHV0UHJvcHMsXG4gICAgaXNUaGVTYW1lLFxuICAgIHJlbmRlck1vZGFsQ29tcG9zaXRpb24sXG4gICAgcmVuZGVyTW9kYWxQcm9wc1xuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWRDb25maWdzSW5jbHVkaW5nU3RhdGljT25lcyA9IHVzZU1lbW80KCgpID0+IHtcbiAgICBjb25zdCBzdGF0aWNDb21wcyA9IGNvbXBvc2l0aW9ucy5maWx0ZXIoKGMpID0+IHtcbiAgICAgIHJldHVybiBjLmNhbGN1bGF0ZU1ldGFkYXRhID09PSBudWxsO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNvbHZlZENvbmZpZ3MsXG4gICAgICAuLi5zdGF0aWNDb21wcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbY3Vyci5pZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgcmVzdWx0OiB7IC4uLmN1cnIsIGRlZmF1bHRQcm9wczogY3Vyci5kZWZhdWx0UHJvcHMgPz8ge30gfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0sIFtjb21wb3NpdGlvbnMsIHJlc29sdmVkQ29uZmlnc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDUoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnID0gKHByZWZlcnJlZENvbXBvc2l0aW9uSWQpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQzKFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQpO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDMoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0MyhDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICBjb25zdCBjb21wb3NpdGlvbklkID0gcHJlZmVycmVkQ29tcG9zaXRpb25JZCA/PyBjdXJyZW50Q29tcG9zaXRpb247XG4gIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGNvbXBvc2l0aW9uSWQpO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW2NvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIGNvbXBvc2l0aW9uXSk7XG4gIHJldHVybiB1c2VNZW1vNCgoKSA9PiB7XG4gICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIC4uLmN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgICBkZWZhdWx0UHJvcHM6IGNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIW5lZWRzUmVzb2x1dGlvbihjb21wb3NpdGlvbikpIHtcbiAgICAgIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhjb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgICAgIGFsbG93RmxvYXRzOiBmYWxzZSxcbiAgICAgICAgY29tcG9uZW50OiBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlRnBzKGNvbXBvc2l0aW9uLmZwcywgYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YCwgZmFsc2UpO1xuICAgICAgdmFsaWRhdGVEaW1lbnNpb24oY29tcG9zaXRpb24ud2lkdGgsIFwid2lkdGhcIiwgYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YCk7XG4gICAgICB2YWxpZGF0ZURpbWVuc2lvbihjb21wb3NpdGlvbi5oZWlnaHQsIFwiaGVpZ2h0XCIsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIHdpZHRoOiBjb21wb3NpdGlvbi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNvbXBvc2l0aW9uLmhlaWdodCxcbiAgICAgICAgICBmcHM6IGNvbXBvc2l0aW9uLmZwcyxcbiAgICAgICAgICBpZDogY29tcG9zaXRpb24uaWQsXG4gICAgICAgICAgZHVyYXRpb25JbkZyYW1lczogY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgICBkZWZhdWx0UHJvcHM6IGNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgLi4uY29tcG9zaXRpb24uZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgICAgICAgLi4uc2VsZWN0ZWRFZGl0b3JQcm9wcyA/PyB7fSxcbiAgICAgICAgICAgIC4uLnR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyID8ge30gOiBnZXRJbnB1dFByb3BzKCkgPz8ge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmF1bHRDb2RlYzogbnVsbCxcbiAgICAgICAgICBkZWZhdWx0T3V0TmFtZTogbnVsbFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHRbY29tcG9zaXRpb24uaWRdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRbY29tcG9zaXRpb24uaWRdO1xuICB9LCBbY29tcG9zaXRpb24sIGNvbnRleHQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCBzZWxlY3RlZEVkaXRvclByb3BzXSk7XG59O1xuXG4vLyBzcmMvdXNlLXZpZGVvLnRzXG52YXIgdXNlVmlkZW8gPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzQ29udGVudCwgY29tcG9zaXRpb25zLCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSB9ID0gdXNlQ29udGV4dDQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4ge1xuICAgIHJldHVybiBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgJiYgYy5pZCA9PT0gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkO1xuICB9KTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKHNlbGVjdGVkPy5pZCA/PyBudWxsKTtcbiAgcmV0dXJuIHVzZU1lbW81KCgpID0+IHtcbiAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc29sdmVkLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LFxuICAgICAgZGVmYXVsdFByb3BzOiBzZWxlY3RlZC5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICBpZDogc2VsZWN0ZWQuaWQsXG4gICAgICAuLi5jdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSA/PyB7fSxcbiAgICAgIGNvbXBvbmVudDogc2VsZWN0ZWQuY29tcG9uZW50XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCByZXNvbHZlZCwgc2VsZWN0ZWRdKTtcbn07XG5cbi8vIHNyYy90aW1lbGluZS1wb3NpdGlvbi1zdGF0ZS50c1xudmFyIFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ4KHtcbiAgZnJhbWU6IHt9LFxuICBwbGF5aW5nOiBmYWxzZSxcbiAgcGxheWJhY2tSYXRlOiAxLFxuICByb290SWQ6IFwiXCIsXG4gIGltcGVyYXRpdmVQbGF5aW5nOiB7XG4gICAgY3VycmVudDogZmFsc2VcbiAgfSxcbiAgc2V0UGxheWJhY2tSYXRlOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgYXVkaW9BbmRWaWRlb1RhZ3M6IHsgY3VycmVudDogW10gfVxufSk7XG52YXIgU2V0VGltZWxpbmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDgoe1xuICBzZXRGcmFtZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIHNldFBsYXlpbmc6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9XG59KTtcbnZhciBtYWtlS2V5ID0gKCkgPT4ge1xuICByZXR1cm4gYHJlbW90aW9uLnRpbWUtYWxsYDtcbn07XG52YXIgcGVyc2lzdEN1cnJlbnRGcmFtZSA9ICh0aW1lKSA9PiB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1ha2VLZXkoKSwgSlNPTi5zdHJpbmdpZnkodGltZSkpO1xufTtcbnZhciBnZXRJbml0aWFsRnJhbWVTdGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgaXRlbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG1ha2VLZXkoKSkgPz8gXCJ7fVwiO1xuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGl0ZW0pO1xuICByZXR1cm4gb2JqO1xufTtcbnZhciBnZXRGcmFtZUZvckNvbXBvc2l0aW9uID0gKGNvbXBvc2l0aW9uKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYWtlS2V5KCkpID8/IFwie31cIjtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgaWYgKG9ialtjb21wb3NpdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBOdW1iZXIob2JqW2NvbXBvc2l0aW9uXSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlbW90aW9uX2luaXRpYWxGcmFtZSA/PyAwO1xufTtcbnZhciB1c2VUaW1lbGluZVBvc2l0aW9uID0gKCkgPT4ge1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvKCk7XG4gIGNvbnN0IHN0YXRlID0gdXNlQ29udGV4dDUoVGltZWxpbmVDb250ZXh0KTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gMCA6IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbiAgfVxuICBjb25zdCB1bmNsYW1wZWQgPSBzdGF0ZS5mcmFtZVt2aWRlb0NvbmZpZy5pZF0gPz8gKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllciA/IDAgOiBnZXRGcmFtZUZvckNvbXBvc2l0aW9uKHZpZGVvQ29uZmlnLmlkKSk7XG4gIHJldHVybiBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gMSwgdW5jbGFtcGVkKTtcbn07XG52YXIgdXNlVGltZWxpbmVTZXRGcmFtZSA9ICgpID0+IHtcbiAgY29uc3QgeyBzZXRGcmFtZSB9ID0gdXNlQ29udGV4dDUoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgcmV0dXJuIHNldEZyYW1lO1xufTtcbnZhciB1c2VQbGF5aW5nU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgcGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQ1KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0UGxheWluZyB9ID0gdXNlQ29udGV4dDUoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW82KCgpID0+IFtwbGF5aW5nLCBzZXRQbGF5aW5nLCBpbXBlcmF0aXZlUGxheWluZ10sIFtpbXBlcmF0aXZlUGxheWluZywgcGxheWluZywgc2V0UGxheWluZ10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby1jb25maWcudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NhblVzZVJlbW90aW9uSG9va3MudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIENhblVzZVJlbW90aW9uSG9va3MgPSBjcmVhdGVDb250ZXh0OShmYWxzZSk7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDYoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS11bnNhZmUtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ2LCB1c2VNZW1vIGFzIHVzZU1lbW83IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVW5zYWZlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0NihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjdHhXaWR0aCA9IGNvbnRleHQ/LndpZHRoID8/IG51bGw7XG4gIGNvbnN0IGN0eEhlaWdodCA9IGNvbnRleHQ/LmhlaWdodCA/PyBudWxsO1xuICBjb25zdCBjdHhEdXJhdGlvbiA9IGNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICByZXR1cm4gdXNlTWVtbzcoKCkgPT4ge1xuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgZGVmYXVsdE91dE5hbWVcbiAgICB9ID0gdmlkZW87XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgd2lkdGg6IGN0eFdpZHRoID8/IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBjdHhIZWlnaHQgPz8gaGVpZ2h0LFxuICAgICAgZnBzLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogY3R4RHVyYXRpb24gPz8gZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgZGVmYXVsdE91dE5hbWVcbiAgICB9O1xuICB9LCBbY3R4RHVyYXRpb24sIGN0eEhlaWdodCwgY3R4V2lkdGgsIHZpZGVvXSk7XG59O1xuXG4vLyBzcmMvdXNlLXZpZGVvLWNvbmZpZy50c1xudmFyIHVzZVZpZGVvQ29uZmlnID0gKCkgPT4ge1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0NyhDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgY29uc3QgaXNQbGF5ZXIgPSB1c2VJc1BsYXllcigpO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzUGxheWVyIHx8IGlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICBcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZC4gTGlrZWx5IHJlYXNvbnM6XCIsXG4gICAgICAgIFwiLSBZb3UgYXJlIHByb2JhYmx5IGNhbGxpbmcgdXNlVmlkZW9Db25maWcoKSBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudCBwYXNzZWQgdG8gPFBsYXllciAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci9leGFtcGxlcyBmb3IgaG93IHRvIHNldCB1cCB0aGUgUGxheWVyIGNvcnJlY3RseS5cIixcbiAgICAgICAgXCItIFlvdSBoYXZlIG11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGluc3RhbGxlZCB3aGljaCBjYXVzZXMgdGhlIFJlYWN0IGNvbnRleHQgdG8gZ2V0IGxvc3QuXCJcbiAgICAgIF0uam9pbihcIi1cIikpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2aWRlbyBjb25maWcgZm91bmQuIFlvdSBhcmUgcHJvYmFibHkgY2FsbGluZyB1c2VWaWRlb0NvbmZpZygpIGZyb20gYSBjb21wb25lbnQgd2hpY2ggaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgYXMgYSA8Q29tcG9zaXRpb24gLz4uIFNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy90aGUtZnVuZGFtZW50YWxzI2RlZmluaW5nLWNvbXBvc2l0aW9ucyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gIH1cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIHVzZVZpZGVvQ29uZmlnKCkgb3V0c2lkZSBhIFJlbW90aW9uIGNvbXBvc2l0aW9uLlwiKTtcbiAgfVxuICByZXR1cm4gdmlkZW9Db25maWc7XG59O1xuXG4vLyBzcmMvZnJlZXplLnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0OSwgdXNlTWVtbyBhcyB1c2VNZW1vOCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDggfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VDdXJyZW50RnJhbWUgPSAoKSA9PiB7XG4gIGNvbnN0IGNhblVzZVJlbW90aW9uSG9va3MgPSB1c2VDb250ZXh0OChDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgaWYgKCFjYW5Vc2VSZW1vdGlvbkhvb2tzKSB7XG4gICAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhIGNvbXBvbmVudCB0aGF0IHdhcyBwYXNzZWQgdG8gPFBsYXllcj4uIFNlZTogaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2V4YW1wbGVzYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgdXNlQ3VycmVudEZyYW1lKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhIGNvbXBvbmVudCB0aGF0IHdhcyByZWdpc3RlcmVkIGFzIGEgY29tcG9zaXRpb24uIFNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy90aGUtZnVuZGFtZW50YWxzI2RlZmluaW5nLWNvbXBvc2l0aW9uc2ApO1xuICB9XG4gIGNvbnN0IGZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDgoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgY29udGV4dE9mZnNldCA9IGNvbnRleHQgPyBjb250ZXh0LmN1bXVsYXRlZEZyb20gKyBjb250ZXh0LnJlbGF0aXZlRnJvbSA6IDA7XG4gIHJldHVybiBmcmFtZSAtIGNvbnRleHRPZmZzZXQ7XG59O1xuXG4vLyBzcmMvZnJlZXplLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGcmVlemUgPSAoe1xuICBmcmFtZTogZnJhbWVUb0ZyZWV6ZSxcbiAgY2hpbGRyZW4sXG4gIGFjdGl2ZSA9IHRydWVcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8RnJlZXplIC8+IGNvbXBvbmVudCByZXF1aXJlcyBhICdmcmFtZScgcHJvcCwgYnV0IG5vbmUgd2FzIHBhc3NlZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgaXMgb2YgdHlwZSAke3R5cGVvZiBmcmFtZVRvRnJlZXplfWApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgcmVhbCBudW1iZXIsIGJ1dCBpdCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgZmluaXRlIG51bWJlciwgYnV0IGl0IGlzICR7ZnJhbWVUb0ZyZWV6ZX0uYCk7XG4gIH1cbiAgY29uc3QgaXNBY3RpdmUgPSB1c2VNZW1vOCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGl2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlKGZyYW1lKTtcbiAgICB9XG4gIH0sIFthY3RpdmUsIGZyYW1lXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ29udGV4dCA9IHVzZUNvbnRleHQ5KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQ5KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHJlbGF0aXZlRnJvbSA9IHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDA7XG4gIGNvbnN0IHRpbWVsaW5lVmFsdWUgPSB1c2VNZW1vOCgoKSA9PiB7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIHRpbWVsaW5lQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRpbWVsaW5lQ29udGV4dCxcbiAgICAgIHBsYXlpbmc6IGZhbHNlLFxuICAgICAgaW1wZXJhdGl2ZVBsYXlpbmc6IHtcbiAgICAgICAgY3VycmVudDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmcmFtZToge1xuICAgICAgICBbdmlkZW9Db25maWcuaWRdOiBmcmFtZVRvRnJlZXplICsgcmVsYXRpdmVGcm9tXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzQWN0aXZlLCB0aW1lbGluZUNvbnRleHQsIHZpZGVvQ29uZmlnLmlkLCBmcmFtZVRvRnJlZXplLCByZWxhdGl2ZUZyb21dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0aW1lbGluZVZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL1NlcXVlbmNlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAoe1xuICBmcm9tID0gMCxcbiAgZHVyYXRpb25JbkZyYW1lcyA9IEluZmluaXR5LFxuICBjaGlsZHJlbixcbiAgbmFtZSxcbiAgaGVpZ2h0LFxuICB3aWR0aCxcbiAgc2hvd0luVGltZWxpbmUgPSB0cnVlLFxuICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2ssXG4gIF9yZW1vdGlvbkludGVybmFsUHJlbW91bnREaXNwbGF5OiBwcmVtb3VudERpc3BsYXksXG4gIC4uLm90aGVyXG59LCByZWYpID0+IHtcbiAgY29uc3QgeyBsYXlvdXQgPSBcImFic29sdXRlLWZpbGxcIiB9ID0gb3RoZXI7XG4gIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZTQoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MTAoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgeyByb290SWQgfSA9IHVzZUNvbnRleHQxMChUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBjdW11bGF0ZWRGcm9tID0gcGFyZW50U2VxdWVuY2UgPyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tICsgcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tIDogMDtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBpZiAobGF5b3V0ICE9PSBcImFic29sdXRlLWZpbGxcIiAmJiBsYXlvdXQgIT09IFwibm9uZVwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGxheW91dCBwcm9wIG9mIDxTZXF1ZW5jZSAvPiBleHBlY3RzIGVpdGhlciBcImFic29sdXRlLWZpbGxcIiBvciBcIm5vbmVcIiwgYnV0IHlvdSBwYXNzZWQ6ICR7bGF5b3V0fWApO1xuICB9XG4gIGlmIChsYXlvdXQgPT09IFwibm9uZVwiICYmIHR5cGVvZiBvdGhlci5zdHlsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIGxheW91dD1cIm5vbmVcIiwgeW91IG1heSBub3QgcGFzcyBhIHN0eWxlLicpO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gZHVyYXRpb25JbkZyYW1lcyBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uSW5GcmFtZXN9LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHVyYXRpb25JbkZyYW1lcyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgcGFzc2VkIHRvIHRoZSBcImZyb21cIiBwcm9wcyBvZiB5b3VyIDxTZXF1ZW5jZT4gYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiBmcm9tfSwgYnV0IGl0IG11c3QgYmUgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJvbSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmcm9tXCIgcHJvcCBvZiBhIHNlcXVlbmNlIG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZnJvbX0uYCk7XG4gIH1cbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZUR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzIC0gZnJvbSwgZHVyYXRpb25JbkZyYW1lcykgOiBkdXJhdGlvbkluRnJhbWVzO1xuICBjb25zdCBhY3R1YWxEdXJhdGlvbkluRnJhbWVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyAtIGZyb20sIHBhcmVudFNlcXVlbmNlRHVyYXRpb24pKTtcbiAgY29uc3QgeyByZWdpc3RlclNlcXVlbmNlLCB1bnJlZ2lzdGVyU2VxdWVuY2UgfSA9IHVzZUNvbnRleHQxMChTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDEwKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBjb25zdCBwcmVtb3VudGluZyA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4gcGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nIHx8IEJvb2xlYW4ob3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nKTtcbiAgfSwgW290aGVyLl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZywgcGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VtdWxhdGVkRnJvbSxcbiAgICAgIHJlbGF0aXZlRnJvbTogZnJvbSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBwYXJlbnRGcm9tOiBwYXJlbnRTZXF1ZW5jZT8ucmVsYXRpdmVGcm9tID8/IDAsXG4gICAgICBpZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHBhcmVudFNlcXVlbmNlPy5oZWlnaHQgPz8gbnVsbCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyBwYXJlbnRTZXF1ZW5jZT8ud2lkdGggPz8gbnVsbCxcbiAgICAgIHByZW1vdW50aW5nXG4gICAgfTtcbiAgfSwgW1xuICAgIGN1bXVsYXRlZEZyb20sXG4gICAgZnJvbSxcbiAgICBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgIHBhcmVudFNlcXVlbmNlLFxuICAgIGlkLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBwcmVtb3VudGluZ1xuICBdKTtcbiAgY29uc3QgdGltZWxpbmVDbGlwTmFtZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4gbmFtZSA/PyBcIlwiO1xuICB9LCBbbmFtZV0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIGZyb20sXG4gICAgICBkdXJhdGlvbjogYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGlkLFxuICAgICAgZGlzcGxheU5hbWU6IHRpbWVsaW5lQ2xpcE5hbWUsXG4gICAgICBwYXJlbnQ6IHBhcmVudFNlcXVlbmNlPy5pZCA/PyBudWxsLFxuICAgICAgdHlwZTogXCJzZXF1ZW5jZVwiLFxuICAgICAgcm9vdElkLFxuICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICBub25jZSxcbiAgICAgIGxvb3BEaXNwbGF5LFxuICAgICAgc3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgICBwcmVtb3VudERpc3BsYXk6IHByZW1vdW50RGlzcGxheSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgIHRpbWVsaW5lQ2xpcE5hbWUsXG4gICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgIHBhcmVudFNlcXVlbmNlPy5pZCxcbiAgICBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgIHJvb3RJZCxcbiAgICBmcm9tLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIG5vbmNlLFxuICAgIGxvb3BEaXNwbGF5LFxuICAgIHN0YWNrLFxuICAgIHByZW1vdW50RGlzcGxheVxuICBdKTtcbiAgY29uc3QgZW5kVGhyZXNob2xkID0gTWF0aC5jZWlsKGN1bXVsYXRlZEZyb20gKyBmcm9tICsgZHVyYXRpb25JbkZyYW1lcyAtIDEpO1xuICBjb25zdCBjb250ZW50ID0gYWJzb2x1dGVGcmFtZSA8IGN1bXVsYXRlZEZyb20gKyBmcm9tID8gbnVsbCA6IGFic29sdXRlRnJhbWUgPiBlbmRUaHJlc2hvbGQgPyBudWxsIDogY2hpbGRyZW47XG4gIGNvbnN0IHN0eWxlSWZUaGVyZSA9IG90aGVyLmxheW91dCA9PT0gXCJub25lXCIgPyB1bmRlZmluZWQgOiBvdGhlci5zdHlsZTtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmbGV4RGlyZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAuLi53aWR0aCA/IHsgd2lkdGggfSA6IHt9LFxuICAgICAgLi4uaGVpZ2h0ID8geyBoZWlnaHQgfSA6IHt9LFxuICAgICAgLi4uc3R5bGVJZlRoZXJlID8/IHt9XG4gICAgfTtcbiAgfSwgW2hlaWdodCwgc3R5bGVJZlRoZXJlLCB3aWR0aF0pO1xuICBpZiAocmVmICE9PSBudWxsICYmIGxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHBhc3MgYm90aCBhIGByZWZgIGFuZCBgbGF5b3V0PVwibm9uZVwiYCB0byA8U2VxdWVuY2UgLz4uJyk7XG4gIH1cbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlbltpZF0gPz8gZmFsc2U7XG4gIGlmIChpc1NlcXVlbmNlSGlkZGVuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFNlcXVlbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IGNvbnRlbnQgPT09IG51bGwgPyBudWxsIDogb3RoZXIubGF5b3V0ID09PSBcIm5vbmVcIiA/IGNvbnRlbnQgOiAvKiBAX19QVVJFX18gKi8ganN4OChBYnNvbHV0ZUZpbGwsIHtcbiAgICAgIHJlZixcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuOiBjb250ZW50XG4gICAgfSlcbiAgfSk7XG59O1xudmFyIFJlZ3VsYXJTZXF1ZW5jZSA9IGZvcndhcmRSZWYyKFJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgUHJlbW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgaWYgKHByb3BzLmxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2A8U2VxdWVuY2U+YCB3aXRoIGBwcmVtb3VudEZvcmAgcHJvcCBkb2VzIG5vdCBzdXBwb3J0IGxheW91dD1cIm5vbmVcIicpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBzdHlsZTogcGFzc2VkU3R5bGUsXG4gICAgZnJvbSA9IDAsXG4gICAgcHJlbW91bnRGb3IgPSAwLFxuICAgIHN0eWxlV2hpbGVQcmVtb3VudGVkLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwcmVtb3VudGluZ0FjdGl2ZSA9IGZyYW1lIDwgZnJvbSAmJiBmcmFtZSA+PSBmcm9tIC0gcHJlbW91bnRGb3I7XG4gIGNvbnN0IHN0eWxlID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXNzZWRTdHlsZSxcbiAgICAgIG9wYWNpdHk6IHByZW1vdW50aW5nQWN0aXZlID8gMCA6IDEsXG4gICAgICBwb2ludGVyRXZlbnRzOiBwcmVtb3VudGluZ0FjdGl2ZSA/IFwibm9uZVwiIDogcGFzc2VkU3R5bGU/LnBvaW50ZXJFdmVudHMgPz8gdW5kZWZpbmVkLFxuICAgICAgLi4ucHJlbW91bnRpbmdBY3RpdmUgPyBzdHlsZVdoaWxlUHJlbW91bnRlZCA6IHt9XG4gICAgfTtcbiAgfSwgW3Bhc3NlZFN0eWxlLCBwcmVtb3VudGluZ0FjdGl2ZSwgc3R5bGVXaGlsZVByZW1vdW50ZWRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KEZyZWV6ZSwge1xuICAgIGZyYW1lOiBmcm9tLFxuICAgIGFjdGl2ZTogcHJlbW91bnRpbmdBY3RpdmUsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g4KFNlcXVlbmNlLCB7XG4gICAgICByZWYsXG4gICAgICBmcm9tLFxuICAgICAgc3R5bGUsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheTogcHJlbW91bnRGb3IsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmc6IHByZW1vdW50aW5nQWN0aXZlLFxuICAgICAgLi4ub3RoZXJQcm9wc1xuICAgIH0pXG4gIH0pO1xufTtcbnZhciBQcmVtb3VudGVkU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihQcmVtb3VudGVkU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgaWYgKHByb3BzLmxheW91dCAhPT0gXCJub25lXCIgJiYgcHJvcHMucHJlbW91bnRGb3IgJiYgIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChQcmVtb3VudGVkU2VxdWVuY2UsIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFJlZ3VsYXJTZXF1ZW5jZSwge1xuICAgIC4uLnByb3BzLFxuICAgIHJlZlxuICB9KTtcbn07XG52YXIgU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvQW5pbWF0ZWRJbWFnZS50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjMsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU0LFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZVJlZiBhcyB1c2VSZWYzLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTVcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jYW5jZWwtcmVuZGVyLnRzXG52YXIgaXNFcnJvckxpa2UgPSAoZXJyKSA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJzdGFja1wiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJtZXNzYWdlXCIgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGVyci5tZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGNhbmNlbFJlbmRlcihlcnIpIHtcbiAgbGV0IGVycm9yO1xuICBpZiAoaXNFcnJvckxpa2UoZXJyKSkge1xuICAgIGVycm9yID0gZXJyO1xuICAgIGlmICghZXJyb3Iuc3RhY2spIHtcbiAgICAgIGVycm9yLnN0YWNrID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpLnN0YWNrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXJyb3IgPSBFcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yID0gRXJyb3IoXCJSZW5kZXJpbmcgd2FzIGNhbmNlbGxlZFwiKTtcbiAgfVxuICB3aW5kb3cucmVtb3Rpb25fY2FuY2VsbGVkRXJyb3IgPSBlcnJvci5zdGFjaztcbiAgdGhyb3cgZXJyb3I7XG59XG5cbi8vIHNyYy9sb2cudHNcbnZhciBsb2dMZXZlbHMgPSBbXCJ0cmFjZVwiLCBcInZlcmJvc2VcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xudmFyIGdldE51bWJlckZvckxvZ0xldmVsID0gKGxldmVsKSA9PiB7XG4gIHJldHVybiBsb2dMZXZlbHMuaW5kZXhPZihsZXZlbCk7XG59O1xudmFyIGlzRXF1YWxPckJlbG93TG9nTGV2ZWwgPSAoY3VycmVudExldmVsLCBsZXZlbCkgPT4ge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9yTG9nTGV2ZWwoY3VycmVudExldmVsKSA8PSBnZXROdW1iZXJGb3JMb2dMZXZlbChsZXZlbCk7XG59O1xudmFyIExvZyA9IHtcbiAgdHJhY2U6IChsb2dMZXZlbCwgLi4uYXJncykgPT4ge1xuICAgIGlmIChpc0VxdWFsT3JCZWxvd0xvZ0xldmVsKGxvZ0xldmVsLCBcInRyYWNlXCIpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICB2ZXJib3NlOiAobG9nTGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChsb2dMZXZlbCwgXCJ2ZXJib3NlXCIpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICBpbmZvOiAobG9nTGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChsb2dMZXZlbCwgXCJpbmZvXCIpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICB3YXJuOiAobG9nTGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChsb2dMZXZlbCwgXCJ3YXJuXCIpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gIH1cbn07XG5cbi8vIHNyYy9kZWxheS1yZW5kZXIudHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xufVxudmFyIGhhbmRsZXMgPSBbXTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzID0ge307XG59XG52YXIgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTiA9IFwiVGhlIGRlbGF5UmVuZGVyIHdhcyBjYWxsZWQ6XCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCA9IFwiUmV0cmllcyBsZWZ0OiBcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gPSBcIi0gUmVuZGVyaW5nIHRoZSBmcmFtZSB3aWxsIGJlIHJldHJpZWQuXCI7XG52YXIgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOID0gXCJoYW5kbGUgd2FzIGNsZWFyZWQgYWZ0ZXJcIjtcbnZhciBkZWZhdWx0VGltZW91dCA9IDMwMDAwO1xudmFyIGRlbGF5UmVuZGVyID0gKGxhYmVsLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2YgbGFiZWwgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGxhYmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhYmVsIHBhcmFtZXRlciBvZiBkZWxheVJlbmRlcigpIG11c3QgYmUgYSBzdHJpbmcgb3IgdW5kZWZpbmVkLCBnb3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkobGFiZWwpKTtcbiAgfVxuICBjb25zdCBoYW5kbGUgPSBNYXRoLnJhbmRvbSgpO1xuICBoYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgY29uc3QgY2FsbGVkID0gRXJyb3IoKS5zdGFjaz8ucmVwbGFjZSgvXkVycm9yL2csIFwiXCIpID8/IFwiXCI7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICBjb25zdCB0aW1lb3V0VG9Vc2UgPSAob3B0aW9ucz8udGltZW91dEluTWlsbGlzZWNvbmRzID8/ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFRpbWVvdXQgOiB3aW5kb3cucmVtb3Rpb25fcHVwcGV0ZWVyVGltZW91dCA/PyBkZWZhdWx0VGltZW91dCkpIC0gMjAwMDtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3QgcmV0cmllc0xlZnQgPSAob3B0aW9ucz8ucmV0cmllcyA/PyAwKSAtICh3aW5kb3cucmVtb3Rpb25fYXR0ZW1wdCAtIDEpO1xuICAgICAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXSA9IHtcbiAgICAgICAgbGFiZWw6IGxhYmVsID8/IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIGBBIGRlbGF5UmVuZGVyKClgLFxuICAgICAgICAgICAgbGFiZWwgPyBgXCIke2xhYmVsfVwiYCA6IG51bGwsXG4gICAgICAgICAgICBgd2FzIGNhbGxlZCBidXQgbm90IGNsZWFyZWQgYWZ0ZXIgJHt0aW1lb3V0VG9Vc2V9bXMuIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3RpbWVvdXQgZm9yIGhlbHAuYCxcbiAgICAgICAgICAgIHJldHJpZXNMZWZ0ID4gMCA/IERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgKyByZXRyaWVzTGVmdCA6IG51bGwsXG4gICAgICAgICAgICByZXRyaWVzTGVmdCA+IDAgPyBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gOiBudWxsLFxuICAgICAgICAgICAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgICAgICAgICAgIGNhbGxlZFxuICAgICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgICAgY2FuY2VsUmVuZGVyKEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgfSwgdGltZW91dFRvVXNlKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufTtcbnZhciBjb250aW51ZVJlbmRlciA9IChoYW5kbGUpID0+IHtcbiAgaWYgKHR5cGVvZiBoYW5kbGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGNvbnRpbnVlUmVuZGVyKCkgbWV0aG9kIG11c3QgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgdGhhdCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkuIE5vIHZhbHVlIHdhcyBwYXNzZWQuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBwYXJhbWV0ZXIgcGFzc2VkIGludG8gY29udGludWVSZW5kZXIoKSBtdXN0IGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgZGVsYXlSZW5kZXIoKSB3aGljaCBpcyBhIG51bWJlci4gR290OiBcIiArIEpTT04uc3RyaW5naWZ5KGhhbmRsZSkpO1xuICB9XG4gIGhhbmRsZXMgPSBoYW5kbGVzLmZpbHRlcigoaCkgPT4ge1xuICAgIGlmIChoID09PSBoYW5kbGUpIHtcbiAgICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbGFiZWwsIHN0YXJ0VGltZSwgdGltZW91dCB9ID0gd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgIGxhYmVsID8gYGRlbGF5UmVuZGVyKCkgXCIke2xhYmVsfVwiYCA6IFwiQSBkZWxheVJlbmRlcigpXCIsXG4gICAgICAgICAgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOLFxuICAgICAgICAgIGAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgXG4gICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgIExvZy52ZXJib3NlKHdpbmRvdy5yZW1vdGlvbl9sb2dMZXZlbCwgbWVzc2FnZSk7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIGlmIChoYW5kbGVzLmxlbmd0aCA9PT0gMCAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2FuaW1hdGVkLWltYWdlL2NhbnZhcy50c3hcbmltcG9ydCBSZWFjdDgsIHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUzLCB1c2VSZWYgYXMgdXNlUmVmMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBjYWxjQXJncyA9IChmaXQsIGZyYW1lU2l6ZSwgY2FudmFzU2l6ZSkgPT4ge1xuICBzd2l0Y2ggKGZpdCkge1xuICAgIGNhc2UgXCJmaWxsXCI6IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgY2FudmFzU2l6ZS5oZWlnaHRcbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJjb250YWluXCI6IHtcbiAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4oY2FudmFzU2l6ZS53aWR0aCAvIGZyYW1lU2l6ZS53aWR0aCwgY2FudmFzU2l6ZS5oZWlnaHQgLyBmcmFtZVNpemUuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSAoY2FudmFzU2l6ZS53aWR0aCAtIGZyYW1lU2l6ZS53aWR0aCAqIHJhdGlvKSAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gKGNhbnZhc1NpemUuaGVpZ2h0IC0gZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvKSAvIDI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmcmFtZVNpemUud2lkdGgsXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIGNlbnRlclgsXG4gICAgICAgIGNlbnRlclksXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCAqIHJhdGlvLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0ICogcmF0aW9cbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJjb3ZlclwiOiB7XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWF4KGNhbnZhc1NpemUud2lkdGggLyBmcmFtZVNpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0IC8gZnJhbWVTaXplLmhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gKGNhbnZhc1NpemUud2lkdGggLSBmcmFtZVNpemUud2lkdGggKiByYXRpbykgLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IChjYW52YXNTaXplLmhlaWdodCAtIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpbykgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBmcmFtZVNpemUud2lkdGggKiByYXRpbyxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvXG4gICAgICBdO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmaXQ6IFwiICsgZml0KTtcbiAgfVxufTtcbnZhciBDYW52YXNSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAoeyB3aWR0aCwgaGVpZ2h0LCBmaXQsIGNsYXNzTmFtZSwgc3R5bGUgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjIobnVsbCk7XG4gIGNvbnN0IGRyYXcgPSB1c2VDYWxsYmFjazQoKGltYWdlRGF0YSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2lkdGggPz8gaW1hZ2VEYXRhLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBoZWlnaHQgPz8gaW1hZ2VEYXRhLmRpc3BsYXlIZWlnaHQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWYgaXMgbm90IHNldFwiKTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gY2FudmFzUmVmLmN1cnJlbnQ/LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCAyZCBjb250ZXh0XCIpO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2VEYXRhLCAuLi5jYWxjQXJncyhmaXQsIHtcbiAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmRpc3BsYXlIZWlnaHQsXG4gICAgICB3aWR0aDogaW1hZ2VEYXRhLmRpc3BsYXlXaWR0aFxuICAgIH0sIHtcbiAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XG4gICAgfSkpO1xuICB9LCBbZml0LCBoZWlnaHQsIHdpZHRoXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUzKHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkcmF3LFxuICAgICAgZ2V0Q2FudmFzOiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmIGlzIG5vdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50Py5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCAyZCBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzUmVmLmN1cnJlbnQud2lkdGgsIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2RyYXddKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g5KFwiY2FudmFzXCIsIHtcbiAgICByZWY6IGNhbnZhc1JlZixcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGVcbiAgfSk7XG59O1xudmFyIENhbnZhcyA9IFJlYWN0OC5mb3J3YXJkUmVmKENhbnZhc1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9kZWNvZGUtaW1hZ2UudHNcbnZhciBDQUNIRV9TSVpFID0gNTtcbnZhciBnZXRBY3R1YWxUaW1lID0gKHtcbiAgbG9vcEJlaGF2aW9yLFxuICBkdXJhdGlvbkZvdW5kLFxuICB0aW1lSW5TZWNcbn0pID0+IHtcbiAgcmV0dXJuIGxvb3BCZWhhdmlvciA9PT0gXCJsb29wXCIgPyBkdXJhdGlvbkZvdW5kID8gdGltZUluU2VjICUgZHVyYXRpb25Gb3VuZCA6IHRpbWVJblNlYyA6IE1hdGgubWluKHRpbWVJblNlYywgZHVyYXRpb25Gb3VuZCB8fCBJbmZpbml0eSk7XG59O1xudmFyIGRlY29kZUltYWdlID0gYXN5bmMgKHtcbiAgcmVzb2x2ZWRTcmMsXG4gIHNpZ25hbCxcbiAgY3VycmVudFRpbWUsXG4gIGluaXRpYWxMb29wQmVoYXZpb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBJbWFnZURlY29kZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgV2ViQ29kZWNzIEltYWdlRGVjb2RlciBBUEkuXCIpO1xuICB9XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHJlc29sdmVkU3JjLCB7IHNpZ25hbCB9KTtcbiAgY29uc3QgeyBib2R5IH0gPSByZXM7XG4gIGlmICghYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBubyBib2R5XCIpO1xuICB9XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgSW1hZ2VEZWNvZGVyKHtcbiAgICBkYXRhOiBib2R5LFxuICAgIHR5cGU6IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSB8fCBcImltYWdlL2dpZlwiXG4gIH0pO1xuICBhd2FpdCBkZWNvZGVyLmNvbXBsZXRlZDtcbiAgY29uc3QgeyBzZWxlY3RlZFRyYWNrIH0gPSBkZWNvZGVyLnRyYWNrcztcbiAgaWYgKCFzZWxlY3RlZFRyYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2VsZWN0ZWQgdHJhY2tcIik7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgbGV0IGR1cmF0aW9uRm91bmQgPSBudWxsO1xuICBjb25zdCBnZXRGcmFtZUJ5SW5kZXggPSBhc3luYyAoZnJhbWVJbmRleCkgPT4ge1xuICAgIGNvbnN0IGZvdW5kSW5DYWNoZSA9IGNhY2hlLmZpbmQoKGMpID0+IGMuZnJhbWVJbmRleCA9PT0gZnJhbWVJbmRleCk7XG4gICAgaWYgKGZvdW5kSW5DYWNoZSAmJiBmb3VuZEluQ2FjaGUuZnJhbWUpIHtcbiAgICAgIHJldHVybiBmb3VuZEluQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoe1xuICAgICAgZnJhbWVJbmRleCxcbiAgICAgIGNvbXBsZXRlRnJhbWVzT25seTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChmb3VuZEluQ2FjaGUpIHtcbiAgICAgIGZvdW5kSW5DYWNoZS5mcmFtZSA9IGZyYW1lLmltYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKHtcbiAgICAgICAgZnJhbWU6IGZyYW1lLmltYWdlLFxuICAgICAgICBmcmFtZUluZGV4LFxuICAgICAgICB0aW1lSW5TZWNvbmRzOiBmcmFtZS5pbWFnZS50aW1lc3RhbXAgLyAxZTZcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZnJhbWU6IGZyYW1lLmltYWdlLFxuICAgICAgZnJhbWVJbmRleCxcbiAgICAgIHRpbWVJblNlY29uZHM6IGZyYW1lLmltYWdlLnRpbWVzdGFtcCAvIDFlNlxuICAgIH07XG4gIH07XG4gIGNvbnN0IGNsZWFyQ2FjaGUgPSAoY2xvc2VUb1RpbWVJblNlYykgPT4ge1xuICAgIGNvbnN0IGl0ZW1zSW5DYWNoZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy5mcmFtZSk7XG4gICAgY29uc3Qgc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUgPSBpdGVtc0luQ2FjaGUuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyhhLnRpbWVJblNlY29uZHMgLSBjbG9zZVRvVGltZUluU2VjKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoYi50aW1lSW5TZWNvbmRzIC0gY2xvc2VUb1RpbWVJblNlYyk7XG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDtpIDwgc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpIDwgQ0FDSEVfU0laRSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW0gPSBzb3J0QnlDbG9zZXN0VG9DdXJyZW50VGltZVtpXTtcbiAgICAgIGl0ZW0uZnJhbWUgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlciA9IGFzeW5jICh7XG4gICAgdGltZUluU2VjLFxuICAgIGxvb3BCZWhhdmlvclxuICB9KSA9PiB7XG4gICAgY29uc3QgYWN0dWFsVGltZUluU2VjID0gZ2V0QWN0dWFsVGltZSh7XG4gICAgICBkdXJhdGlvbkZvdW5kLFxuICAgICAgbG9vcEJlaGF2aW9yLFxuICAgICAgdGltZUluU2VjXG4gICAgfSk7XG4gICAgY29uc3QgZnJhbWVzQmVmb3JlID0gY2FjaGUuZmlsdGVyKChjKSA9PiBjLnRpbWVJblNlY29uZHMgPD0gYWN0dWFsVGltZUluU2VjKTtcbiAgICBjb25zdCBiaWdnZXN0SW5kZXggPSBmcmFtZXNCZWZvcmUubWFwKChjKSA9PiBjLmZyYW1lSW5kZXgpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYiksIDApO1xuICAgIGxldCBpID0gYmlnZ2VzdEluZGV4O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmID0gYXdhaXQgZ2V0RnJhbWVCeUluZGV4KGkpO1xuICAgICAgaSsrO1xuICAgICAgaWYgKCFmLmZyYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFmLmZyYW1lLmR1cmF0aW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCAmJiBkdXJhdGlvbkZvdW5kID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gKGYuZnJhbWUudGltZXN0YW1wICsgZi5mcmFtZS5kdXJhdGlvbikgLyAxZTY7XG4gICAgICAgIGR1cmF0aW9uRm91bmQgPSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChmLnRpbWVJblNlY29uZHMgPiBhY3R1YWxUaW1lSW5TZWMgfHwgaSA9PT0gc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50IC0gYmlnZ2VzdEluZGV4IDwgMyAmJiBsb29wQmVoYXZpb3IgPT09IFwibG9vcFwiKSB7XG4gICAgICBhd2FpdCBnZXRGcmFtZUJ5SW5kZXgoMCk7XG4gICAgfVxuICAgIGNsZWFyQ2FjaGUoYWN0dWFsVGltZUluU2VjKTtcbiAgfTtcbiAgYXdhaXQgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlcih7XG4gICAgdGltZUluU2VjOiBjdXJyZW50VGltZSxcbiAgICBsb29wQmVoYXZpb3I6IGluaXRpYWxMb29wQmVoYXZpb3JcbiAgfSk7XG4gIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoe1xuICAgIHRpbWVJblNlYzogY3VycmVudFRpbWUsXG4gICAgbG9vcEJlaGF2aW9yOiBpbml0aWFsTG9vcEJlaGF2aW9yXG4gIH0pO1xuICBjb25zdCBnZXRGcmFtZSA9IGFzeW5jICh0aW1lSW5TZWMsIGxvb3BCZWhhdmlvcikgPT4ge1xuICAgIGlmIChkdXJhdGlvbkZvdW5kICE9PSBudWxsICYmIHRpbWVJblNlYyA+IGR1cmF0aW9uRm91bmQgJiYgbG9vcEJlaGF2aW9yID09PSBcImNsZWFyLWFmdGVyLWZpbmlzaFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsVGltZUluU2VjID0gZ2V0QWN0dWFsVGltZSh7XG4gICAgICBsb29wQmVoYXZpb3IsXG4gICAgICBkdXJhdGlvbkZvdW5kLFxuICAgICAgdGltZUluU2VjXG4gICAgfSk7XG4gICAgYXdhaXQgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlcih7IHRpbWVJblNlYzogYWN0dWFsVGltZUluU2VjLCBsb29wQmVoYXZpb3IgfSk7XG4gICAgY29uc3QgaXRlbXNJbkNhY2hlID0gY2FjaGUuZmlsdGVyKChjKSA9PiBjLmZyYW1lKTtcbiAgICBjb25zdCBjbG9zZXN0ID0gaXRlbXNJbkNhY2hlLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyhhLnRpbWVJblNlY29uZHMgLSBhY3R1YWxUaW1lSW5TZWMpO1xuICAgICAgY29uc3QgYkRpZmYgPSBNYXRoLmFicyhiLnRpbWVJblNlY29uZHMgLSBhY3R1YWxUaW1lSW5TZWMpO1xuICAgICAgcmV0dXJuIGFEaWZmIDwgYkRpZmYgPyBhIDogYjtcbiAgICB9KTtcbiAgICBpZiAoIWNsb3Nlc3QuZnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRGcmFtZSxcbiAgICBmcmFtZUNvdW50OiBzZWxlY3RlZFRyYWNrLmZyYW1lQ291bnRcbiAgfTtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9yZXNvbHZlLWltYWdlLXNvdXJjZS50c3hcbnZhciByZXNvbHZlQW5pbWF0ZWRJbWFnZVNvdXJjZSA9IChzcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9BbmltYXRlZEltYWdlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDEwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQW5pbWF0ZWRJbWFnZSA9IGZvcndhcmRSZWYzKCh7XG4gIHNyYyxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgb25FcnJvcixcbiAgbG9vcEJlaGF2aW9yID0gXCJsb29wXCIsXG4gIHBsYXliYWNrUmF0ZSA9IDEsXG4gIGZpdCA9IFwiZmlsbFwiLFxuICAuLi5wcm9wc1xufSwgY2FudmFzUmVmKSA9PiB7XG4gIGNvbnN0IG1vdW50U3RhdGUgPSB1c2VSZWYzKHsgaXNNb3VudGVkOiB0cnVlIH0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IG1vdW50U3RhdGU7XG4gICAgY3VycmVudC5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzb2x2ZWRTcmMgPSByZXNvbHZlQW5pbWF0ZWRJbWFnZVNvdXJjZShzcmMpO1xuICBjb25zdCBbaW1hZ2VEZWNvZGVyLCBzZXRJbWFnZURlY29kZXJdID0gdXNlU3RhdGU1KG51bGwpO1xuICBjb25zdCBbZGVjb2RlSGFuZGxlXSA9IHVzZVN0YXRlNSgoKSA9PiBkZWxheVJlbmRlcihgUmVuZGVyaW5nIDxBbmltYXRlZEltYWdlLz4gd2l0aCBzcmM9XCIke3Jlc29sdmVkU3JjfVwiYCkpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBmcmFtZSAvIHBsYXliYWNrUmF0ZSAvIGZwcztcbiAgY29uc3QgY3VycmVudFRpbWVSZWYgPSB1c2VSZWYzKGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRpbWVSZWYuY3VycmVudCA9IGN1cnJlbnRUaW1lO1xuICBjb25zdCByZWYgPSB1c2VSZWYzKG51bGwpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNChjYW52YXNSZWYsICgpID0+IHtcbiAgICBjb25zdCBjID0gcmVmLmN1cnJlbnQ/LmdldENhbnZhcygpO1xuICAgIGlmICghYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZiBpcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSwgW10pO1xuICBjb25zdCBbaW5pdGlhbExvb3BCZWhhdmlvcl0gPSB1c2VTdGF0ZTUoKCkgPT4gbG9vcEJlaGF2aW9yKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgZGVjb2RlSW1hZ2Uoe1xuICAgICAgcmVzb2x2ZWRTcmMsXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgY3VycmVudFRpbWU6IGN1cnJlbnRUaW1lUmVmLmN1cnJlbnQsXG4gICAgICBpbml0aWFsTG9vcEJlaGF2aW9yXG4gICAgfSkudGhlbigoZCkgPT4ge1xuICAgICAgc2V0SW1hZ2VEZWNvZGVyKGQpO1xuICAgICAgY29udGludWVSZW5kZXIoZGVjb2RlSGFuZGxlKTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKGRlY29kZUhhbmRsZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3I/LihlcnIpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihkZWNvZGVIYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuY2VsUmVuZGVyKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9O1xuICB9LCBbcmVzb2x2ZWRTcmMsIGRlY29kZUhhbmRsZSwgb25FcnJvciwgaW5pdGlhbExvb3BCZWhhdmlvcl0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW1hZ2VEZWNvZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gZGVsYXlSZW5kZXIoYFJlbmRlcmluZyBmcmFtZSBhdCAke2N1cnJlbnRUaW1lfSBvZiA8QW5pbWF0ZWRJbWFnZSBzcmM9XCIke3NyY31cIi8+YCk7XG4gICAgaW1hZ2VEZWNvZGVyLmdldEZyYW1lKGN1cnJlbnRUaW1lLCBsb29wQmVoYXZpb3IpLnRoZW4oKHZpZGVvRnJhbWUpID0+IHtcbiAgICAgIGlmIChtb3VudFN0YXRlLmN1cnJlbnQuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmICh2aWRlb0ZyYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQ/LmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQ/LmRyYXcodmlkZW9GcmFtZS5mcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlUmVuZGVyKGRlbGF5KTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbY3VycmVudFRpbWUsIGltYWdlRGVjb2RlciwgbG9vcEJlaGF2aW9yLCBvbkVycm9yLCBzcmNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMChDYW52YXMsIHtcbiAgICByZWYsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZpdCxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn0pO1xuLy8gc3JjL0FydGlmYWN0LnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTEsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q1LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL1JlbmRlckFzc2V0TWFuYWdlci50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEwLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazUsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QyLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8xMCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU2XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1hcnRpZmFjdC50c1xudmFyIHZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZSA9IChmaWxlbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIGZpbGVuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZmlsZW5hbWVcIiBtdXN0IGJlIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZmlsZW5hbWV9YCk7XG4gIH1cbiAgaWYgKGZpbGVuYW1lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZmlsZW5hbWVgIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG4gIGlmICghZmlsZW5hbWUubWF0Y2goL14oWzAtOWEtekEtWi0hXy4qJygpLzomJEA9OyssP10rKS9nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBmaWxlbmFtZWAgbXVzdCBtYXRjaCBcIi9eKFswLTlhLXpBLVotIV8uKlxcJygpLzomJEA9OyssP10rKS9nXCIuIFVzZSBmb3J3YXJkIHNsYXNoZXMgb25seSwgZXZlbiBvbiBXaW5kb3dzLicpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQ29udGVudCA9IChjb250ZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIiAmJiAhKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImNvbnRlbnRcIiBtdXN0IGJlIGEgc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBjb250ZW50fWApO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBjb250ZW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgY29udGVudGAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVSZW5kZXJBc3NldCA9IChhcnRpZmFjdCkgPT4ge1xuICBpZiAoYXJ0aWZhY3QudHlwZSAhPT0gXCJhcnRpZmFjdFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZShhcnRpZmFjdC5maWxlbmFtZSk7XG4gIGlmIChhcnRpZmFjdC5jb250ZW50VHlwZSA9PT0gXCJ0aHVtYm5haWxcIikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YWxpZGF0ZUNvbnRlbnQoYXJ0aWZhY3QuY29udGVudCk7XG59O1xuXG4vLyBzcmMvUmVuZGVyQXNzZXRNYW5hZ2VyLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDExIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVuZGVyQXNzZXRNYW5hZ2VyID0gY3JlYXRlQ29udGV4dDEwKHtcbiAgcmVnaXN0ZXJSZW5kZXJBc3NldDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdW5yZWdpc3RlclJlbmRlckFzc2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICByZW5kZXJBc3NldHM6IFtdXG59KTtcbnZhciBSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3JlbmRlckFzc2V0cywgc2V0UmVuZGVyQXNzZXRzXSA9IHVzZVN0YXRlNihbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUmVuZGVyQXNzZXQgPSB1c2VDYWxsYmFjazUoKHJlbmRlckFzc2V0KSA9PiB7XG4gICAgdmFsaWRhdGVSZW5kZXJBc3NldChyZW5kZXJBc3NldCk7XG4gICAgc2V0UmVuZGVyQXNzZXRzKChhc3NldHMpID0+IHtcbiAgICAgIHJldHVybiBbLi4uYXNzZXRzLCByZW5kZXJBc3NldF07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlclJlbmRlckFzc2V0ID0gdXNlQ2FsbGJhY2s1KChpZCkgPT4ge1xuICAgIHNldFJlbmRlckFzc2V0cygoYXNzdHMpID0+IHtcbiAgICAgIHJldHVybiBhc3N0cy5maWx0ZXIoKGEpID0+IGEuaWQgIT09IGlkKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB1c2VMYXlvdXRFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LnJlbW90aW9uX2NvbGxlY3RBc3NldHMgPSAoKSA9PiB7XG4gICAgICAgIHNldFJlbmRlckFzc2V0cyhbXSk7XG4gICAgICAgIHJldHVybiByZW5kZXJBc3NldHM7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlbmRlckFzc2V0c10pO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgICAgcmVuZGVyQXNzZXRzXG4gICAgfTtcbiAgfSwgW3JlbmRlckFzc2V0cywgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTEoUmVuZGVyQXNzZXRNYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9BcnRpZmFjdC50c3hcbnZhciBBcnRpZmFjdFRodW1ibmFpbCA9IFN5bWJvbChcIlRodW1ibmFpbFwiKTtcbnZhciBBcnRpZmFjdCA9ICh7IGZpbGVuYW1lLCBjb250ZW50IH0pID0+IHtcbiAgY29uc3QgeyByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgfSA9IHVzZUNvbnRleHQxMShSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBjb25zdCBbZW52XSA9IHVzZVN0YXRlNygoKSA9PiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBbaWRdID0gdXNlU3RhdGU3KCgpID0+IHtcbiAgICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICB9KTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKCFlbnYuaXNSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgY29udGVudDogYnRvYShuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShjb250ZW50KSksXG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBmcmFtZSxcbiAgICAgICAgY29udGVudFR5cGU6IFwiYmluYXJ5XCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCA9PT0gQXJ0aWZhY3RUaHVtYm5haWwpIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRodW1ibmFpbFwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgIHR5cGU6IFwiYXJ0aWZhY3RcIixcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBmcmFtZSxcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBjb250ZW50LFxuICAgIGVudi5pc1JlbmRlcmluZyxcbiAgICBmaWxlbmFtZSxcbiAgICBmcmFtZSxcbiAgICBpZCxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldFxuICBdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuQXJ0aWZhY3QuVGh1bWJuYWlsID0gQXJ0aWZhY3RUaHVtYm5haWw7XG4vLyBzcmMvYXVkaW8vQXVkaW8udHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY2LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazExLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYWJzb2x1dGUtc3JjLnRzXG52YXIgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwocmVsYXRpdmVTcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvY2FsY3VsYXRlLWxvb3AudHNcbnZhciBjYWxjdWxhdGVMb29wRHVyYXRpb24gPSAoe1xuICBlbmRBdCxcbiAgbWVkaWFEdXJhdGlvbixcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgbGV0IGR1cmF0aW9uID0gbWVkaWFEdXJhdGlvbjtcbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGR1cmF0aW9uID0gZW5kQXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiAtPSBzdGFydEZyb207XG4gIH1cbiAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSBkdXJhdGlvbiAvIHBsYXliYWNrUmF0ZTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYWN0dWFsRHVyYXRpb24pO1xufTtcblxuLy8gc3JjL2xvb3AvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3Q5LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDExLCB1c2VNZW1vIGFzIHVzZU1lbW8xMSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDEyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTG9vcENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTEobnVsbCk7XG52YXIgdXNlTG9vcCA9ICgpID0+IHtcbiAgcmV0dXJuIFJlYWN0OS51c2VDb250ZXh0KExvb3BDb250ZXh0KTtcbn07XG52YXIgTG9vcCA9ICh7IGR1cmF0aW9uSW5GcmFtZXMsIHRpbWVzID0gSW5maW5pdHksIGNoaWxkcmVuLCBuYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBEdXJhdGlvbiB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBjb21wb25lbnQ6IFwib2YgdGhlIDxMb29wIC8+IGNvbXBvbmVudFwiLFxuICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gIH0pO1xuICBpZiAodHlwZW9mIHRpbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBcInRpbWVzXCIgYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiB0aW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICh0aW1lcyAhPT0gSW5maW5pdHkgJiYgdGltZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGltZXNcIiBwcm9wIG9mIGEgbG9vcCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHt0aW1lc30uYCk7XG4gIH1cbiAgaWYgKHRpbWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7dGltZXN9YCk7XG4gIH1cbiAgY29uc3QgbWF4VGltZXMgPSBNYXRoLmNlaWwoY29tcER1cmF0aW9uIC8gZHVyYXRpb25JbkZyYW1lcyk7XG4gIGNvbnN0IGFjdHVhbFRpbWVzID0gTWF0aC5taW4obWF4VGltZXMsIHRpbWVzKTtcbiAgY29uc3Qgc3R5bGUgPSBwcm9wcy5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogcHJvcHMuc3R5bGU7XG4gIGNvbnN0IG1heEZyYW1lID0gZHVyYXRpb25JbkZyYW1lcyAqIChhY3R1YWxUaW1lcyAtIDEpO1xuICBjb25zdCBpdGVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICBjb25zdCBzdGFydCA9IGl0ZXJhdGlvbiAqIGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGZyb20gPSBNYXRoLm1pbihzdGFydCwgbWF4RnJhbWUpO1xuICBjb25zdCBsb29wRGlzcGxheSA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mVGltZXM6IGFjdHVhbFRpbWVzLFxuICAgICAgc3RhcnRPZmZzZXQ6IC1mcm9tLFxuICAgICAgZHVyYXRpb25JbkZyYW1lc1xuICAgIH07XG4gIH0sIFthY3R1YWxUaW1lcywgZHVyYXRpb25JbkZyYW1lcywgZnJvbV0pO1xuICBjb25zdCBsb29wQ29udGV4dCA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZXJhdGlvbjogTWF0aC5mbG9vcihjdXJyZW50RnJhbWUgLyBkdXJhdGlvbkluRnJhbWVzKSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXNcbiAgICB9O1xuICB9LCBbY3VycmVudEZyYW1lLCBkdXJhdGlvbkluRnJhbWVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTIoTG9vcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9vcENvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxMihTZXF1ZW5jZSwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGZyb20sXG4gICAgICBuYW1lOiBuYW1lID8/IFwiPExvb3A+XCIsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgICAgIGxheW91dDogcHJvcHMubGF5b3V0LFxuICAgICAgc3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcbkxvb3AudXNlTG9vcCA9IHVzZUxvb3A7XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3BsYXliYWNrLWxvZ2dpbmcudHNcbnZhciBwbGF5YmFja0xvZ2dpbmcgPSAoe1xuICBsb2dMZXZlbCxcbiAgdGFnLFxuICBtZXNzYWdlLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGFncyA9IFttb3VudFRpbWUgPyBEYXRlLm5vdygpIC0gbW91bnRUaW1lICsgXCJtcyBcIiA6IG51bGwsIHRhZ10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICBMb2cudHJhY2UobG9nTGV2ZWwsIGBbJHt0YWdzfV1gLCBtZXNzYWdlKTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEyLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NiwgdXNlU3RhdGUgYXMgdXNlU3RhdGU4IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBQcmVsb2FkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxMih7fSk7XG52YXIgcHJlbG9hZHMgPSB7fTtcbnZhciB1cGRhdGVycyA9IFtdO1xudmFyIHNldFByZWxvYWRzID0gKHVwZGF0ZXIpID0+IHtcbiAgcHJlbG9hZHMgPSB1cGRhdGVyKHByZWxvYWRzKTtcbiAgdXBkYXRlcnMuZm9yRWFjaCgodSkgPT4gdSgpKTtcbn07XG52YXIgUHJlZmV0Y2hQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW19wcmVsb2FkcywgX3NldFByZWxvYWRzXSA9IHVzZVN0YXRlOCgoKSA9PiBwcmVsb2Fkcyk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZXJGdW5jdGlvbiA9ICgpID0+IHtcbiAgICAgIF9zZXRQcmVsb2FkcyhwcmVsb2Fkcyk7XG4gICAgfTtcbiAgICB1cGRhdGVycy5wdXNoKHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVwZGF0ZXJzID0gdXBkYXRlcnMuZmlsdGVyKCh1KSA9PiB1ICE9PSB1cGRhdGVyRnVuY3Rpb24pO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMyhQcmVsb2FkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBfcHJlbG9hZHMsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvcHJlZmV0Y2gudHNcbnZhciByZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQgPSAoc3JjKSA9PiB7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHNyYy5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGhhc2hJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFzaEluZGV4O1xufTtcbnZhciBnZXRTcmNXaXRob3V0SGFzaCA9IChzcmMpID0+IHtcbiAgY29uc3QgaGFzaEluZGV4ID0gcmVtb3ZlQW5kR2V0SGFzaEZyYWdtZW50KHNyYyk7XG4gIGlmIChoYXNoSW5kZXggPT09IG51bGwpIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIHJldHVybiBzcmMuc2xpY2UoMCwgaGFzaEluZGV4KTtcbn07XG52YXIgdXNlUHJlbG9hZCA9IChzcmMpID0+IHtcbiAgY29uc3QgcHJlbG9hZHMyID0gdXNlQ29udGV4dDEyKFByZWxvYWRDb250ZXh0KTtcbiAgY29uc3QgaGFzaEZyYWdtZW50SW5kZXggPSByZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQoc3JjKTtcbiAgY29uc3Qgd2l0aG91dEhhc2hGcmFnbWVudCA9IGdldFNyY1dpdGhvdXRIYXNoKHNyYyk7XG4gIGlmICghcHJlbG9hZHMyW3dpdGhvdXRIYXNoRnJhZ21lbnRdKSB7XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICBpZiAoaGFzaEZyYWdtZW50SW5kZXggIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJlbG9hZHMyW3dpdGhvdXRIYXNoRnJhZ21lbnRdICsgc3JjLnNsaWNlKGhhc2hGcmFnbWVudEluZGV4KTtcbiAgfVxuICByZXR1cm4gcHJlbG9hZHMyW3dpdGhvdXRIYXNoRnJhZ21lbnRdO1xufTtcbnZhciBibG9iVG9CYXNlNjQgPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSByZWFkZXIucmVzdWx0O1xuICAgICAgcmVzb2x2ZShkYXRhVXJsKTtcbiAgICB9O1xuICAgIHJlYWRlci5vbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIH0pO1xufTtcbnZhciBnZXRCbG9iRnJvbVJlYWRlciA9IGFzeW5jICh7XG4gIHJlYWRlcixcbiAgY29udGVudFR5cGUsXG4gIGNvbnRlbnRMZW5ndGgsXG4gIG9uUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgbGV0IHJlY2VpdmVkTGVuZ3RoID0gMDtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICByZWNlaXZlZExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgIG9uUHJvZ3Jlc3MoeyBsb2FkZWRCeXRlczogcmVjZWl2ZWRMZW5ndGgsIHRvdGFsQnl0ZXM6IGNvbnRlbnRMZW5ndGggfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNodW5rc0FsbCA9IG5ldyBVaW50OEFycmF5KHJlY2VpdmVkTGVuZ3RoKTtcbiAgbGV0IHBvc2l0aW9uID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjaHVua3NBbGwuc2V0KGNodW5rLCBwb3NpdGlvbik7XG4gICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiBuZXcgQmxvYihbY2h1bmtzQWxsXSwge1xuICAgIHR5cGU6IGNvbnRlbnRUeXBlID8/IHVuZGVmaW5lZFxuICB9KTtcbn07XG52YXIgcHJlZmV0Y2ggPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/Lm1ldGhvZCA/PyBcImJsb2ItdXJsXCI7XG4gIGNvbnN0IGxvZ0xldmVsID0gb3B0aW9ucz8ubG9nTGV2ZWwgPz8gXCJpbmZvXCI7XG4gIGNvbnN0IHNyY1dpdGhvdXRIYXNoID0gZ2V0U3JjV2l0aG91dEhhc2goc3JjKTtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBmcmVlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICB3YWl0VW50aWxEb25lOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3JjV2l0aG91dEhhc2gpXG4gICAgfTtcbiAgfVxuICBMb2cudmVyYm9zZShsb2dMZXZlbCwgYFtwcmVmZXRjaF0gU3RhcnRpbmcgcHJlZmV0Y2ggJHtzcmNXaXRob3V0SGFzaH1gKTtcbiAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gIGxldCBvYmplY3RVcmwgPSBudWxsO1xuICBsZXQgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGxldCByZWplY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBjb25zdCB3YWl0VW50aWxEb25lID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgbGV0IGNhbkJlQWJvcnRlZCA9IHRydWU7XG4gIGZldGNoKHNyY1dpdGhvdXRIYXNoLCB7XG4gICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICBjcmVkZW50aWFsczogb3B0aW9ucz8uY3JlZGVudGlhbHMgPz8gdW5kZWZpbmVkXG4gIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgIGNhbkJlQWJvcnRlZCA9IGZhbHNlO1xuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IsIHN0YXR1cyA9ICR7cmVzLnN0YXR1c31gKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyQ29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBvcHRpb25zPy5jb250ZW50VHlwZSA/PyBoZWFkZXJDb250ZW50VHlwZTtcbiAgICBjb25zdCBoYXNQcm9wZXJDb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlICYmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKFwidmlkZW8vXCIpIHx8IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJhdWRpby9cIikgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImltYWdlL1wiKSk7XG4gICAgaWYgKCFoYXNQcm9wZXJDb250ZW50VHlwZSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYWxsZWQgcHJlZmV0Y2goKSBvbiAke3NyY1dpdGhvdXRIYXNofSB3aGljaCByZXR1cm5lZCBhIFwiQ29udGVudC1UeXBlXCIgb2YgJHtoZWFkZXJDb250ZW50VHlwZX0uIFByZWZldGNoZWQgY29udGVudCBzaG91bGQgaGF2ZSBhIHByb3BlciBjb250ZW50IHR5cGUgKHZpZGVvLy4uLiBvciBhdWRpby8uLi4pIG9yIGEgY29udGVudFR5cGUgcGFzc2VkIHRoZSBvcHRpb25zIG9mIHByZWZldGNoKCkuIE90aGVyd2lzZSwgcHJlZmV0Y2hpbmcgd2lsbCBub3Qgd29yayBwcm9wZXJseSBpbiBhbGwgYnJvd3NlcnMuYCk7XG4gICAgfVxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCByZXNwb25zZSBvZiAke3NyY1dpdGhvdXRIYXNofSBoYXMgbm8gYm9keWApO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4gZ2V0QmxvYkZyb21SZWFkZXIoe1xuICAgICAgcmVhZGVyLFxuICAgICAgY29udGVudFR5cGU6IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8/IGhlYWRlckNvbnRlbnRUeXBlID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSA/IHBhcnNlSW50KHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCkgOiBudWxsLFxuICAgICAgb25Qcm9ncmVzczogb3B0aW9ucz8ub25Qcm9ncmVzc1xuICAgIH0pO1xuICB9KS50aGVuKChidWYpID0+IHtcbiAgICBpZiAoIWJ1Zikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3R1YWxCbG9iID0gb3B0aW9ucz8uY29udGVudFR5cGUgPyBuZXcgQmxvYihbYnVmXSwgeyB0eXBlOiBvcHRpb25zLmNvbnRlbnRUeXBlIH0pIDogYnVmO1xuICAgIGlmIChtZXRob2QgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgIHJldHVybiBibG9iVG9CYXNlNjQoYWN0dWFsQmxvYik7XG4gICAgfVxuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGFjdHVhbEJsb2IpO1xuICB9KS50aGVuKCh1cmwpID0+IHtcbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgIGxvZ0xldmVsLFxuICAgICAgdGFnOiBcInByZWZldGNoXCIsXG4gICAgICBtZXNzYWdlOiBgRmluaXNoZWQgcHJlZmV0Y2ggJHtzcmNXaXRob3V0SGFzaH0gd2l0aCBtZXRob2QgJHttZXRob2R9YCxcbiAgICAgIG1vdW50VGltZTogbnVsbFxuICAgIH0pO1xuICAgIG9iamVjdFVybCA9IHVybDtcbiAgICBzZXRQcmVsb2FkcygocCkgPT4gKHtcbiAgICAgIC4uLnAsXG4gICAgICBbc3JjV2l0aG91dEhhc2hdOiBvYmplY3RVcmxcbiAgICB9KSk7XG4gICAgcmVzb2x2ZShvYmplY3RVcmwpO1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKGVycj8ubWVzc2FnZS5pbmNsdWRlcyhcImZyZWUoKSBjYWxsZWRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVqZWN0KGVycik7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGZyZWU6ICgpID0+IHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB0YWc6IFwicHJlZmV0Y2hcIixcbiAgICAgICAgbWVzc2FnZTogYEZyZWVpbmcgJHtzcmNXaXRob3V0SGFzaH1gLFxuICAgICAgICBtb3VudFRpbWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImJsb2ItdXJsXCIpIHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJlbG9hZHMoKHApID0+IHtcbiAgICAgICAgICBjb25zdCBjb3B5ID0geyAuLi5wIH07XG4gICAgICAgICAgZGVsZXRlIGNvcHlbc3JjV2l0aG91dEhhc2hdO1xuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbkJlQWJvcnRlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImZyZWUoKSBjYWxsZWRcIikpO1xuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgd2FpdFVudGlsRG9uZTogKCkgPT4ge1xuICAgICAgcmV0dXJuIHdhaXRVbnRpbERvbmU7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZhbGlkYXRlLW1lZGlhLXByb3BzLnRzXG52YXIgdmFsaWRhdGVNZWRpYVByb3BzID0gKHByb3BzLCBjb21wb25lbnQpID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSB2b2x1bWUgb2YgdHlwZSAke3R5cGVvZiBwcm9wcy52b2x1bWV9IHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFZvbHVtZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2lnbmF0dXJlICcoZnJhbWU6IG51bWJlcikgPT4gbnVtYmVyJyB1bmRlZmluZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy52b2x1bWUgPT09IFwibnVtYmVyXCIgJiYgcHJvcHMudm9sdW1lIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHZvbHVtZSBiZWxvdyAwIHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFZvbHVtZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMWApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSBwbGF5YmFja1JhdGUgb2YgdHlwZSAke3R5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGV9IHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFBsYXliYWNrIHJhdGUgbXVzdCBhIHJlYWwgbnVtYmVyIG9yIHVuZGVmaW5lZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSA9PT0gXCJudW1iZXJcIiAmJiAoaXNOYU4ocHJvcHMucGxheWJhY2tSYXRlKSB8fCAhTnVtYmVyLmlzRmluaXRlKHByb3BzLnBsYXliYWNrUmF0ZSkgfHwgcHJvcHMucGxheWJhY2tSYXRlIDw9IDApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgcGxheWJhY2tSYXRlIG9mICR7cHJvcHMucGxheWJhY2tSYXRlfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBQbGF5YmFjayByYXRlIG11c3QgYmUgYSByZWFsIG51bWJlciBhYm92ZSAwLmApO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdGUtc3RhcnQtZnJvbS1wcm9wcy50c1xudmFyIHZhbGlkYXRlU3RhcnRGcm9tUHJvcHMgPSAoc3RhcnRGcm9tLCBlbmRBdCkgPT4ge1xuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIHN0YXJ0RnJvbSBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2Ygc3RhcnRGcm9tfS5gKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHN0YXJ0RnJvbSkgfHwgc3RhcnRGcm9tID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInN0YXJ0RnJvbSBwcm9wIGNhbiBub3QgYmUgTmFOIG9yIEluZmluaXR5LlwiKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0RnJvbSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXJ0RnJvbSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBlcXVhbCB0byAwIGluc3RlYWQgZ290ICR7c3RhcnRGcm9tfS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2YgZW5kQXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2YgZW5kQXQgcHJvcCBtdXN0IGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCB0eXBlICR7dHlwZW9mIGVuZEF0fS5gKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGVuZEF0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuZEF0IHByb3AgY2FuIG5vdCBiZSBOYU4uXCIpO1xuICAgIH1cbiAgICBpZiAoZW5kQXQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZW5kQXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciwgaW5zdGVhZCBnb3QgJHtlbmRBdH0uYCk7XG4gICAgfVxuICB9XG4gIGlmIChlbmRBdCA8IHN0YXJ0RnJvbSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmRBdCBwcm9wIG11c3QgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0RnJvbSBwcm9wLlwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZpZGVvL2R1cmF0aW9uLXN0YXRlLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTMsIHVzZU1lbW8gYXMgdXNlTWVtbzEyLCB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkdXJhdGlvblJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcImdvdC1kdXJhdGlvblwiOiB7XG4gICAgICBjb25zdCBhYnNvbHV0ZVNyYyA9IGdldEFic29sdXRlU3JjKGFjdGlvbi5zcmMpO1xuICAgICAgaWYgKHN0YXRlW2Fic29sdXRlU3JjXSA9PT0gYWN0aW9uLmR1cmF0aW9uSW5TZWNvbmRzKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbYWJzb2x1dGVTcmNdOiBhY3Rpb24uZHVyYXRpb25JblNlY29uZHNcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG52YXIgRHVyYXRpb25zQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxMyh7XG4gIGR1cmF0aW9uczoge30sXG4gIHNldER1cmF0aW9uczogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRleHQgbWlzc2luZ1wiKTtcbiAgfVxufSk7XG52YXIgRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbZHVyYXRpb25zLCBzZXREdXJhdGlvbnNdID0gdXNlUmVkdWNlcihkdXJhdGlvblJlZHVjZXIsIHt9KTtcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vMTIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkdXJhdGlvbnMsXG4gICAgICBzZXREdXJhdGlvbnNcbiAgICB9O1xuICB9LCBbZHVyYXRpb25zXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTQoRHVyYXRpb25zQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUHJldmlldy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjQsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIxLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTQsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzE5LFxuICB1c2VSZWYgYXMgdXNlUmVmMTEsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTNcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9sb2ctbGV2ZWwtY29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdDEyIGZyb20gXCJyZWFjdFwiO1xudmFyIExvZ0xldmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNCh7XG4gIGxvZ0xldmVsOiBcImluZm9cIixcbiAgbW91bnRUaW1lOiAwXG59KTtcbnZhciB1c2VMb2dMZXZlbCA9ICgpID0+IHtcbiAgY29uc3QgeyBsb2dMZXZlbCB9ID0gUmVhY3QxMi51c2VDb250ZXh0KExvZ0xldmVsQ29udGV4dCk7XG4gIGlmIChsb2dMZXZlbCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUxvZ0xldmVsIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBMb2dMZXZlbFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBsb2dMZXZlbDtcbn07XG52YXIgdXNlTW91bnRUaW1lID0gKCkgPT4ge1xuICBjb25zdCB7IG1vdW50VGltZSB9ID0gUmVhY3QxMi51c2VDb250ZXh0KExvZ0xldmVsQ29udGV4dCk7XG4gIGlmIChtb3VudFRpbWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VNb3VudFRpbWUgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIExvZ0xldmVsUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIG1vdW50VGltZTtcbn07XG5cbi8vIHNyYy9yYW5kb20udHNcbmZ1bmN0aW9uIG11bGJlcnJ5MzIoYSkge1xuICBsZXQgdCA9IGEgKyAxODMxNTY1ODEzO1xuICB0ID0gTWF0aC5pbXVsKHQgXiB0ID4+PiAxNSwgdCB8IDEpO1xuICB0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG4gIHJldHVybiAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5Njtcbn1cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICBsZXQgaSA9IDA7XG4gIGxldCBjaHIgPSAwO1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAoaSA9IDA7aSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNociA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBoYXNoO1xufVxudmFyIHJhbmRvbSA9IChzZWVkLCBkdW1teSkgPT4ge1xuICBpZiAoZHVtbXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyYW5kb20oKSB0YWtlcyBvbmx5IG9uZSBhcmd1bWVudFwiKTtcbiAgfVxuICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKGhhc2hDb2RlKHNlZWQpKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihzZWVkICogMTAwMDAwMDAwMDApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInJhbmRvbSgpIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmdcIik7XG59O1xuXG4vLyBzcmMvdXNlLWFtcGxpZmljYXRpb24udHNcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QzLCB1c2VSZWYgYXMgdXNlUmVmNCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHdhcm5lZCA9IGZhbHNlO1xudmFyIHdhcm5PbmNlID0gKGxvZ0xldmVsKSA9PiB7XG4gIGlmICh3YXJuZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkID0gdHJ1ZTtcbiAgTG9nLndhcm4obG9nTGV2ZWwsIFwiQXVkaW9Db250ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xufTtcbnZhciBnZXRTaG91bGRBbXBsaWZ5ID0gKHZvbHVtZSkgPT4ge1xuICByZXR1cm4gdm9sdW1lID4gMTtcbn07XG52YXIgdXNlQW1wbGlmaWNhdGlvbiA9ICh7XG4gIG1lZGlhUmVmLFxuICB2b2x1bWUsXG4gIGxvZ0xldmVsXG59KSA9PiB7XG4gIGNvbnN0IHNob3VsZEFtcGxpZnkgPSBnZXRTaG91bGRBbXBsaWZ5KHZvbHVtZSk7XG4gIGNvbnN0IGF1ZGlvU3R1ZmZSZWYgPSB1c2VSZWY0KG51bGwpO1xuICBjb25zdCBjdXJyZW50Vm9sdW1lUmVmID0gdXNlUmVmNCh2b2x1bWUpO1xuICBjdXJyZW50Vm9sdW1lUmVmLmN1cnJlbnQgPSB2b2x1bWU7XG4gIHVzZUxheW91dEVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkQW1wbGlmeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUF1ZGlvQ29udGV4dCkge1xuICAgICAgd2Fybk9uY2UobG9nTGV2ZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGF1ZGlvU3R1ZmZSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgIGxhdGVuY3lIaW50OiBcImludGVyYWN0aXZlXCJcbiAgICB9KTtcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlKGF1ZGlvQ29udGV4dCwge1xuICAgICAgbWVkaWFFbGVtZW50OiBtZWRpYVJlZi5jdXJyZW50XG4gICAgfSk7XG4gICAgY29uc3QgZ2Fpbk5vZGUgPSBuZXcgR2Fpbk5vZGUoYXVkaW9Db250ZXh0LCB7XG4gICAgICBnYWluOiBNYXRoLm1heChjdXJyZW50Vm9sdW1lUmVmLmN1cnJlbnQsIDEpXG4gICAgfSk7XG4gICAgYXVkaW9TdHVmZlJlZi5jdXJyZW50ID0ge1xuICAgICAgZ2Fpbk5vZGUsXG4gICAgICBzb3VyY2UsXG4gICAgICBhdWRpb0NvbnRleHRcbiAgICB9O1xuICAgIHNvdXJjZS5jb25uZWN0KGdhaW5Ob2RlKTtcbiAgICBnYWluTm9kZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgTG9nLnRyYWNlKGxvZ0xldmVsLCBgU3RhcnRpbmcgdG8gYW1wbGlmeSAke21lZGlhUmVmLmN1cnJlbnQ/LnNyY30uIEdhaW4gPSAke2N1cnJlbnRWb2x1bWVSZWYuY3VycmVudH1gKTtcbiAgfSwgW2xvZ0xldmVsLCBtZWRpYVJlZiwgc2hvdWxkQW1wbGlmeV0pO1xuICBpZiAoYXVkaW9TdHVmZlJlZi5jdXJyZW50KSB7XG4gICAgY29uc3QgdmFsdWVUb1NldCA9IE1hdGgubWF4KHZvbHVtZSwgMSk7XG4gICAgaWYgKGF1ZGlvU3R1ZmZSZWYuY3VycmVudC5nYWluTm9kZS5nYWluLnZhbHVlICE9PSB2YWx1ZVRvU2V0KSB7XG4gICAgICBhdWRpb1N0dWZmUmVmLmN1cnJlbnQuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IHZhbHVlVG9TZXQ7XG4gICAgICBMb2cudHJhY2UobG9nTGV2ZWwsIGBTZXR0aW5nIGdhaW4gdG8gJHt2YWx1ZVRvU2V0fSBmb3IgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdWRpb1N0dWZmUmVmO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1pbi10aW1lbGluZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTUsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q3LCB1c2VNZW1vIGFzIHVzZU1lbW8xMywgdXNlU3RhdGUgYXMgdXNlU3RhdGU5IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9hdWRpby91c2UtYXVkaW8tZnJhbWUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTWVkaWFTdGFydHNBdCA9ICgpID0+IHtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MTQoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3Qgc3RhcnRzQXQgPSBNYXRoLm1pbigwLCBwYXJlbnRTZXF1ZW5jZT8ucmVsYXRpdmVGcm9tID8/IDApO1xuICByZXR1cm4gc3RhcnRzQXQ7XG59O1xudmFyIHVzZUZyYW1lRm9yVm9sdW1lUHJvcCA9IChiZWhhdmlvcikgPT4ge1xuICBjb25zdCBsb29wID0gTG9vcC51c2VMb29wKCk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBpZiAoYmVoYXZpb3IgPT09IFwicmVwZWF0XCIgfHwgbG9vcCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmcmFtZSArIHN0YXJ0c0F0O1xuICB9XG4gIHJldHVybiBmcmFtZSArIHN0YXJ0c0F0ICsgbG9vcC5kdXJhdGlvbkluRnJhbWVzICogbG9vcC5pdGVyYXRpb247XG59O1xuXG4vLyBzcmMvZ2V0LWFzc2V0LWZpbGUtbmFtZS50c1xudmFyIGdldEFzc2V0RGlzcGxheU5hbWUgPSAoZmlsZW5hbWUpID0+IHtcbiAgaWYgKC9kYXRhOnxibG9iOi8udGVzdChmaWxlbmFtZS5zdWJzdHJpbmcoMCwgNSkpKSB7XG4gICAgcmV0dXJuIFwiRGF0YSBVUkxcIjtcbiAgfVxuICBjb25zdCBzcGxpdHRlZCA9IGZpbGVuYW1lLnNwbGl0KFwiL1wiKS5tYXAoKHMpID0+IHMuc3BsaXQoXCJcXFxcXCIpKS5mbGF0KDEpO1xuICByZXR1cm4gc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoIC0gMV07XG59O1xuXG4vLyBzcmMvcGxheS1hbmQtaGFuZGxlLW5vdC1hbGxvd2VkLWVycm9yLnRzXG52YXIgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvciA9ICh7XG4gIG1lZGlhUmVmLFxuICBtZWRpYVR5cGUsXG4gIG9uQXV0b1BsYXlFcnJvcixcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZSxcbiAgcmVhc29uXG59KSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gIGlmICghY3VycmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgIGxvZ0xldmVsLFxuICAgIHRhZzogXCJwbGF5XCIsXG4gICAgbWVzc2FnZTogYEF0dGVtcHRpbmcgdG8gcGxheSAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgY29uc3QgcHJvbSA9IGN1cnJlbnQucGxheSgpO1xuICBpZiAoIXByb20uY2F0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgY2FsbCB0byBwYXVzZVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgZmV0Y2hpbmcgcHJvY2VzcyBmb3IgdGhlIG1lZGlhIHJlc291cmNlIHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyIGFnZW50XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgbmV3IGxvYWQgcmVxdWVzdFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJiZWNhdXNlIHRoZSBtZWRpYSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJ1c2VyIGRpZG4ndCBpbnRlcmFjdCB3aXRoIHRoZSBkb2N1bWVudFwiKSAmJiBjdXJyZW50Lm11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBDb3VsZCBub3QgcGxheSAke21lZGlhVHlwZX0gZHVlIHRvIGZvbGxvd2luZyBlcnJvcjogYCwgZXJyKTtcbiAgICBpZiAoIWN1cnJlbnQubXV0ZWQpIHtcbiAgICAgIGlmIChvbkF1dG9QbGF5RXJyb3IpIHtcbiAgICAgICAgb25BdXRvUGxheUVycm9yKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGBUaGUgdmlkZW8gd2lsbCBiZSBtdXRlZCBhbmQgd2UnbGwgcmV0cnkgcGxheWluZyBpdC5gKTtcbiAgICAgIGlmIChtZWRpYVR5cGUgPT09IFwidmlkZW9cIiAmJiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2Ugb25BdXRvUGxheUVycm9yKCkgdG8gaGFuZGxlIHRoaXMgZXJyb3IgeW91cnNlbGYuXCIpO1xuICAgICAgfVxuICAgICAgY3VycmVudC5tdXRlZCA9IHRydWU7XG4gICAgICBjdXJyZW50LnBsYXkoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL3ZvbHVtZS1wcm9wLnRzXG52YXIgZXZhbHVhdGVWb2x1bWUgPSAoe1xuICBmcmFtZSxcbiAgdm9sdW1lLFxuICBtZWRpYVZvbHVtZSA9IDFcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdm9sdW1lICogbWVkaWFWb2x1bWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gTnVtYmVyKG1lZGlhVm9sdW1lKTtcbiAgfVxuICBjb25zdCBldmFsdWF0ZWQgPSB2b2x1bWUoZnJhbWUpICogbWVkaWFWb2x1bWU7XG4gIGlmICh0eXBlb2YgZXZhbHVhdGVkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCBkaWQgbm90IHJldHVybiBhIG51bWJlciBidXQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGV2YWx1YXRlZH0gZm9yIGZyYW1lICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgTmFOIGZvciBmcmFtZSAke2ZyYW1lfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgYSBub24tZmluaXRlIG51bWJlciBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV2YWx1YXRlZCk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG52YXIgZGlkV2FybiA9IHt9O1xudmFyIHdhcm5PbmNlMiA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FyblttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIHVzZU1lZGlhSW5UaW1lbGluZSA9ICh7XG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUsXG4gIG1lZGlhUmVmLFxuICBzcmMsXG4gIG1lZGlhVHlwZSxcbiAgcGxheWJhY2tSYXRlLFxuICBkaXNwbGF5TmFtZSxcbiAgaWQsXG4gIHN0YWNrLFxuICBzaG93SW5UaW1lbGluZSxcbiAgcHJlbW91bnREaXNwbGF5LFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIGlzUHJlbW91bnRpbmdcbn0pID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCB7IHJvb3RJZCwgYXVkaW9BbmRWaWRlb1RhZ3MgfSA9IHVzZUNvbnRleHQxNShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxNShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBhY3R1YWxGcm9tID0gcGFyZW50U2VxdWVuY2UgPyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gKyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tIDogMDtcbiAgY29uc3QgeyBpbXBlcmF0aXZlUGxheWluZyB9ID0gdXNlQ29udGV4dDE1KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDE1KFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IFtpbml0aWFsVm9sdW1lXSA9IHVzZVN0YXRlOSgoKSA9PiB2b2x1bWUpO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IG1vdW50VGltZSA9IHVzZU1vdW50VGltZSgpO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCB2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzKSA6IHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGRvZXNWb2x1bWVDaGFuZ2UgPSB0eXBlb2Ygdm9sdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gIGNvbnN0IHZvbHVtZXMgPSB1c2VNZW1vMTMoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdm9sdW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5KE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgZHVyYXRpb24gKyBzdGFydHNBdCkpKS5maWxsKHRydWUpLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgICAgZnJhbWU6IGkgKyBzdGFydHNBdCxcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZVxuICAgICAgfSk7XG4gICAgfSkuam9pbihcIixcIik7XG4gIH0sIFtkdXJhdGlvbiwgc3RhcnRzQXQsIHZvbHVtZSwgbWVkaWFWb2x1bWVdKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIgJiYgdm9sdW1lICE9PSBpbml0aWFsVm9sdW1lKSB7XG4gICAgICB3YXJuT25jZTIoYFJlbW90aW9uOiBUaGUgJHttZWRpYVR5cGV9IHdpdGggc3JjICR7c3JjfSBoYXMgY2hhbmdlZCBpdCdzIHZvbHVtZS4gUHJlZmVyIHRoZSBjYWxsYmFjayBzeW50YXggZm9yIHNldHRpbmcgdm9sdW1lIHRvIGdldCBiZXR0ZXIgdGltZWxpbmUgZGlzcGxheTogaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvYXVkaW8vdm9sdW1lYCk7XG4gICAgfVxuICB9LCBbaW5pdGlhbFZvbHVtZSwgbWVkaWFUeXBlLCBzcmMsIHZvbHVtZV0pO1xuICB1c2VFZmZlY3Q3KCgpID0+IHtcbiAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvICYmIHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WICE9PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNob3dJblRpbWVsaW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyU2VxdWVuY2Uoe1xuICAgICAgdHlwZTogbWVkaWFUeXBlLFxuICAgICAgc3JjLFxuICAgICAgaWQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGZyb206IDAsXG4gICAgICBwYXJlbnQ6IHBhcmVudFNlcXVlbmNlPy5pZCA/PyBudWxsLFxuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lID8/IGdldEFzc2V0RGlzcGxheU5hbWUoc3JjKSxcbiAgICAgIHJvb3RJZCxcbiAgICAgIHZvbHVtZTogdm9sdW1lcyxcbiAgICAgIHNob3dJblRpbWVsaW5lOiB0cnVlLFxuICAgICAgbm9uY2UsXG4gICAgICBzdGFydE1lZGlhRnJvbTogMCAtIHN0YXJ0c0F0LFxuICAgICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICAgIGxvb3BEaXNwbGF5OiB1bmRlZmluZWQsXG4gICAgICBwbGF5YmFja1JhdGUsXG4gICAgICBzdGFjayxcbiAgICAgIHByZW1vdW50RGlzcGxheVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyU2VxdWVuY2UoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBhY3R1YWxGcm9tLFxuICAgIGR1cmF0aW9uLFxuICAgIGlkLFxuICAgIHBhcmVudFNlcXVlbmNlLFxuICAgIHNyYyxcbiAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgIHJvb3RJZCxcbiAgICB1bnJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgdmlkZW9Db25maWcsXG4gICAgdm9sdW1lcyxcbiAgICBkb2VzVm9sdW1lQ2hhbmdlLFxuICAgIG5vbmNlLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBzdGFydHNBdCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgZGlzcGxheU5hbWUsXG4gICAgc3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5XG4gIF0pO1xuICB1c2VFZmZlY3Q3KCgpID0+IHtcbiAgICBjb25zdCB0YWcgPSB7XG4gICAgICBpZCxcbiAgICAgIHBsYXk6IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKCFpbXBlcmF0aXZlUGxheWluZy5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZW1vdW50aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHtcbiAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgICAgb25BdXRvUGxheUVycm9yLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgICByZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50LnB1c2godGFnKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudCA9IGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQuZmlsdGVyKChhKSA9PiBhLmlkICE9PSBpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGF1ZGlvQW5kVmlkZW9UYWdzLFxuICAgIGlkLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgaW1wZXJhdGl2ZVBsYXlpbmcsXG4gICAgaXNQcmVtb3VudGluZyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWVcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXBsYXliYWNrLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazgsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE4LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTEsIHVzZVJlZiBhcyB1c2VSZWY5IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXItdW50aWwtZmlyc3QtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNywgdXNlTWVtbyBhcyB1c2VNZW1vMTYsIHVzZVJlZiBhcyB1c2VSZWY2IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtYnVmZmVyLXN0YXRlLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNywgdXNlTWVtbyBhcyB1c2VNZW1vMTUgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2J1ZmZlcmluZy50c3hcbmltcG9ydCBSZWFjdDEzLCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTYsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q4LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NCxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTQsXG4gIHVzZVJlZiBhcyB1c2VSZWY1LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEwXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgdXNlQnVmZmVyTWFuYWdlciA9IChsb2dMZXZlbCwgbW91bnRUaW1lKSA9PiB7XG4gIGNvbnN0IFtibG9ja3MsIHNldEJsb2Nrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgW29uQnVmZmVyaW5nQ2FsbGJhY2tzLCBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgW29uUmVzdW1lQ2FsbGJhY2tzLCBzZXRPblJlc3VtZUNhbGxiYWNrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgYnVmZmVyaW5nID0gdXNlUmVmNShmYWxzZSk7XG4gIGNvbnN0IGFkZEJsb2NrID0gdXNlQ2FsbGJhY2s2KChibG9jaykgPT4ge1xuICAgIHNldEJsb2NrcygoYikgPT4gWy4uLmIsIGJsb2NrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuYmxvY2s6ICgpID0+IHtcbiAgICAgICAgc2V0QmxvY2tzKChiKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3QXJyID0gYi5maWx0ZXIoKGJ4KSA9PiBieCAhPT0gYmxvY2spO1xuICAgICAgICAgIGlmIChuZXdBcnIubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yQnVmZmVyaW5nID0gdXNlQ2FsbGJhY2s2KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yUmVzdW1lID0gdXNlQ2FsbGJhY2s2KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkJ1ZmZlcmluZ0NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IFwiUGxheWVyIGlzIGVudGVyaW5nIGJ1ZmZlciBzdGF0ZVwiLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJwbGF5ZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYmxvY2tzXSk7XG4gIHVzZUxheW91dEVmZmVjdDQoKCkgPT4ge1xuICAgIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBvblJlc3VtZUNhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IFwiUGxheWVyIGlzIGV4aXRpbmcgYnVmZmVyIHN0YXRlXCIsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgdGFnOiBcInBsYXllclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtibG9ja3NdKTtcbiAgcmV0dXJuIHVzZU1lbW8xNCgoKSA9PiB7XG4gICAgcmV0dXJuIHsgYWRkQmxvY2ssIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lLCBidWZmZXJpbmcgfTtcbiAgfSwgW2FkZEJsb2NrLCBidWZmZXJpbmcsIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lXSk7XG59O1xudmFyIEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCA9IFJlYWN0MTMuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBCdWZmZXJpbmdQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgeyBsb2dMZXZlbCwgbW91bnRUaW1lIH0gPSB1c2VDb250ZXh0MTYoTG9nTGV2ZWxDb250ZXh0KTtcbiAgY29uc3QgYnVmZmVyTWFuYWdlciA9IHVzZUJ1ZmZlck1hbmFnZXIobG9nTGV2ZWwgPz8gXCJpbmZvXCIsIG1vdW50VGltZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTUoQnVmZmVyaW5nQ29udGV4dFJlYWN0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGJ1ZmZlck1hbmFnZXIsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZUlzUGxheWVyQnVmZmVyaW5nID0gKGJ1ZmZlck1hbmFnZXIpID0+IHtcbiAgY29uc3QgW2lzQnVmZmVyaW5nLCBzZXRJc0J1ZmZlcmluZ10gPSB1c2VTdGF0ZTEwKGJ1ZmZlck1hbmFnZXIuYnVmZmVyaW5nLmN1cnJlbnQpO1xuICB1c2VFZmZlY3Q4KCgpID0+IHtcbiAgICBjb25zdCBvbkJ1ZmZlciA9ICgpID0+IHtcbiAgICAgIHNldElzQnVmZmVyaW5nKHRydWUpO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXN1bWUgPSAoKSA9PiB7XG4gICAgICBzZXRJc0J1ZmZlcmluZyhmYWxzZSk7XG4gICAgfTtcbiAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvckJ1ZmZlcmluZyhvbkJ1ZmZlcik7XG4gICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JSZXN1bWUob25SZXN1bWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvckJ1ZmZlcmluZygoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JSZXN1bWUoKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbYnVmZmVyTWFuYWdlcl0pO1xuICByZXR1cm4gaXNCdWZmZXJpbmc7XG59O1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xudmFyIHVzZUJ1ZmZlclN0YXRlID0gKCkgPT4ge1xuICBjb25zdCBidWZmZXIgPSB1c2VDb250ZXh0MTcoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgYWRkQmxvY2sgPSBidWZmZXIgPyBidWZmZXIuYWRkQmxvY2sgOiBudWxsO1xuICByZXR1cm4gdXNlTWVtbzE1KCgpID0+ICh7XG4gICAgZGVsYXlQbGF5YmFjazogKCkgPT4ge1xuICAgICAgaWYgKCFhZGRCbG9jaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBlbmFibGUgdGhlIGJ1ZmZlcmluZyBzdGF0ZSwgYnV0IGEgUmVtb3Rpb24gY29udGV4dCB3YXMgbm90IGZvdW5kLiBUaGlzIEFQSSBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBSZW1vdGlvbiBQbGF5ZXIgb3IgYSA8Q29tcG9zaXRpb24+LiBPciB5b3UgbWlnaHQgaGF2ZSBleHBlcmllbmNlZCBhIHZlcnNpb24gbWlzbWF0Y2ggLSBydW4gYG5weCByZW1vdGlvbiB2ZXJzaW9uc2AgYW5kIGVuc3VyZSBhbGwgcGFja2FnZXMgaGF2ZSB0aGUgc2FtZSB2ZXJzaW9uLiBUaGlzIGVycm9yIGlzIHRocm93biBieSB0aGUgYnVmZmVyIHN0YXRlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2J1ZmZlci1zdGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdW5ibG9jayB9ID0gYWRkQmxvY2soe1xuICAgICAgICBpZDogU3RyaW5nKE1hdGgucmFuZG9tKCkpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHVuYmxvY2sgfTtcbiAgICB9XG4gIH0pLCBbYWRkQmxvY2tdKTtcbn07XG5cbi8vIHNyYy9idWZmZXItdW50aWwtZmlyc3QtZnJhbWUudHNcbnZhciBpc1NhZmFyaVdlYmtpdCA9ICgpID0+IHtcbiAgY29uc3QgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgcmV0dXJuIGlzU2FmYXJpO1xufTtcbnZhciB1c2VCdWZmZXJVbnRpbEZpcnN0RnJhbWUgPSAoe1xuICBtZWRpYVJlZixcbiAgbWVkaWFUeXBlLFxuICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICBsb2dMZXZlbCxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlcmluZ1JlZiA9IHVzZVJlZjYoZmFsc2UpO1xuICBjb25zdCB7IGRlbGF5UGxheWJhY2sgfSA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IGJ1ZmZlclVudGlsRmlyc3RGcmFtZSA9IHVzZUNhbGxiYWNrNygocmVxdWVzdGVkVGltZSkgPT4ge1xuICAgIGlmIChtZWRpYVR5cGUgIT09IFwidmlkZW9cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBhdXNlV2hlbkJ1ZmZlcmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA+PSBjdXJyZW50LkhBVkVfRU5PVUdIX0RBVEEgJiYgIWlzU2FmYXJpV2Via2l0KCkpIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBgTm90IHVzaW5nIGJ1ZmZlciB1bnRpbCBmaXJzdCBmcmFtZSwgYmVjYXVzZSByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSBhbmQgaXMgbm90IFNhZmFyaWAsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgdGFnOiBcImJ1ZmZlclwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2spIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBgTm90IHVzaW5nIGJ1ZmZlciB1bnRpbCBmaXJzdCBmcmFtZSwgYmVjYXVzZSByZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrIGlzIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJidWZmZXJcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJ1ZmZlcmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtZXNzYWdlOiBgQnVmZmVyaW5nICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfSB1bnRpbCB0aGUgZmlyc3QgZnJhbWUgaXMgcmVjZWl2ZWRgLFxuICAgICAgbW91bnRUaW1lLFxuICAgICAgdGFnOiBcImJ1ZmZlclwiXG4gICAgfSk7XG4gICAgY29uc3QgcGxheWJhY2sgPSBkZWxheVBsYXliYWNrKCk7XG4gICAgY29uc3QgdW5ibG9jayA9ICgpID0+IHtcbiAgICAgIHBsYXliYWNrLnVuYmxvY2soKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHVuYmxvY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB1bmJsb2NrLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5ID0gKCkgPT4ge1xuICAgICAgdW5ibG9jaygpO1xuICAgIH07XG4gICAgY3VycmVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCA9IE1hdGguYWJzKGluZm8ubWVkaWFUaW1lIC0gcmVxdWVzdGVkVGltZSk7XG4gICAgICBpZiAoZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQgPiAwLjUpIHtcbiAgICAgICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHVuYmxvY2soKTtcbiAgICB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbXG4gICAgZGVsYXlQbGF5YmFjayxcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgbW91bnRUaW1lLFxuICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZ1xuICBdKTtcbiAgcmV0dXJuIHVzZU1lbW8xNigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQnVmZmVyaW5nOiAoKSA9PiBidWZmZXJpbmdSZWYuY3VycmVudCxcbiAgICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZVxuICAgIH07XG4gIH0sIFtidWZmZXJVbnRpbEZpcnN0RnJhbWVdKTtcbn07XG5cbi8vIHNyYy92aWRlby92aWRlby1mcmFnbWVudC50c1xuaW1wb3J0IHsgdXNlUmVmIGFzIHVzZVJlZjcgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB0b1NlY29uZHMgPSAodGltZSwgZnBzKSA9PiB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHRpbWUgLyBmcHMgKiAxMDApIC8gMTAwO1xufTtcbnZhciBpc0lvc1NhZmFyaSA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaXNJcGFkSVBvZElQaG9uZSA9IC9pUChhZHxvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBpc0FwcGxlV2ViS2l0ID0gL0FwcGxlV2ViS2l0Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgcmV0dXJuIGlzSXBhZElQb2RJUGhvbmUgJiYgaXNBcHBsZVdlYktpdDtcbn07XG52YXIgaXNJT1NTYWZhcmlBbmRCbG9iID0gKGFjdHVhbFNyYykgPT4ge1xuICByZXR1cm4gaXNJb3NTYWZhcmkoKSAmJiBhY3R1YWxTcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpO1xufTtcbnZhciBnZXRWaWRlb0ZyYWdtZW50U3RhcnQgPSAoe1xuICBhY3R1YWxGcm9tLFxuICBmcHNcbn0pID0+IHtcbiAgcmV0dXJuIHRvU2Vjb25kcyhNYXRoLm1heCgwLCAtYWN0dWFsRnJvbSksIGZwcyk7XG59O1xudmFyIGdldFZpZGVvRnJhZ21lbnRFbmQgPSAoe1xuICBkdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIHJldHVybiB0b1NlY29uZHMoZHVyYXRpb24sIGZwcyk7XG59O1xudmFyIGFwcGVuZFZpZGVvRnJhZ21lbnQgPSAoe1xuICBhY3R1YWxTcmMsXG4gIGFjdHVhbEZyb20sXG4gIGR1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgaWYgKGlzSU9TU2FmYXJpQW5kQmxvYihhY3R1YWxTcmMpKSB7XG4gICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgfVxuICBpZiAoYWN0dWFsU3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdIYXNoID0gQm9vbGVhbihuZXcgVVJMKGFjdHVhbFNyYywgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogd2luZG93LmxvY2F0aW9uLmhyZWYpID8/IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIpLmhhc2gpO1xuICBpZiAoZXhpc3RpbmdIYXNoKSB7XG4gICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhY3R1YWxGcm9tKSkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgY29uc3Qgd2l0aFN0YXJ0SGFzaCA9IGAke2FjdHVhbFNyY30jdD0ke2dldFZpZGVvRnJhZ21lbnRTdGFydCh7IGFjdHVhbEZyb20sIGZwcyB9KX1gO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICByZXR1cm4gd2l0aFN0YXJ0SGFzaDtcbiAgfVxuICByZXR1cm4gYCR7d2l0aFN0YXJ0SGFzaH0sJHtnZXRWaWRlb0ZyYWdtZW50RW5kKHsgZHVyYXRpb24sIGZwcyB9KX1gO1xufTtcbnZhciBpc1N1YnNldE9mRHVyYXRpb24gPSAoe1xuICBwcmV2U3RhcnRGcm9tLFxuICBuZXdTdGFydEZyb20sXG4gIHByZXZEdXJhdGlvbixcbiAgbmV3RHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICBjb25zdCBwcmV2aW91c0Zyb20gPSBnZXRWaWRlb0ZyYWdtZW50U3RhcnQoeyBhY3R1YWxGcm9tOiBwcmV2U3RhcnRGcm9tLCBmcHMgfSk7XG4gIGNvbnN0IG5ld0Zyb20gPSBnZXRWaWRlb0ZyYWdtZW50U3RhcnQoeyBhY3R1YWxGcm9tOiBuZXdTdGFydEZyb20sIGZwcyB9KTtcbiAgY29uc3QgcHJldmlvdXNFbmQgPSBnZXRWaWRlb0ZyYWdtZW50RW5kKHsgZHVyYXRpb246IHByZXZEdXJhdGlvbiwgZnBzIH0pO1xuICBjb25zdCBuZXdFbmQgPSBnZXRWaWRlb0ZyYWdtZW50RW5kKHsgZHVyYXRpb246IG5ld0R1cmF0aW9uLCBmcHMgfSk7XG4gIGlmIChuZXdGcm9tIDwgcHJldmlvdXNGcm9tKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuZXdFbmQgPiBwcmV2aW91c0VuZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgdXNlQXBwZW5kVmlkZW9GcmFnbWVudCA9ICh7XG4gIGFjdHVhbFNyYzogaW5pdGlhbEFjdHVhbFNyYyxcbiAgYWN0dWFsRnJvbTogaW5pdGlhbEFjdHVhbEZyb20sXG4gIGR1cmF0aW9uOiBpbml0aWFsRHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICBjb25zdCBhY3R1YWxGcm9tUmVmID0gdXNlUmVmNyhpbml0aWFsQWN0dWFsRnJvbSk7XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uID0gdXNlUmVmNyhpbml0aWFsRHVyYXRpb24pO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VSZWY3KGluaXRpYWxBY3R1YWxTcmMpO1xuICBpZiAoIWlzU3Vic2V0T2ZEdXJhdGlvbih7XG4gICAgcHJldlN0YXJ0RnJvbTogYWN0dWFsRnJvbVJlZi5jdXJyZW50LFxuICAgIG5ld1N0YXJ0RnJvbTogaW5pdGlhbEFjdHVhbEZyb20sXG4gICAgcHJldkR1cmF0aW9uOiBhY3R1YWxEdXJhdGlvbi5jdXJyZW50LFxuICAgIG5ld0R1cmF0aW9uOiBpbml0aWFsRHVyYXRpb24sXG4gICAgZnBzXG4gIH0pIHx8IGluaXRpYWxBY3R1YWxTcmMgIT09IGFjdHVhbFNyYy5jdXJyZW50KSB7XG4gICAgYWN0dWFsRnJvbVJlZi5jdXJyZW50ID0gaW5pdGlhbEFjdHVhbEZyb207XG4gICAgYWN0dWFsRHVyYXRpb24uY3VycmVudCA9IGluaXRpYWxEdXJhdGlvbjtcbiAgICBhY3R1YWxTcmMuY3VycmVudCA9IGluaXRpYWxBY3R1YWxTcmM7XG4gIH1cbiAgY29uc3QgYXBwZW5kZWQgPSBhcHBlbmRWaWRlb0ZyYWdtZW50KHtcbiAgICBhY3R1YWxTcmM6IGFjdHVhbFNyYy5jdXJyZW50LFxuICAgIGFjdHVhbEZyb206IGFjdHVhbEZyb21SZWYuY3VycmVudCxcbiAgICBkdXJhdGlvbjogYWN0dWFsRHVyYXRpb24uY3VycmVudCxcbiAgICBmcHNcbiAgfSk7XG4gIHJldHVybiBhcHBlbmRlZDtcbn07XG5cbi8vIHNyYy9zZWVrLnRzXG52YXIgc2VlayA9ICh7XG4gIG1lZGlhUmVmLFxuICB0aW1lLFxuICBsb2dMZXZlbCxcbiAgd2h5LFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGltZVRvU2V0ID0gaXNJb3NTYWZhcmkoKSA/IE51bWJlcih0aW1lLnRvRml4ZWQoMSkpIDogdGltZTtcbiAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICBsb2dMZXZlbCxcbiAgICB0YWc6IFwic2Vla1wiLFxuICAgIG1lc3NhZ2U6IGBTZWVraW5nIGZyb20gJHttZWRpYVJlZi5jdXJyZW50VGltZX0gdG8gJHt0aW1lVG9TZXR9LiBzcmM9ICR7bWVkaWFSZWYuc3JjfSBSZWFzb246ICR7d2h5fWAsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBtZWRpYVJlZi5jdXJyZW50VGltZSA9IHRpbWVUb1NldDtcbiAgcmV0dXJuIHRpbWVUb1NldDtcbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtYnVmZmVyaW5nLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OSwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhQnVmZmVyaW5nID0gKHtcbiAgZWxlbWVudCxcbiAgc2hvdWxkQnVmZmVyLFxuICBpc1ByZW1vdW50aW5nLFxuICBsb2dMZXZlbCxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IFtpc0J1ZmZlcmluZywgc2V0SXNCdWZmZXJpbmddID0gdXNlU3RhdGUxMShmYWxzZSk7XG4gIHVzZUVmZmVjdDkoKCkgPT4ge1xuICAgIGxldCBjbGVhbnVwRm5zID0gW107XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBlbGVtZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNob3VsZEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcmVtb3VudGluZykge1xuICAgICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA8IGN1cnJlbnQuSEFWRV9GVVRVUkVfREFUQSkge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJGaXJlZm94L1wiKSkge1xuICAgICAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDYWxsaW5nIC5sb2FkKCkgb24gJHtjdXJyZW50LnNyY30gYmVjYXVzZSByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSBhbmQgaXQgaXMgbm90IEZpcmVmb3guIEVsZW1lbnQgaXMgcHJlbW91bnRlZGAsXG4gICAgICAgICAgICB0YWc6IFwibG9hZFwiLFxuICAgICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9IChyZWFzb24pID0+IHtcbiAgICAgIGxldCBkaWREb1NvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgY2xlYW51cEZucy5mb3JFYWNoKChmbikgPT4ge1xuICAgICAgICBmbihyZWFzb24pO1xuICAgICAgICBkaWREb1NvbWV0aGluZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGNsZWFudXBGbnMgPSBbXTtcbiAgICAgIHNldElzQnVmZmVyaW5nKChwcmV2aW91cykgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICBkaWREb1NvbWV0aGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBpZiAoZGlkRG9Tb21ldGhpbmcpIHtcbiAgICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5tYXJraW5nIGFzIGJ1ZmZlcmluZzogJHtjdXJyZW50LnNyY30uIFJlYXNvbjogJHtyZWFzb259YCxcbiAgICAgICAgICB0YWc6IFwiYnVmZmVyXCIsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmxvY2tNZWRpYSA9IChyZWFzb24pID0+IHtcbiAgICAgIHNldElzQnVmZmVyaW5nKHRydWUpO1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IGBNYXJraW5nIGFzIGJ1ZmZlcmluZzogJHtjdXJyZW50LnNyY30uIFJlYXNvbjogJHtyZWFzb259YCxcbiAgICAgICAgdGFnOiBcImJ1ZmZlclwiLFxuICAgICAgICBtb3VudFRpbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyB1bmJsb2NrIH0gPSBidWZmZXIuZGVsYXlQbGF5YmFjaygpO1xuICAgICAgY29uc3Qgb25DYW5QbGF5ID0gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCdcImNhbnBsYXlcIiB3YXMgZmlyZWQnKTtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoJ1wiZXJyb3JcIiBldmVudCB3YXMgb2NjdXJyZWQnKTtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkNhblBsYXkpO1xuICAgICAgfSk7XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICB9KTtcbiAgICAgIGNsZWFudXBGbnMucHVzaCgoY2xlYW51cFJlYXNvbikgPT4ge1xuICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbmJsb2NraW5nICR7Y3VycmVudC5zcmN9IGZyb20gYnVmZmVyLiBSZWFzb246ICR7Y2xlYW51cFJlYXNvbn1gLFxuICAgICAgICAgIHRhZzogXCJidWZmZXJcIixcbiAgICAgICAgICBtb3VudFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgYmxvY2tNZWRpYShgcmVhZHlTdGF0ZSBpcyAke2N1cnJlbnQucmVhZHlTdGF0ZX0sIHdoaWNoIGlzIGxlc3MgdGhhbiBIQVZFX0ZVVFVSRV9EQVRBYCk7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3gvXCIpKSB7XG4gICAgICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgbWVzc2FnZTogYENhbGxpbmcgLmxvYWQoKSBvbiAke2N1cnJlbnQuc3JjfSBiZWNhdXNlIHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9IGFuZCBpdCBpcyBub3QgRmlyZWZveC5gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnQubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbldhaXRpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgYmxvY2tNZWRpYSgnXCJ3YWl0aW5nXCIgZXZlbnQgd2FzIGZpcmVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndhaXRpbmdcIiwgb25XYWl0aW5nKTtcbiAgICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgaW5pdCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwKFwiZWxlbWVudCB3YXMgdW5tb3VudGVkIG9yIHByb3AgY2hhbmdlZFwiKTtcbiAgICB9O1xuICB9LCBbYnVmZmVyLCBlbGVtZW50LCBpc1ByZW1vdW50aW5nLCBsb2dMZXZlbCwgc2hvdWxkQnVmZmVyLCBtb3VudFRpbWVdKTtcbiAgcmV0dXJuIGlzQnVmZmVyaW5nO1xufTtcblxuLy8gc3JjL3VzZS1yZXF1ZXN0LXZpZGVvLWNhbGxiYWNrLXRpbWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMCwgdXNlUmVmIGFzIHVzZVJlZjggfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUgPSAoe1xuICBtZWRpYVJlZixcbiAgbWVkaWFUeXBlLFxuICBsYXN0U2VlayxcbiAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWRcbn0pID0+IHtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VSZWY4KG51bGwpO1xuICB1c2VFZmZlY3QxMCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBtZWRpYVJlZjtcbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgY3VycmVudFRpbWUuY3VycmVudCA9IGN1cnJlbnQuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFUeXBlICE9PSBcInZpZGVvXCIpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWRlb1RhZyA9IGN1cnJlbnQ7XG4gICAgaWYgKCF2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgaWYgKCF2aWRlb1RhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjYiA9IHZpZGVvVGFnLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soKF8sIGluZm8pID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoY3VycmVudFRpbWUuY3VycmVudCAtIGluZm8ubWVkaWFUaW1lKTtcbiAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlVG9MYXN0U2VlayA9IE1hdGguYWJzKGxhc3RTZWVrLmN1cnJlbnQgPT09IG51bGwgPyBJbmZpbml0eSA6IGluZm8ubWVkaWFUaW1lIC0gbGFzdFNlZWsuY3VycmVudCk7XG4gICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPiAwLjUgJiYgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPiAwLjUgJiYgaW5mby5tZWRpYVRpbWUgPiBjdXJyZW50VGltZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gaW5mby5tZWRpYVRpbWU7XG4gICAgICAgIHJlcXVlc3QoKTtcbiAgICAgIH0pO1xuICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICB2aWRlb1RhZy5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2soY2IpO1xuICAgICAgICBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICAgIHJlcXVlc3QoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsKCk7XG4gICAgfTtcbiAgfSwgW2xhc3RTZWVrLCBtZWRpYVJlZiwgbWVkaWFUeXBlLCBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZF0pO1xuICByZXR1cm4gY3VycmVudFRpbWU7XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBlYXNpbmcgfSA9IG9wdGlvbnM7XG4gIGxldCByZXN1bHQgPSBpbnB1dDtcbiAgY29uc3QgW2lucHV0TWluLCBpbnB1dE1heF0gPSBpbnB1dFJhbmdlO1xuICBjb25zdCBbb3V0cHV0TWluLCBvdXRwdXRNYXhdID0gb3V0cHV0UmFuZ2U7XG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImV4dGVuZFwiKSB7fVxuICB9XG4gIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWF4O1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHtcbiAgICByZXR1cm4gb3V0cHV0TWluO1xuICB9XG4gIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTtpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGFycikge1xuICBmb3IgKGxldCBpID0gMTtpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCEoYXJyW2ldID4gYXJyW2kgLSAxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRSYW5nZSBtdXN0IGJlIHN0cmljdGx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0luZmluaXRlUmFuZ2UobmFtZSwgYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHNcIik7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IG51bWJlcnNgKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBmaW5pdGUgbnVtYmVycywgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgKFwiICsgaW5wdXRSYW5nZS5sZW5ndGggKyBcIikgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcImlucHV0UmFuZ2VcIiwgaW5wdXRSYW5nZSk7XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcIm91dHB1dFJhbmdlXCIsIG91dHB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG4gIGNvbnN0IGVhc2luZyA9IG9wdGlvbnM/LmVhc2luZyA/PyAoKG51bSkgPT4gbnVtKTtcbiAgbGV0IGV4dHJhcG9sYXRlTGVmdCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlTGVmdCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVMZWZ0O1xuICB9XG4gIGxldCBleHRyYXBvbGF0ZVJpZ2h0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBvcHRpb25zLmV4dHJhcG9sYXRlUmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW50ZXJwb2xhdGUgYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKTtcbiAgcmV0dXJuIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIFtpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdXSwgW291dHB1dFJhbmdlW3JhbmdlXSwgb3V0cHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIHtcbiAgICBlYXNpbmcsXG4gICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgIGV4dHJhcG9sYXRlUmlnaHRcbiAgfSk7XG59XG5cbi8vIHNyYy92aWRlby9nZXQtY3VycmVudC10aW1lLnRzXG52YXIgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQgPSAoe1xuICBmcmFtZSxcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgcmV0dXJuIGludGVycG9sYXRlKGZyYW1lLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgMV0sIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyBwbGF5YmFja1JhdGVdKTtcbn07XG52YXIgZ2V0TWVkaWFUaW1lID0gKHtcbiAgZnBzLFxuICBmcmFtZSxcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgY29uc3QgZXhwZWN0ZWRGcmFtZSA9IGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkKHtcbiAgICBmcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgc3RhcnRGcm9tXG4gIH0pO1xuICBjb25zdCBtc1BlckZyYW1lID0gMTAwMCAvIGZwcztcbiAgcmV0dXJuIGV4cGVjdGVkRnJhbWUgKiBtc1BlckZyYW1lIC8gMTAwMDtcbn07XG5cbi8vIHNyYy93YXJuLWFib3V0LW5vbi1zZWVrYWJsZS1tZWRpYS50c1xudmFyIGFscmVhZHlXYXJuZWQgPSB7fTtcbnZhciB3YXJuQWJvdXROb25TZWVrYWJsZU1lZGlhID0gKHJlZiwgdHlwZSkgPT4ge1xuICBpZiAocmVmID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZWYuc2Vla2FibGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZWYuc2Vla2FibGUubGVuZ3RoID4gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYWxyZWFkeVdhcm5lZFtyZWYuc3JjXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByYW5nZSA9IHsgc3RhcnQ6IHJlZi5zZWVrYWJsZS5zdGFydCgwKSwgZW5kOiByZWYuc2Vla2FibGUuZW5kKDApIH07XG4gIGlmIChyYW5nZS5zdGFydCA9PT0gMCAmJiByYW5nZS5lbmQgPT09IDApIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgVGhlIG1lZGlhICR7cmVmLnNyY30gY2Fubm90IGJlIHNlZWtlZC4gVGhpcyBjb3VsZCBiZSBvbmUgb2YgZmV3IHJlYXNvbnM6YCxcbiAgICAgIFwiMSkgVGhlIG1lZGlhIHJlc291cmNlIHdhcyByZXBsYWNlZCB3aGlsZSB0aGUgdmlkZW8gaXMgcGxheWluZyBidXQgaXQgd2FzIG5vdCBsb2FkZWQgeWV0LlwiLFxuICAgICAgXCIyKSBUaGUgbWVkaWEgZG9lcyBub3Qgc3VwcG9ydCBzZWVraW5nLlwiLFxuICAgICAgXCIzKSBUaGUgbWVkaWEgd2FzIGxvYWRlZCB3aXRoIHNlY3VyaXR5IGhlYWRlcnMgcHJ2ZW50aW5nIGl0IGZyb20gYmVpbmcgaW5jbHVkZWQuXCIsXG4gICAgICBcIlBsZWFzZSBzZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9ub24tc2Vla2FibGUtbWVkaWEgZm9yIGFzc2lzdGFuY2UuXCJcbiAgICBdLmpvaW4oYFxuYCk7XG4gICAgaWYgKHR5cGUgPT09IFwiY29uc29sZS1lcnJvclwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbnNvbGUtd2FybmluZ1wiKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBtZWRpYSAke3JlZi5zcmN9IGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy4gVGhlIHZpZGVvIHdpbGwgcmVuZGVyIGZpbmUsIGJ1dCBtYXkgbm90IHBsYXkgY29ycmVjdGx5IGluIHRoZSBSZW1vdGlvbiBTdHVkaW8gYW5kIGluIHRoZSA8UGxheWVyPi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhbiBleHBsYW5hdGlvbi5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGFscmVhZHlXYXJuZWRbcmVmLnNyY10gPSB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXBsYXliYWNrLnRzXG52YXIgdXNlTWVkaWFQbGF5YmFjayA9ICh7XG4gIG1lZGlhUmVmLFxuICBzcmMsXG4gIG1lZGlhVHlwZSxcbiAgcGxheWJhY2tSYXRlOiBsb2NhbFBsYXliYWNrUmF0ZSxcbiAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcixcbiAgYWNjZXB0YWJsZVRpbWVzaGlmdCxcbiAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICBpc1ByZW1vdW50aW5nLFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIHVzZXJQcmVmZXJyZWRWb2x1bWVcbn0pID0+IHtcbiAgY29uc3QgeyBwbGF5YmFja1JhdGU6IGdsb2JhbFBsYXliYWNrUmF0ZSB9ID0gdXNlQ29udGV4dDE4KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IFtwbGF5aW5nXSA9IHVzZVBsYXlpbmdTdGF0ZSgpO1xuICBjb25zdCBidWZmZXJpbmcgPSB1c2VDb250ZXh0MTgoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IG1lZGlhU3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IGxhc3RTZWVrRHVlVG9TaGlmdCA9IHVzZVJlZjkobnVsbCk7XG4gIGNvbnN0IGxhc3RTZWVrID0gdXNlUmVmOShudWxsKTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgaWYgKCFidWZmZXJpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VNZWRpYVBsYXliYWNrIG11c3QgYmUgdXNlZCBpbnNpZGUgYSA8QnVmZmVyaW5nQ29udGV4dD5cIik7XG4gIH1cbiAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvTWFwID0gdXNlUmVmOSh7fSk7XG4gIGNvbnN0IG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkID0gdXNlQ2FsbGJhY2s4KCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBMb2cudmVyYm9zZShsb2dMZXZlbCwgYERldGVjdGVkICR7c3JjfSBhcyBhIHZhcmlhYmxlIEZQUyB2aWRlby4gRGlzYWJsaW5nIGJ1ZmZlcmluZyB3aGlsZSBzZWVraW5nLmApO1xuICAgIGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY10gPSB0cnVlO1xuICB9LCBbbG9nTGV2ZWwsIHNyY10pO1xuICBjb25zdCBjdXJyZW50VGltZSA9IHVzZVJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSh7XG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIGxhc3RTZWVrLFxuICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG4gIH0pO1xuICBjb25zdCBkZXNpcmVkVW5jbGFtcGVkVGltZSA9IGdldE1lZGlhVGltZSh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlOiBsb2NhbFBsYXliYWNrUmF0ZSxcbiAgICBzdGFydEZyb206IC1tZWRpYVN0YXJ0c0F0LFxuICAgIGZwc1xuICB9KTtcbiAgY29uc3QgaXNNZWRpYVRhZ0J1ZmZlcmluZyA9IHVzZU1lZGlhQnVmZmVyaW5nKHtcbiAgICBlbGVtZW50OiBtZWRpYVJlZixcbiAgICBzaG91bGRCdWZmZXI6IHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgY29uc3QgeyBidWZmZXJVbnRpbEZpcnN0RnJhbWUsIGlzQnVmZmVyaW5nIH0gPSB1c2VCdWZmZXJVbnRpbEZpcnN0RnJhbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBjb25zdCBwbGF5YmFja1JhdGUgPSBsb2NhbFBsYXliYWNrUmF0ZSAqIGdsb2JhbFBsYXliYWNrUmF0ZTtcbiAgY29uc3QgYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24gPSAoKCkgPT4ge1xuICAgIGNvbnN0IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0sgPSAwLjQ1O1xuICAgIGNvbnN0IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9BTVBMSUZJQ0FUSU9OID0gREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVF9XSVRIX05PUk1BTF9QTEFZQkFDSyArIDAuMjtcbiAgICBjb25zdCBkZWZhdWx0QWNjZXB0YWJsZVRpbWVzaGlmdCA9IGdldFNob3VsZEFtcGxpZnkodXNlclByZWZlcnJlZFZvbHVtZSkgPyBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTiA6IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0s7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obWVkaWFSZWYuY3VycmVudC5kdXJhdGlvbiwgYWNjZXB0YWJsZVRpbWVzaGlmdCA/PyBkZWZhdWx0QWNjZXB0YWJsZVRpbWVzaGlmdCk7XG4gICAgfVxuICAgIHJldHVybiBhY2NlcHRhYmxlVGltZXNoaWZ0ID8/IGRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0O1xuICB9KSgpO1xuICBjb25zdCBpc1BsYXllckJ1ZmZlcmluZyA9IHVzZUlzUGxheWVyQnVmZmVyaW5nKGJ1ZmZlcmluZyk7XG4gIHVzZUVmZmVjdDExKCgpID0+IHtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudD8ucGF1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGxheWluZykge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIHRhZzogXCJwYXVzZVwiLFxuICAgICAgICBtZXNzYWdlOiBgUGF1c2luZyAke21lZGlhUmVmLmN1cnJlbnQ/LnNyY30gYmVjYXVzZSAke2lzUHJlbW91bnRpbmcgPyBcIm1lZGlhIGlzIHByZW1vdW50aW5nXCIgOiBcIlBsYXllciBpcyBub3QgcGxheWluZ1wifWAsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50Py5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IHBsYXllckJ1ZmZlcmluZ05vdFN0YXRlQnV0TGl2ZSA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudDtcbiAgICBpZiAocGxheWVyQnVmZmVyaW5nTm90U3RhdGVCdXRMaXZlICYmICFpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkKSB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgdGFnOiBcInBhdXNlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBQYXVzaW5nICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfSBiZWNhdXNlIHBsYXllciBpcyBidWZmZXJpbmcgYnV0IG1lZGlhIHRhZyBpcyBub3RgLFxuICAgICAgICBtb3VudFRpbWVcbiAgICAgIH0pO1xuICAgICAgbWVkaWFSZWYuY3VycmVudD8ucGF1c2UoKTtcbiAgICB9XG4gIH0sIFtcbiAgICBpc0J1ZmZlcmluZyxcbiAgICBpc01lZGlhVGFnQnVmZmVyaW5nLFxuICAgIGJ1ZmZlcmluZyxcbiAgICBpc1BsYXllckJ1ZmZlcmluZyxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBtb3VudFRpbWUsXG4gICAgcGxheWluZ1xuICBdKTtcbiAgdXNlRWZmZWN0MTEoKCkgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBtZWRpYVR5cGUgPT09IFwiYXVkaW9cIiA/IFwiPEF1ZGlvPlwiIDogXCI8VmlkZW8+XCI7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vICR7bWVkaWFUeXBlfSByZWYgZm91bmRgKTtcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJ3NyYycgYXR0cmlidXRlIHdhcyBwYXNzZWQgdG8gdGhlICR7dGFnTmFtZX0gZWxlbWVudC5gKTtcbiAgICB9XG4gICAgY29uc3QgcGxheWJhY2tSYXRlVG9TZXQgPSBNYXRoLm1heCgwLCBwbGF5YmFja1JhdGUpO1xuICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSAhPT0gcGxheWJhY2tSYXRlVG9TZXQpIHtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlVG9TZXQ7XG4gICAgfVxuICAgIGNvbnN0IHsgZHVyYXRpb24gfSA9IG1lZGlhUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc2hvdWxkQmVUaW1lID0gIU51bWJlci5pc05hTihkdXJhdGlvbikgJiYgTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSA/IE1hdGgubWluKGR1cmF0aW9uLCBkZXNpcmVkVW5jbGFtcGVkVGltZSkgOiBkZXNpcmVkVW5jbGFtcGVkVGltZTtcbiAgICBjb25zdCBtZWRpYVRhZ1RpbWUgPSBtZWRpYVJlZi5jdXJyZW50LmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHJ2Y1RpbWUgPSBjdXJyZW50VGltZS5jdXJyZW50ID8/IG51bGw7XG4gICAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvID0gaXNWYXJpYWJsZUZwc1ZpZGVvTWFwLmN1cnJlbnRbc3JjXTtcbiAgICBjb25zdCB0aW1lU2hpZnRNZWRpYVRhZyA9IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIG1lZGlhVGFnVGltZSk7XG4gICAgY29uc3QgdGltZVNoaWZ0UnZjVGFnID0gcnZjVGltZSA/IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIHJ2Y1RpbWUpIDogbnVsbDtcbiAgICBjb25zdCB0aW1lU2hpZnQgPSB0aW1lU2hpZnRSdmNUYWcgJiYgIWlzVmFyaWFibGVGcHNWaWRlbyA/IHRpbWVTaGlmdFJ2Y1RhZyA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGlmICh0aW1lU2hpZnQgPiBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiAmJiBsYXN0U2Vla0R1ZVRvU2hpZnQuY3VycmVudCAhPT0gc2hvdWxkQmVUaW1lKSB7XG4gICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgIG1lZGlhUmVmOiBtZWRpYVJlZi5jdXJyZW50LFxuICAgICAgICB0aW1lOiBzaG91bGRCZVRpbWUsXG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB3aHk6IGBiZWNhdXNlIHRpbWUgc2hpZnQgaXMgdG9vIGJpZy4gc2hvdWxkQmVUaW1lID0gJHtzaG91bGRCZVRpbWV9LCBpc1RpbWUgPSAke21lZGlhVGFnVGltZX0sIHJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSA9ICR7cnZjVGltZX0sIHRpbWVTaGlmdCA9ICR7dGltZVNoaWZ0fSR7aXNWYXJpYWJsZUZwc1ZpZGVvID8gXCIsIGlzVmFyaWFibGVGcHNWaWRlbyA9IHRydWVcIiA6IFwiXCJ9LCBpc1ByZW1vdW50aW5nID0gJHtpc1ByZW1vdW50aW5nfSwgcGF1c2VXaGVuQnVmZmVyaW5nID0gJHtwYXVzZVdoZW5CdWZmZXJpbmd9YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGxhc3RTZWVrRHVlVG9TaGlmdC5jdXJyZW50ID0gbGFzdFNlZWsuY3VycmVudDtcbiAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgIGlmIChwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lKHNob3VsZEJlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQucGF1c2VkKSB7XG4gICAgICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgICAgcmVhc29uOiBcInBsYXllciBpcyBwbGF5aW5nIGJ1dCBtZWRpYSB0YWcgaXMgcGF1c2VkLCBhbmQganVzdCBzZWVrZWRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IpIHtcbiAgICAgICAgd2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYShtZWRpYVJlZi5jdXJyZW50LCBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yID8gXCJjb25zb2xlLXdhcm5pbmdcIiA6IFwiY29uc29sZS1lcnJvclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Vla1RocmVzaG9sZCA9IHBsYXlpbmcgPyAwLjE1IDogMC4wMTtcbiAgICBjb25zdCBtYWtlc1NlbnNlVG9TZWVrID0gTWF0aC5hYnMobWVkaWFSZWYuY3VycmVudC5jdXJyZW50VGltZSAtIHNob3VsZEJlVGltZSkgPiBzZWVrVGhyZXNob2xkO1xuICAgIGNvbnN0IGlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQgPSBpc01lZGlhVGFnQnVmZmVyaW5nIHx8IGlzQnVmZmVyaW5nKCk7XG4gICAgY29uc3QgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nID0gYnVmZmVyaW5nLmJ1ZmZlcmluZy5jdXJyZW50ICYmICFpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkO1xuICAgIGlmICghcGxheWluZyB8fCBpc1NvbWV0aGluZ0Vsc2VCdWZmZXJpbmcpIHtcbiAgICAgIGlmIChtYWtlc1NlbnNlVG9TZWVrKSB7XG4gICAgICAgIGxhc3RTZWVrLmN1cnJlbnQgPSBzZWVrKHtcbiAgICAgICAgICBtZWRpYVJlZjogbWVkaWFSZWYuY3VycmVudCxcbiAgICAgICAgICB0aW1lOiBzaG91bGRCZVRpbWUsXG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgd2h5OiBgbm90IHBsYXlpbmcgb3Igc29tZXRoaW5nIGVsc2UgaXMgYnVmZmVyaW5nLiB0aW1lIG9mZnNldCBpcyBvdmVyIHNlZWsgdGhyZXNob2xkICgke3NlZWtUaHJlc2hvbGR9KWAsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBsYXlpbmcgfHwgYnVmZmVyaW5nLmJ1ZmZlcmluZy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhdXNlZENvbmRpdGlvbiA9IG1lZGlhUmVmLmN1cnJlbnQucGF1c2VkICYmICFtZWRpYVJlZi5jdXJyZW50LmVuZGVkO1xuICAgIGNvbnN0IGZpcnN0RnJhbWVDb25kaXRpb24gPSBhYnNvbHV0ZUZyYW1lID09PSAwO1xuICAgIGlmIChwYXVzZWRDb25kaXRpb24gfHwgZmlyc3RGcmFtZUNvbmRpdGlvbikge1xuICAgICAgY29uc3QgcmVhc29uID0gcGF1c2VkQ29uZGl0aW9uID8gXCJtZWRpYSB0YWcgaXMgcGF1c2VkXCIgOiBcImFic29sdXRlIGZyYW1lIGlzIDBcIjtcbiAgICAgIGlmIChtYWtlc1NlbnNlVG9TZWVrKSB7XG4gICAgICAgIGxhc3RTZWVrLmN1cnJlbnQgPSBzZWVrKHtcbiAgICAgICAgICBtZWRpYVJlZjogbWVkaWFSZWYuY3VycmVudCxcbiAgICAgICAgICB0aW1lOiBzaG91bGRCZVRpbWUsXG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgd2h5OiBgaXMgb3ZlciB0aW1lc2hpZnQgdGhyZXNob2xkICh0aHJlc2hvbGQgPSAke3NlZWtUaHJlc2hvbGR9KSBhbmQgJHtyZWFzb259YCxcbiAgICAgICAgICBtb3VudFRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHtcbiAgICAgICAgbWVkaWFSZWYsXG4gICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgb25BdXRvUGxheUVycm9yLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICByZWFzb246IGBwbGF5ZXIgaXMgcGxheWluZyBhbmQgJHtyZWFzb259YFxuICAgICAgfSk7XG4gICAgICBpZiAoIWlzVmFyaWFibGVGcHNWaWRlbyAmJiBwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZShzaG91bGRCZVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW1xuICAgIGFic29sdXRlRnJhbWUsXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24sXG4gICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lLFxuICAgIGJ1ZmZlcmluZy5idWZmZXJpbmcsXG4gICAgY3VycmVudFRpbWUsXG4gICAgbG9nTGV2ZWwsXG4gICAgZGVzaXJlZFVuY2xhbXBlZFRpbWUsXG4gICAgaXNCdWZmZXJpbmcsXG4gICAgaXNNZWRpYVRhZ0J1ZmZlcmluZyxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcixcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgcGxheWluZyxcbiAgICBzcmMsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIG1vdW50VGltZVxuICBdKTtcbn07XG5cbi8vIHNyYy91c2Utc3luYy12b2x1bWUtd2l0aC1tZWRpYS10YWcudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9pcy1hcHByb3hpbWF0ZWx5LXRoZS1zYW1lLnRzXG52YXIgRkxPQVRJTkdfUE9JTlRfRVJST1JfVEhSRVNIT0xEID0gMC4wMDAwMTtcbnZhciBpc0FwcHJveGltYXRlbHlUaGVTYW1lID0gKG51bTEsIG51bTIpID0+IHtcbiAgcmV0dXJuIE1hdGguYWJzKG51bTEgLSBudW0yKSA8IEZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRDtcbn07XG5cbi8vIHNyYy91c2Utc3luYy12b2x1bWUtd2l0aC1tZWRpYS10YWcudHNcbnZhciB1c2VTeW5jVm9sdW1lV2l0aE1lZGlhVGFnID0gKHtcbiAgdm9sdW1lUHJvcEZyYW1lLFxuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lLFxuICBtZWRpYVJlZlxufSkgPT4ge1xuICBjb25zdCBhZGp1c3RWb2x1bWUgPSB1c2VDYWxsYmFjazkoKCkgPT4ge1xuICAgIGlmICghbWVkaWFSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1c2VyUHJlZmVycmVkVm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgZnJhbWU6IHZvbHVtZVByb3BGcmFtZSxcbiAgICAgIHZvbHVtZSxcbiAgICAgIG1lZGlhVm9sdW1lXG4gICAgfSk7XG4gICAgaWYgKCFpc0FwcHJveGltYXRlbHlUaGVTYW1lKHVzZXJQcmVmZXJyZWRWb2x1bWUsIG1lZGlhUmVmLmN1cnJlbnQudm9sdW1lKSkge1xuICAgICAgbWVkaWFSZWYuY3VycmVudC52b2x1bWUgPSBNYXRoLm1pbih1c2VyUHJlZmVycmVkVm9sdW1lLCAxKTtcbiAgICB9XG4gIH0sIFttZWRpYVJlZiwgbWVkaWFWb2x1bWUsIHZvbHVtZSwgdm9sdW1lUHJvcEZyYW1lXSk7XG4gIHVzZUVmZmVjdDEyKCgpID0+IHtcbiAgICBhZGp1c3RWb2x1bWUoKTtcbiAgfSwgW2FkanVzdFZvbHVtZV0pO1xuICB1c2VFZmZlY3QxMigoKSA9PiB7XG4gICAgY29uc3QgbWVkaWEgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlVm9sdW1lQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgYWRqdXN0Vm9sdW1lKCk7XG4gICAgfTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKFwidm9sdW1lY2hhbmdlXCIsIGhhbmRsZVZvbHVtZUNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2b2x1bWVjaGFuZ2VcIiwgaGFuZGxlVm9sdW1lQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbYWRqdXN0Vm9sdW1lLCBtZWRpYVJlZl0pO1xufTtcblxuLy8gc3JjL3ZvbHVtZS1wb3NpdGlvbi1zdGF0ZS50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTUsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE5LCB1c2VNZW1vIGFzIHVzZU1lbW8xNyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIE1lZGlhVm9sdW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNSh7XG4gIG1lZGlhTXV0ZWQ6IGZhbHNlLFxuICBtZWRpYVZvbHVtZTogMVxufSk7XG52YXIgU2V0TWVkaWFWb2x1bWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE1KHtcbiAgc2V0TWVkaWFNdXRlZDogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIHNldE1lZGlhVm9sdW1lOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgdXNlTWVkaWFWb2x1bWVTdGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgeyBtZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dDE5KE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0TWVkaWFWb2x1bWUgfSA9IHVzZUNvbnRleHQxOShTZXRNZWRpYVZvbHVtZUNvbnRleHQpO1xuICByZXR1cm4gdXNlTWVtbzE3KCgpID0+IHtcbiAgICByZXR1cm4gW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV07XG4gIH0sIFttZWRpYVZvbHVtZSwgc2V0TWVkaWFWb2x1bWVdKTtcbn07XG52YXIgdXNlTWVkaWFNdXRlZFN0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IG1lZGlhTXV0ZWQgfSA9IHVzZUNvbnRleHQxOShNZWRpYVZvbHVtZUNvbnRleHQpO1xuICBjb25zdCB7IHNldE1lZGlhTXV0ZWQgfSA9IHVzZUNvbnRleHQxOShTZXRNZWRpYVZvbHVtZUNvbnRleHQpO1xuICByZXR1cm4gdXNlTWVtbzE3KCgpID0+IHtcbiAgICByZXR1cm4gW21lZGlhTXV0ZWQsIHNldE1lZGlhTXV0ZWRdO1xuICB9LCBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF0pO1xufTtcblxuLy8gc3JjL2F1ZGlvL3NoYXJlZC1hdWRpby10YWdzLnRzeFxuaW1wb3J0IFJlYWN0MTQsIHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTYsXG4gIGNyZWF0ZVJlZiBhcyBjcmVhdGVSZWYyLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEwLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEzLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8xOCxcbiAgdXNlUmVmIGFzIHVzZVJlZjEwLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEyXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE2LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRU1QVFlfQVVESU8gPSBcImRhdGE6YXVkaW8vbXAzO2Jhc2U2NCwvK01ZeEFBSmNBVjhBQWdBQUJuLy8vLy8vKy9nUTVCQU1BK0Q0UGcrQkFRQkFFQXdENFBnK0Q0RUJBRUFRREFQZysraFlCSC8vL2hVRlFWQlVGUkVEUU5IbWYvLy8vLy8vK01ZeEJVR2tBR0lNQUFBQVAvMjlYdDZsVXhCVFVVekxqRXdNRlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlYvK01ZeERVQUFBTklBQUFBQUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZcIjtcbnZhciBjb21wYXJlUHJvcHMgPSAob2JqMSwgb2JqMikgPT4ge1xuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iajEpLnNvcnQoKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmoyKS5zb3J0KCk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDtpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5c0FbaV0gIT09IGtleXNCW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmoxW2tleXNBW2ldXSAhPT0gb2JqMltrZXlzQltpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGRpZFByb3BDaGFuZ2UgPSAoa2V5LCBuZXdQcm9wLCBwcmV2UHJvcCkgPT4ge1xuICBpZiAoa2V5ID09PSBcInNyY1wiICYmICFwcmV2UHJvcC5zdGFydHNXaXRoKFwiZGF0YTpcIikgJiYgIW5ld1Byb3Auc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwocHJldlByb3AsIHdpbmRvdy5vcmlnaW4pLnRvU3RyaW5nKCkgIT09IG5ldyBVUkwobmV3UHJvcCwgd2luZG93Lm9yaWdpbikudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAocHJldlByb3AgPT09IG5ld1Byb3ApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIFNoYXJlZEF1ZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNihudWxsKTtcbnZhciBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuLCBudW1iZXJPZkF1ZGlvVGFncywgY29tcG9uZW50IH0pID0+IHtcbiAgY29uc3QgYXVkaW9zID0gdXNlUmVmMTAoW10pO1xuICBjb25zdCBbaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzXSA9IHVzZVN0YXRlMTIobnVtYmVyT2ZBdWRpb1RhZ3MpO1xuICBpZiAobnVtYmVyT2ZBdWRpb1RhZ3MgIT09IGluaXRpYWxOdW1iZXJPZkF1ZGlvVGFncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBudW1iZXIgb2Ygc2hhcmVkIGF1ZGlvIHRhZ3MgaGFzIGNoYW5nZWQgZHluYW1pY2FsbHkuIE9uY2UgeW91IGhhdmUgc2V0IHRoaXMgcHJvcGVydHksIHlvdSBjYW5ub3QgY2hhbmdlIGl0IGFmdGVyd2FyZHMuXCIpO1xuICB9XG4gIGNvbnN0IHJlZnMgPSB1c2VNZW1vMTgoKCkgPT4ge1xuICAgIHJldHVybiBuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwodHJ1ZSkubWFwKCgpID0+IHtcbiAgICAgIHJldHVybiB7IGlkOiBNYXRoLnJhbmRvbSgpLCByZWY6IGNyZWF0ZVJlZjIoKSB9O1xuICAgIH0pO1xuICB9LCBbbnVtYmVyT2ZBdWRpb1RhZ3NdKTtcbiAgY29uc3QgdGFrZW5BdWRpb3MgPSB1c2VSZWYxMChuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwoZmFsc2UpKTtcbiAgY29uc3QgcmVyZW5kZXJBdWRpb3MgPSB1c2VDYWxsYmFjazEwKCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHsgcmVmLCBpZCB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuaWQgPT09IGlkKTtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudC5zcmMgPSBFTVBUWV9BVURJTztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdWRpbyBkYXRhIHRvIGJlIHRoZXJlXCIpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGF0YS5wcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChkaWRQcm9wQ2hhbmdlKGtleSwgZGF0YS5wcm9wc1trZXldLCBjdXJyZW50W2tleV0pKSB7XG4gICAgICAgICAgY3VycmVudFtrZXldID0gZGF0YS5wcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3JlZnNdKTtcbiAgY29uc3QgcmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrMTAoKGF1ZCwgYXVkaW9JZCkgPT4ge1xuICAgIGNvbnN0IGZvdW5kID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuYXVkaW9JZCA9PT0gYXVkaW9JZCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0RnJlZUF1ZGlvID0gdGFrZW5BdWRpb3MuY3VycmVudC5maW5kSW5kZXgoKGEpID0+IGEgPT09IGZhbHNlKTtcbiAgICBpZiAoZmlyc3RGcmVlQXVkaW8gPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIHNpbXVsdGFuZW91c2x5IG1vdW50ICR7bnVtYmVyT2ZBdWRpb1RhZ3MgKyAxfSA8QXVkaW8gLz4gdGFncyBhdCB0aGUgc2FtZSB0aW1lLiBXaXRoIHRoZSBjdXJyZW50IHNldHRpbmdzLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgPEF1ZGlvIC8+IHRhZ3MgaXMgbGltaXRlZCB0byAke251bWJlck9mQXVkaW9UYWdzfSBhdCB0aGUgc2FtZSB0aW1lLiBSZW1vdGlvbiBwcmUtbW91bnRzIHNpbGVudCBhdWRpbyB0YWdzIHRvIGhlbHAgYXZvaWQgYnJvd3NlciBhdXRvcGxheSByZXN0cmljdGlvbnMuIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3BsYXllci9hdXRvcGxheSN1c2luZy10aGUtbnVtYmVyb2ZzaGFyZWRhdWRpb3RhZ3MtcHJvcCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gaW5jcmVhc2UgdGhpcyBsaW1pdC5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcmVmIH0gPSByZWZzW2ZpcnN0RnJlZUF1ZGlvXTtcbiAgICBjb25zdCBjbG9uZWQgPSBbLi4udGFrZW5BdWRpb3MuY3VycmVudF07XG4gICAgY2xvbmVkW2ZpcnN0RnJlZUF1ZGlvXSA9IGlkO1xuICAgIHRha2VuQXVkaW9zLmN1cnJlbnQgPSBjbG9uZWQ7XG4gICAgY29uc3QgbmV3RWxlbSA9IHtcbiAgICAgIHByb3BzOiBhdWQsXG4gICAgICBpZCxcbiAgICAgIGVsOiByZWYsXG4gICAgICBhdWRpb0lkXG4gICAgfTtcbiAgICBhdWRpb3MuY3VycmVudD8ucHVzaChuZXdFbGVtKTtcbiAgICByZXJlbmRlckF1ZGlvcygpO1xuICAgIHJldHVybiBuZXdFbGVtO1xuICB9LCBbbnVtYmVyT2ZBdWRpb1RhZ3MsIHJlZnMsIHJlcmVuZGVyQXVkaW9zXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrMTAoKGlkKSA9PiB7XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNvbnN0IGluZGV4ID0gcmVmcy5maW5kSW5kZXgoKHIpID0+IHIuaWQgPT09IGlkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXJyb3Igb2NjdXJlZCBpbiBcIik7XG4gICAgfVxuICAgIGNsb25lZFtpbmRleF0gPSBmYWxzZTtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gIH0sIFtyZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1cGRhdGVBdWRpbyA9IHVzZUNhbGxiYWNrMTAoKHtcbiAgICBhdWQsXG4gICAgYXVkaW9JZCxcbiAgICBpZFxuICB9KSA9PiB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBhdWRpb3MuY3VycmVudCA9IGF1ZGlvcy5jdXJyZW50Py5tYXAoKHByZXZBKSA9PiB7XG4gICAgICBpZiAocHJldkEuaWQgPT09IGlkKSB7XG4gICAgICAgIGNvbnN0IGlzVGhlU2FtZSA9IGNvbXBhcmVQcm9wcyhhdWQsIHByZXZBLnByb3BzKTtcbiAgICAgICAgaWYgKGlzVGhlU2FtZSkge1xuICAgICAgICAgIHJldHVybiBwcmV2QTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wcmV2QSxcbiAgICAgICAgICBwcm9wczogYXVkLFxuICAgICAgICAgIGF1ZGlvSWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2QTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICB9XG4gIH0sIFtyZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IG1vdW50VGltZSA9IHVzZU1vdW50VGltZSgpO1xuICBjb25zdCBwbGF5QWxsQXVkaW9zID0gdXNlQ2FsbGJhY2sxMCgoKSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3Ioe1xuICAgICAgICBtZWRpYVJlZjogcmVmLnJlZixcbiAgICAgICAgbWVkaWFUeXBlOiBcImF1ZGlvXCIsXG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcjogbnVsbCxcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgcmVhc29uOiBcInBsYXlpbmcgYWxsIGF1ZGlvc1wiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW2xvZ0xldmVsLCBtb3VudFRpbWUsIHJlZnNdKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vMTgoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlckF1ZGlvLFxuICAgICAgdW5yZWdpc3RlckF1ZGlvLFxuICAgICAgdXBkYXRlQXVkaW8sXG4gICAgICBwbGF5QWxsQXVkaW9zLFxuICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3NcbiAgICB9O1xuICB9LCBbXG4gICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgcGxheUFsbEF1ZGlvcyxcbiAgICByZWdpc3RlckF1ZGlvLFxuICAgIHVucmVnaXN0ZXJBdWRpbyxcbiAgICB1cGRhdGVBdWRpb1xuICBdKTtcbiAgY29uc3QgcmVzZXRBdWRpbyA9IHVzZUNhbGxiYWNrMTAoKCkgPT4ge1xuICAgIHRha2VuQXVkaW9zLmN1cnJlbnQgPSBuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwoZmFsc2UpO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gW107XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZXJlbmRlckF1ZGlvc10pO1xuICB1c2VFZmZlY3QxMygoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2V0QXVkaW8oKTtcbiAgICB9O1xuICB9LCBbY29tcG9uZW50LCByZXNldEF1ZGlvXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhTaGFyZWRBdWRpb0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlbjogW1xuICAgICAgcmVmcy5tYXAoKHsgaWQsIHJlZiB9KSA9PiB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTYoXCJhdWRpb1wiLCB7XG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIHByZWxvYWQ6IFwibWV0YWRhdGFcIixcbiAgICAgICAgICBzcmM6IEVNUFRZX0FVRElPXG4gICAgICAgIH0sIGlkKTtcbiAgICAgIH0pLFxuICAgICAgY2hpbGRyZW5cbiAgICBdXG4gIH0pO1xufTtcbnZhciB1c2VTaGFyZWRBdWRpbyA9IChhdWQsIGF1ZGlvSWQpID0+IHtcbiAgY29uc3QgY3R4ID0gdXNlQ29udGV4dDIwKFNoYXJlZEF1ZGlvQ29udGV4dCk7XG4gIGNvbnN0IFtlbGVtXSA9IHVzZVN0YXRlMTIoKCkgPT4ge1xuICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgcmV0dXJuIGN0eC5yZWdpc3RlckF1ZGlvKGF1ZCwgYXVkaW9JZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbDogUmVhY3QxNC5jcmVhdGVSZWYoKSxcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgIGF1ZGlvSWRcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgZWZmZWN0VG9Vc2UgPSBSZWFjdDE0LnVzZUluc2VydGlvbkVmZmVjdCA/PyBSZWFjdDE0LnVzZUxheW91dEVmZmVjdDtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICBjdHgudXBkYXRlQXVkaW8oeyBpZDogZWxlbS5pZCwgYXVkLCBhdWRpb0lkIH0pO1xuICAgICAgfVxuICAgIH0sIFthdWQsIGN0eCwgZWxlbS5pZCwgYXVkaW9JZF0pO1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICAgIGN0eC51bnJlZ2lzdGVyQXVkaW8oZWxlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW2N0eCwgZWxlbS5pZF0pO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUHJldmlldy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxNyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBbaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50c10gPSB1c2VTdGF0ZTEzKHByb3BzLnNob3VsZFByZU1vdW50QXVkaW9UYWdzKTtcbiAgaWYgKHByb3BzLnNob3VsZFByZU1vdW50QXVkaW9UYWdzICE9PSBpbml0aWFsU2hvdWxkUHJlTW91bnRBdWRpb0VsZW1lbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNoYW5nZSB0aGUgYmVoYXZpb3IgZm9yIHByZS1tb3VudGluZyBhdWRpbyB0YWdzIGR5bmFtaWNhbGx5LlwiKTtcbiAgfVxuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IHtcbiAgICB2b2x1bWUsXG4gICAgbXV0ZWQsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHNob3VsZFByZU1vdW50QXVkaW9UYWdzLFxuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIG5hbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAgIHN0YWNrLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW21lZGlhVm9sdW1lXSA9IHVzZU1lZGlhVm9sdW1lU3RhdGUoKTtcbiAgY29uc3QgW21lZGlhTXV0ZWRdID0gdXNlTWVkaWFNdXRlZFN0YXRlKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBoaWRkZW4gfSA9IHVzZUNvbnRleHQyMShTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gJ3NyYycgd2FzIHBhc3NlZCB0byA8QXVkaW8+LlwiKTtcbiAgfVxuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHNyYyk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyMShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBbdGltZWxpbmVJZF0gPSB1c2VTdGF0ZTEzKCgpID0+IFN0cmluZyhNYXRoLnJhbmRvbSgpKSk7XG4gIGNvbnN0IGlzU2VxdWVuY2VIaWRkZW4gPSBoaWRkZW5bdGltZWxpbmVJZF0gPz8gZmFsc2U7XG4gIGNvbnN0IHVzZXJQcmVmZXJyZWRWb2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgZnJhbWU6IHZvbHVtZVByb3BGcmFtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWVcbiAgfSk7XG4gIGNvbnN0IHByb3BzVG9QYXNzID0gdXNlTWVtbzE5KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbXV0ZWQ6IG11dGVkIHx8IG1lZGlhTXV0ZWQgfHwgaXNTZXF1ZW5jZUhpZGRlbiB8fCB1c2VyUHJlZmVycmVkVm9sdW1lIDw9IDAsXG4gICAgICBzcmM6IHByZWxvYWRlZFNyYyxcbiAgICAgIGxvb3A6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICAgIC4uLm5hdGl2ZVByb3BzXG4gICAgfTtcbiAgfSwgW1xuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBpc1NlcXVlbmNlSGlkZGVuLFxuICAgIG1lZGlhTXV0ZWQsXG4gICAgbXV0ZWQsXG4gICAgbmF0aXZlUHJvcHMsXG4gICAgcHJlbG9hZGVkU3JjLFxuICAgIHVzZXJQcmVmZXJyZWRWb2x1bWVcbiAgXSk7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzE5KCgpID0+IGBhdWRpby0ke3JhbmRvbShzcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc30tbXV0ZWQ6JHtwcm9wcy5tdXRlZH0tbG9vcDoke3Byb3BzLmxvb3B9YCwgW1xuICAgIHNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHByb3BzLm11dGVkLFxuICAgIHByb3BzLmxvb3BcbiAgXSk7XG4gIGNvbnN0IGF1ZGlvUmVmID0gdXNlU2hhcmVkQXVkaW8ocHJvcHNUb1Bhc3MsIGlkKS5lbDtcbiAgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyh7XG4gICAgdm9sdW1lUHJvcEZyYW1lLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBtZWRpYVJlZjogYXVkaW9SZWZcbiAgfSk7XG4gIHVzZU1lZGlhSW5UaW1lbGluZSh7XG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICBzcmMsXG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvXCIsXG4gICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICBkaXNwbGF5TmFtZTogbmFtZSA/PyBudWxsLFxuICAgIGlkOiB0aW1lbGluZUlkLFxuICAgIHN0YWNrOiBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIHByZW1vdW50RGlzcGxheTogbnVsbCxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG51bGwsXG4gICAgaXNQcmVtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKVxuICB9KTtcbiAgdXNlQW1wbGlmaWNhdGlvbih7XG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgIHZvbHVtZTogdXNlclByZWZlcnJlZFZvbHVtZVxuICB9KTtcbiAgdXNlTWVkaWFQbGF5YmFjayh7XG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IGZhbHNlLFxuICAgIGFjY2VwdGFibGVUaW1lc2hpZnQ6IGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgPz8gbnVsbCxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucHJlbW91bnRpbmcpLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG51bGwsXG4gICAgdXNlclByZWZlcnJlZFZvbHVtZVxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTUocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFthdWRpb1JlZl0pO1xuICBjb25zdCBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrID0gdXNlUmVmMTEob25EdXJhdGlvbik7XG4gIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudCA9IG9uRHVyYXRpb247XG4gIHVzZUVmZmVjdDE0KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGF1ZGlvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5kdXJhdGlvbikge1xuICAgICAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50Py4oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbkxvYWRlZE1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50Py4oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIH07XG4gIH0sIFthdWRpb1JlZiwgc3JjXSk7XG4gIGlmIChpbml0aWFsU2hvdWxkUHJlTW91bnRBdWRpb0VsZW1lbnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxNyhcImF1ZGlvXCIsIHtcbiAgICByZWY6IGF1ZGlvUmVmLFxuICAgIHByZWxvYWQ6IFwibWV0YWRhdGFcIixcbiAgICAuLi5wcm9wc1RvUGFzc1xuICB9KTtcbn07XG52YXIgQXVkaW9Gb3JQcmV2aWV3ID0gZm9yd2FyZFJlZjQoQXVkaW9Gb3JEZXZlbG9wbWVudEZvcndhcmRSZWZGdW5jdGlvbik7XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjUsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTUsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTYsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q1LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjEyXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZjEyKG51bGwpO1xuICBjb25zdCB7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgb25EdXJhdGlvbixcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICAgIG5hbWUsXG4gICAgb25FcnJvcixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3Qgdm9sdW1lUHJvcEZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjIoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgeyByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgfSA9IHVzZUNvbnRleHQyMihSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yMCgoKSA9PiBgYXVkaW8tJHtyYW5kb20ocHJvcHMuc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHByb3BzLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU2KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBhdWRpb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDE1KCgpID0+IHtcbiAgICBpZiAoIXByb3BzLnNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3JjIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy5tdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICB0eXBlOiBcImF1ZGlvXCIsXG4gICAgICBzcmM6IGdldEFic29sdXRlU3JjKHByb3BzLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHByb3BzLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyBudWxsLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgcHJvcHMubXV0ZWQsXG4gICAgcHJvcHMuc3JjLFxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBpZCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgdm9sdW1lLFxuICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICBmcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgcHJvcHMucGxheWJhY2tSYXRlLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb21cbiAgXSk7XG4gIGNvbnN0IHsgc3JjIH0gPSBwcm9wcztcbiAgY29uc3QgbmVlZHNUb1JlbmRlckF1ZGlvVGFnID0gcmVmIHx8IF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uO1xuICB1c2VMYXlvdXRFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbmVlZHNUb1JlbmRlckF1ZGlvVGFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyKFwiTG9hZGluZyA8QXVkaW8+IGR1cmF0aW9uIHdpdGggc3JjPVwiICsgc3JjLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGF1ZGlvUmVmO1xuICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgICAgb25EdXJhdGlvbihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICB9XG4gICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgIH07XG4gICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICBvbkR1cmF0aW9uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCk7XG4gICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgIH07XG4gIH0sIFtcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBuZWVkc1RvUmVuZGVyQXVkaW9UYWcsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzXG4gIF0pO1xuICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTgoXCJhdWRpb1wiLCB7XG4gICAgcmVmOiBhdWRpb1JlZixcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9KTtcbn07XG52YXIgQXVkaW9Gb3JSZW5kZXJpbmcgPSBmb3J3YXJkUmVmNShBdWRpb0ZvclJlbmRlcmluZ1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbi8vIHNyYy9hdWRpby9BdWRpby50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEF1ZGlvUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gdXNlQ29udGV4dDIzKFNoYXJlZEF1ZGlvQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgbmFtZSxcbiAgICBzdGFjayxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0MjMoRHVyYXRpb25zQ29udGV4dCk7XG4gIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxBdWRpbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wcy5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQocHJvcHMuc3JjKTtcbiAgY29uc3Qgb25FcnJvciA9IHVzZUNhbGxiYWNrMTEoKGUpID0+IHtcbiAgICBjb25zb2xlLmxvZyhlLmN1cnJlbnRUYXJnZXQuZXJyb3IpO1xuICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBgQ291bGQgbm90IHBsYXkgYXVkaW8gd2l0aCBzcmMgJHtwcmVsb2FkZWRTcmN9OiAke2UuY3VycmVudFRhcmdldC5lcnJvcn0uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL21lZGlhLXBsYXliYWNrLWVycm9yIGZvciBoZWxwLmA7XG4gICAgaWYgKGxvb3ApIHtcbiAgICAgIGNhbmNlbFJlbmRlcihuZXcgRXJyb3IoZXJyTWVzc2FnZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oZXJyTWVzc2FnZSk7XG4gICAgfVxuICB9LCBbbG9vcCwgcHJlbG9hZGVkU3JjXSk7XG4gIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjazExKChzcmMsIGR1cmF0aW9uSW5TZWNvbmRzKSA9PiB7XG4gICAgc2V0RHVyYXRpb25zKHsgdHlwZTogXCJnb3QtZHVyYXRpb25cIiwgZHVyYXRpb25JblNlY29uZHMsIHNyYyB9KTtcbiAgfSwgW3NldER1cmF0aW9uc10pO1xuICBjb25zdCBkdXJhdGlvbkZldGNoZWQgPSBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJlbG9hZGVkU3JjKV0gPz8gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByb3BzLnNyYyldO1xuICBpZiAobG9vcCAmJiBkdXJhdGlvbkZldGNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uRmV0Y2hlZCkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoTG9vcCwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNhbGN1bGF0ZUxvb3BEdXJhdGlvbih7XG4gICAgICAgIGVuZEF0LFxuICAgICAgICBtZWRpYUR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwcm9wcy5wbGF5YmFja1JhdGUgPz8gMSxcbiAgICAgICAgc3RhcnRGcm9tXG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gPz8gMDtcbiAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCA/PyBJbmZpbml0eTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBlbmRBdEZyYW1lTm8sXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxOShBdWRpbywge1xuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKSxcbiAgICAgICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAgIHJlZlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMsIFwiQXVkaW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIG9uRHVyYXRpb24sXG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIG9uRXJyb3IsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW9Gb3JQcmV2aWV3LCB7XG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBwcm9wcy5fcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQgPz8gZmFsc2UsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFnczogYXVkaW9Db250ZXh0ICE9PSBudWxsICYmIGF1ZGlvQ29udGV4dC5udW1iZXJPZkF1ZGlvVGFncyA+IDAsXG4gICAgLi4ucHJvcHMsXG4gICAgcmVmLFxuICAgIG9uRXJyb3IsXG4gICAgb25EdXJhdGlvbixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZVxuICB9KTtcbn07XG52YXIgQXVkaW8gPSBmb3J3YXJkUmVmNihBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKEF1ZGlvKTtcbi8vIHNyYy9Db21wb3NpdGlvbi50c3hcbmltcG9ydCB7IFN1c3BlbnNlLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE3IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5cbi8vIHNyYy9Gb2xkZXIudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNywgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjQsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNiwgdXNlTWVtbyBhcyB1c2VNZW1vMjEgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZm9sZGVyLW5hbWUudHNcbnZhciBnZXRSZWdleCA9ICgpID0+IC9eKFthLXpBLVowLTktXFx1NEUwMC1cXHU5RkZGXSkrJC9nO1xudmFyIGlzRm9sZGVyTmFtZVZhbGlkID0gKG5hbWUpID0+IG5hbWUubWF0Y2goZ2V0UmVnZXgoKSk7XG52YXIgdmFsaWRhdGVGb2xkZXJOYW1lID0gKG5hbWUpID0+IHtcbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBuYW1lIHRvIGEgPEZvbGRlciAvPi5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwibmFtZVwiIHlvdSBwYXNzIGludG8gPEZvbGRlciAvPiBtdXN0IGJlIGEgc3RyaW5nLiBHb3Q6ICR7dHlwZW9mIG5hbWV9YCk7XG4gIH1cbiAgaWYgKCFpc0ZvbGRlck5hbWVWYWxpZChuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRm9sZGVyIG5hbWUgY2FuIG9ubHkgY29udGFpbiBhLXosIEEtWiwgMC05IGFuZCAtLiBZb3UgcGFzc2VkICR7bmFtZX1gKTtcbiAgfVxufTtcbnZhciBpbnZhbGlkRm9sZGVyTmFtZUVycm9yTWVzc2FnZSA9IGBGb2xkZXIgbmFtZSBtdXN0IG1hdGNoICR7U3RyaW5nKGdldFJlZ2V4KCkpfWA7XG5cbi8vIHNyYy9Gb2xkZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjAgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGb2xkZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE3KHtcbiAgZm9sZGVyTmFtZTogbnVsbCxcbiAgcGFyZW50TmFtZTogbnVsbFxufSk7XG52YXIgRm9sZGVyID0gKHsgbmFtZSwgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBwYXJlbnQgPSB1c2VDb250ZXh0MjQoRm9sZGVyQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXIgfSA9IHVzZUNvbnRleHQyNChDb21wb3NpdGlvblNldHRlcnMpO1xuICB2YWxpZGF0ZUZvbGRlck5hbWUobmFtZSk7XG4gIGNvbnN0IHBhcmVudE5hbWVBcnIgPSBbcGFyZW50LnBhcmVudE5hbWUsIHBhcmVudC5mb2xkZXJOYW1lXS5maWx0ZXIodHJ1dGh5KTtcbiAgY29uc3QgcGFyZW50TmFtZSA9IHBhcmVudE5hbWVBcnIubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcmVudE5hbWVBcnIuam9pbihcIi9cIik7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzIxKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZGVyTmFtZTogbmFtZSxcbiAgICAgIHBhcmVudE5hbWVcbiAgICB9O1xuICB9LCBbbmFtZSwgcGFyZW50TmFtZV0pO1xuICB1c2VFZmZlY3QxNigoKSA9PiB7XG4gICAgcmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudC5mb2xkZXJOYW1lLCBwYXJlbnROYW1lLCByZWdpc3RlckZvbGRlciwgdW5yZWdpc3RlckZvbGRlcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIwKEZvbGRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9sb2FkaW5nLWluZGljYXRvci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyMSwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHJvdGF0ZSA9IHtcbiAgdHJhbnNmb3JtOiBgcm90YXRlKDkwZGVnKWBcbn07XG52YXIgSUNPTl9TSVpFID0gNDA7XG52YXIgbGFiZWwgPSB7XG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIGZvbnRTaXplOiAxNCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCJcbn07XG52YXIgY29udGFpbmVyID0ge1xuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxufTtcbnZhciBMb2FkaW5nID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMyKEFic29sdXRlRmlsbCwge1xuICAgIHN0eWxlOiBjb250YWluZXIsXG4gICAgaWQ6IFwicmVtb3Rpb24tY29tcC1sb2FkaW5nXCIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyMShcInN0eWxlXCIsIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2Nzc1wiLFxuICAgICAgICBjaGlsZHJlbjogYFxuXHRcdFx0XHRAa2V5ZnJhbWVzIGFuaW0ge1xuXHRcdFx0XHRcdGZyb20ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0byB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5OiAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCNyZW1vdGlvbi1jb21wLWxvYWRpbmcge1xuXHRcdFx0XHRcdGFuaW1hdGlvbjogYW5pbSAycztcblx0XHRcdFx0XHRhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcblx0XHRcdFx0fVxuXHRcdFx0YFxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjEoXCJzdmdcIiwge1xuICAgICAgICB3aWR0aDogSUNPTl9TSVpFLFxuICAgICAgICBoZWlnaHQ6IElDT05fU0laRSxcbiAgICAgICAgdmlld0JveDogXCItMTAwIC0xMDAgNDAwIDQwMFwiLFxuICAgICAgICBzdHlsZTogcm90YXRlLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIxKFwicGF0aFwiLCB7XG4gICAgICAgICAgZmlsbDogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlOiBcIiM1NTVcIixcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCIxMDBcIixcbiAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICAgIGQ6IFwiTSAyIDE3MiBhIDE5NiAxMDAgMCAwIDAgMTk1IDUgQSAxOTYgMjQwIDAgMCAwIDEwMCAyLjI1OSBBIDE5NiAyNDAgMCAwIDAgMiAxNzIgelwiXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcInBcIiwge1xuICAgICAgICBzdHlsZTogbGFiZWwsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgXCJSZXNvbHZpbmcgXCIsXG4gICAgICAgICAgXCI8U3VzcGVuc2U+XCIsXG4gICAgICAgICAgXCIuLi5cIlxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59O1xuXG4vLyBzcmMvcG9ydGFsLW5vZGUudHNcbnZhciBfcG9ydGFsTm9kZSA9IG51bGw7XG52YXIgcG9ydGFsTm9kZSA9ICgpID0+IHtcbiAgaWYgKCFfcG9ydGFsTm9kZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNhbGwgYW4gQVBJIHRoYXQgb25seSB3b3JrcyBpbiB0aGUgYnJvd3NlciBmcm9tIG91dHNpZGUgdGhlIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIF9wb3J0YWxOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xuICAgIGNvbnN0IGNvbnRhaW5lck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgY29udGFpbmVyTm9kZS5zdHlsZS50b3AgPSAtOTk5OTk5ICsgXCJweFwiO1xuICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQoX3BvcnRhbE5vZGUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyTm9kZSk7XG4gIH1cbiAgcmV0dXJuIF9wb3J0YWxOb2RlO1xufTtcblxuLy8gc3JjL3VzZS1sYXp5LWNvbXBvbmVudC50c1xuaW1wb3J0IFJlYWN0MTgsIHsgdXNlTWVtbyBhcyB1c2VNZW1vMjIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VMYXp5Q29tcG9uZW50ID0gKHtcbiAgY29tcFByb3BzLFxuICBjb21wb25lbnROYW1lLFxuICBub1N1c3BlbnNlXG59KSA9PiB7XG4gIGNvbnN0IGxhenkgPSB1c2VNZW1vMjIoKCkgPT4ge1xuICAgIGlmIChcImNvbXBvbmVudFwiIGluIGNvbXBQcm9wcykge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBub1N1c3BlbnNlKSB7XG4gICAgICAgIHJldHVybiBjb21wUHJvcHMuY29tcG9uZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb21wUHJvcHMuY29tcG9uZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSB2YWx1ZSBvZiBcXGB1bmRlZmluZWRcXGAgd2FzIHBhc3NlZCB0byB0aGUgXFxgY29tcG9uZW50XFxgIHByb3AuIENoZWNrIHRoZSB2YWx1ZSB5b3UgYXJlIHBhc3NpbmcgdG8gdGhlIDwke2NvbXBvbmVudE5hbWV9Lz4gY29tcG9uZW50LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0MTgubGF6eSgoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBkZWZhdWx0OiBjb21wUHJvcHMuY29tcG9uZW50IH0pKTtcbiAgICB9XG4gICAgaWYgKFwibGF6eUNvbXBvbmVudFwiIGluIGNvbXBQcm9wcyAmJiB0eXBlb2YgY29tcFByb3BzLmxhenlDb21wb25lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcFByb3BzLmxhenlDb21wb25lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHZhbHVlIG9mIFxcYHVuZGVmaW5lZFxcYCB3YXMgcGFzc2VkIHRvIHRoZSBcXGBsYXp5Q29tcG9uZW50XFxgIHByb3AuIENoZWNrIHRoZSB2YWx1ZSB5b3UgYXJlIHBhc3NpbmcgdG8gdGhlIDwke2NvbXBvbmVudE5hbWV9Lz4gY29tcG9uZW50LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0MTgubGF6eShjb21wUHJvcHMubGF6eUNvbXBvbmVudCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgZWl0aGVyICdjb21wb25lbnQnIG9yICdsYXp5Q29tcG9uZW50J1wiKTtcbiAgfSwgW2NvbXBQcm9wcy5jb21wb25lbnQsIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50XSk7XG4gIHJldHVybiBsYXp5O1xufTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtY29tcG9zaXRpb24taWQudHNcbnZhciBnZXRSZWdleDIgPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0NvbXBvc2l0aW9uSWRWYWxpZCA9IChpZCkgPT4gaWQubWF0Y2goZ2V0UmVnZXgyKCkpO1xudmFyIHZhbGlkYXRlQ29tcG9zaXRpb25JZCA9IChpZCkgPT4ge1xuICBpZiAoIWlzQ29tcG9zaXRpb25JZFZhbGlkKGlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9zaXRpb24gaWQgY2FuIG9ubHkgY29udGFpbiBhLXosIEEtWiwgMC05LCBDSksgY2hhcmFjdGVycyBhbmQgLS4gWW91IHBhc3NlZCAke2lkfWApO1xuICB9XG59O1xudmFyIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSA9IGBDb21wb3NpdGlvbiBJRCBtdXN0IG1hdGNoICR7U3RyaW5nKGdldFJlZ2V4MigpKX1gO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LXByb3BzLnRzXG52YXIgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IChkZWZhdWx0UHJvcHMsIG5hbWUsIGNvbXBvc2l0aW9uSWQpID0+IHtcbiAgaWYgKCFkZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UHJvcHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdFByb3BzfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRQcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSB3YXMgcGFzc2VkICR7Y29tcG9zaXRpb25JZCA/IGBmb3IgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgIDogXCJcIn1gKTtcbiAgfVxufTtcblxuLy8gc3JjL0NvbXBvc2l0aW9uLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRmFsbGJhY2sgPSAoKSA9PiB7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICBjb25zdCBmYWxsYmFjayA9IGRlbGF5UmVuZGVyKFwiV2FpdGluZyBmb3IgUm9vdCBjb21wb25lbnQgdG8gdW5zdXNwZW5kXCIpO1xuICAgIHJldHVybiAoKSA9PiBjb250aW51ZVJlbmRlcihmYWxsYmFjayk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIElubmVyQ29tcG9zaXRpb24gPSAoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBmcHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGlkLFxuICBkZWZhdWx0UHJvcHMsXG4gIHNjaGVtYSxcbiAgLi4uY29tcFByb3BzXG59KSA9PiB7XG4gIGNvbnN0IGNvbXBNYW5hZ2VyID0gdXNlQ29udGV4dDI1KENvbXBvc2l0aW9uU2V0dGVycyk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJDb21wb3NpdGlvbiwgdW5yZWdpc3RlckNvbXBvc2l0aW9uIH0gPSBjb21wTWFuYWdlcjtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICBjb25zdCBsYXp5ID0gdXNlTGF6eUNvbXBvbmVudCh7XG4gICAgY29tcFByb3BzLFxuICAgIGNvbXBvbmVudE5hbWU6IFwiQ29tcG9zaXRpb25cIixcbiAgICBub1N1c3BlbnNlOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBjYW5Vc2VDb21wb3NpdGlvbiA9IHVzZUNvbnRleHQyNShDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IHdhcyBtb3VudGVkIGluc2lkZSB0aGUgYGNvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSA8UGxheWVyPi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvd3JvbmctY29tcG9zaXRpb24tbW91bnQgZm9yIGhlbHAuXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IG1vdW50ZWQgaW5zaWRlIGFub3RoZXIgY29tcG9zaXRpb24uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgfVxuICBjb25zdCB7IGZvbGRlck5hbWUsIHBhcmVudE5hbWUgfSA9IHVzZUNvbnRleHQyNShGb2xkZXJDb250ZXh0KTtcbiAgdXNlRWZmZWN0MTcoKCkgPT4ge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGlkIGZvciBjb21wb3NpdGlvbiBwYXNzZWQuXCIpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUNvbXBvc2l0aW9uSWQoaWQpO1xuICAgIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMoZGVmYXVsdFByb3BzLCBcImRlZmF1bHRQcm9wc1wiLCBpZCk7XG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbih7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIGZwczogZnBzID8/IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyB1bmRlZmluZWQsXG4gICAgICBpZCxcbiAgICAgIGZvbGRlck5hbWUsXG4gICAgICBjb21wb25lbnQ6IGxhenksXG4gICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgICBub25jZSxcbiAgICAgIHBhcmVudEZvbGRlck5hbWU6IHBhcmVudE5hbWUsXG4gICAgICBzY2hlbWE6IHNjaGVtYSA/PyBudWxsLFxuICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbihpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgZnBzLFxuICAgIGhlaWdodCxcbiAgICBsYXp5LFxuICAgIGlkLFxuICAgIGZvbGRlck5hbWUsXG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHdpZHRoLFxuICAgIG5vbmNlLFxuICAgIHBhcmVudE5hbWUsXG4gICAgc2NoZW1hLFxuICAgIGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvblxuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKGlkKTtcbiAgaWYgKGVudmlyb25tZW50LmlzU3R1ZGlvICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIyKENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihTdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIGpzeDIyKExvYWRpbmcsIHt9KSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihDb21wLCB7XG4gICAgICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LnByb3BzID8/IHt9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLCBwb3J0YWxOb2RlKCkpO1xuICB9XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZyAmJiB2aWRlbyAmJiB2aWRlby5jb21wb25lbnQgPT09IGxhenkpIHtcbiAgICBjb25zdCBDb21wID0gbGF6eTtcbiAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwgfHwgcmVzb2x2ZWQudHlwZSAhPT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKC8qIEBfX1BVUkVfXyAqLyBqc3gyMihDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihGYWxsYmFjaywge30pLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKENvbXAsIHtcbiAgICAgICAgICAuLi5yZXNvbHZlZC5yZXN1bHQucHJvcHMgPz8ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksIHBvcnRhbE5vZGUoKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIENvbXBvc2l0aW9uID0gKHByb3BzMikgPT4ge1xuICBjb25zdCB7IG9ubHlSZW5kZXJDb21wb3NpdGlvbiB9ID0gdXNlQ29udGV4dDI1KENvbXBvc2l0aW9uU2V0dGVycyk7XG4gIGlmIChvbmx5UmVuZGVyQ29tcG9zaXRpb24gJiYgb25seVJlbmRlckNvbXBvc2l0aW9uICE9PSBwcm9wczIuaWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIyKElubmVyQ29tcG9zaXRpb24sIHtcbiAgICAuLi5wcm9wczJcbiAgfSk7XG59O1xuLy8gc3JjL2Jlemllci50c1xudmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNDtcbnZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG52YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xudmFyIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xudmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEpO1xudmFyIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGEoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDEgLSAzICogYUEyICsgMyAqIGFBMTtcbn1cbmZ1bmN0aW9uIGIoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhQTIgLSA2ICogYUExO1xufVxuZnVuY3Rpb24gYyhhQTEpIHtcbiAgcmV0dXJuIDMgKiBhQTE7XG59XG5mdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gKChhKGFBMSwgYUEyKSAqIGFUICsgYihhQTEsIGFBMikpICogYVQgKyBjKGFBMSkpICogYVQ7XG59XG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyICogYihhQTEsIGFBMikgKiBhVCArIGMoYUExKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSh7XG4gIGFYLFxuICBfYUEsXG4gIF9hQixcbiAgbVgxLFxuICBtWDJcbn0pIHtcbiAgbGV0IGN1cnJlbnRYO1xuICBsZXQgY3VycmVudFQ7XG4gIGxldCBpID0gMDtcbiAgbGV0IGFBID0gX2FBO1xuICBsZXQgYUIgPSBfYUI7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMjtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgX2FHdWVzc1QsIG1YMSwgbVgyKSB7XG4gIGxldCBhR3Vlc3NUID0gX2FHdWVzc1Q7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgfVxuICByZXR1cm4gYUd1ZXNzVDtcbn1cbmZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKCEobVgxID49IDAgJiYgbVgxIDw9IDEgJiYgbVgyID49IDAgJiYgbVgyIDw9IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXCIpO1xuICB9XG4gIGNvbnN0IHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgIGZvciAobGV0IGkgPSAwO2kgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoO2N1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKHtcbiAgICAgIGFYLFxuICAgICAgX2FBOiBpbnRlcnZhbFN0YXJ0LFxuICAgICAgX2FCOiBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgbVgxLFxuICAgICAgbVgyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Vhc2luZy50c1xuY2xhc3MgRWFzaW5nIHtcbiAgc3RhdGljIHN0ZXAwKG4pIHtcbiAgICByZXR1cm4gbiA+IDAgPyAxIDogMDtcbiAgfVxuICBzdGF0aWMgc3RlcDEobikge1xuICAgIHJldHVybiBuID49IDEgPyAxIDogMDtcbiAgfVxuICBzdGF0aWMgbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBzdGF0aWMgZWFzZSh0KSB7XG4gICAgcmV0dXJuIEVhc2luZy5iZXppZXIoMC40MiwgMCwgMSwgMSkodCk7XG4gIH1cbiAgc3RhdGljIHF1YWQodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuICBzdGF0aWMgY3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgc3RhdGljIHBvbHkobikge1xuICAgIHJldHVybiAodCkgPT4gdCAqKiBuO1xuICB9XG4gIHN0YXRpYyBzaW4odCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTtcbiAgfVxuICBzdGF0aWMgY2lyY2xlKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xuICB9XG4gIHN0YXRpYyBleHAodCkge1xuICAgIHJldHVybiAyICoqICgxMCAqICh0IC0gMSkpO1xuICB9XG4gIHN0YXRpYyBlbGFzdGljKGJvdW5jaW5lc3MgPSAxKSB7XG4gICAgY29uc3QgcCA9IGJvdW5jaW5lc3MgKiBNYXRoLlBJO1xuICAgIHJldHVybiAodCkgPT4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMikgKiogMyAqIE1hdGguY29zKHQgKiBwKTtcbiAgfVxuICBzdGF0aWMgYmFjayhzID0gMS43MDE1OCkge1xuICAgIHJldHVybiAodCkgPT4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfVxuICBzdGF0aWMgYm91bmNlKHQpIHtcbiAgICBpZiAodCA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDIuNzUpIHtcbiAgICAgIGNvbnN0IHQyXyA9IHQgLSAxLjUgLyAyLjc1O1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQyXyAqIHQyXyArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgMi41IC8gMi43NSkge1xuICAgICAgY29uc3QgdDJfID0gdCAtIDIuMjUgLyAyLjc1O1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQyXyAqIHQyXyArIDAuOTM3NTtcbiAgICB9XG4gICAgY29uc3QgdDIgPSB0IC0gMi42MjUgLyAyLjc1O1xuICAgIHJldHVybiA3LjU2MjUgKiB0MiAqIHQyICsgMC45ODQzNzU7XG4gIH1cbiAgc3RhdGljIGJlemllcih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBiZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICB9XG4gIHN0YXRpYyBpbihlYXNpbmcpIHtcbiAgICByZXR1cm4gZWFzaW5nO1xuICB9XG4gIHN0YXRpYyBvdXQoZWFzaW5nKSB7XG4gICAgcmV0dXJuICh0KSA9PiAxIC0gZWFzaW5nKDEgLSB0KTtcbiAgfVxuICBzdGF0aWMgaW5PdXQoZWFzaW5nKSB7XG4gICAgcmV0dXJuICh0KSA9PiB7XG4gICAgICBpZiAodCA8IDAuNSkge1xuICAgICAgICByZXR1cm4gZWFzaW5nKHQgKiAyKSAvIDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAtIGVhc2luZygoMSAtIHQpICogMikgLyAyO1xuICAgIH07XG4gIH1cbn1cbi8vIHNyYy92NS1mbGFnLnRzXG52YXIgRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPSBmYWxzZTtcblxuLy8gc3JjL2dldC1zdGF0aWMtZmlsZXMudHNcbnZhciB3YXJuZWRTZXJ2ZXIgPSBmYWxzZTtcbnZhciB3YXJuZWRQbGF5ZXIgPSBmYWxzZTtcbnZhciB3YXJuU2VydmVyT25jZSA9ICgpID0+IHtcbiAgaWYgKHdhcm5lZFNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuZWRTZXJ2ZXIgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgZ2V0U3RhdGljRmlsZXMoKSBvbiB0aGUgc2VydmVyLiBUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyLiBBbiBlbXB0eSBhcnJheSB3YXMgcmV0dXJuZWQuXCIpO1xufTtcbnZhciB3YXJuUGxheWVyT25jZSA9ICgpID0+IHtcbiAgaWYgKHdhcm5lZFBsYXllcikge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuZWRQbGF5ZXIgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgZ2V0U3RhdGljRmlsZXMoKSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gUGxheWVyLiBUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uIEFuIGVtcHR5IGFycmF5IHdhcyByZXR1cm5lZC5cIik7XG59O1xudmFyIGdldFN0YXRpY0ZpbGVzID0gKCkgPT4ge1xuICBpZiAoRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRTdGF0aWNGaWxlcygpIGhhcyBtb3ZlZCBpbnRvIHRoZSBgQHJlbW90aW9uL3N0dWRpb2AgcGFja2FnZS4gVXBkYXRlIHlvdXIgaW1wb3J0cy5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdhcm5TZXJ2ZXJPbmNlKCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICh3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIpIHtcbiAgICB3YXJuUGxheWVyT25jZSgpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlbW90aW9uX3N0YXRpY0ZpbGVzO1xufTtcbi8vIHNyYy9JRnJhbWUudHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY3LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJRnJhbWVSZWZGb3J3YXJkaW5nID0gKHtcbiAgb25Mb2FkLFxuICBvbkVycm9yLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAuLi5wcm9wczJcbn0sIHJlZikgPT4ge1xuICBjb25zdCBbaGFuZGxlXSA9IHVzZVN0YXRlMTQoKCkgPT4gZGVsYXlSZW5kZXIoYExvYWRpbmcgPElGcmFtZT4gd2l0aCBzb3VyY2UgJHtwcm9wczIuc3JjfWAsIHtcbiAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gIH0pKTtcbiAgY29uc3QgZGlkTG9hZCA9IHVzZUNhbGxiYWNrMTIoKGUpID0+IHtcbiAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgIG9uTG9hZD8uKGUpO1xuICB9LCBbaGFuZGxlLCBvbkxvYWRdKTtcbiAgY29uc3QgZGlkR2V0RXJyb3IgPSB1c2VDYWxsYmFjazEyKChlKSA9PiB7XG4gICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgaWZyYW1lOlwiLCBlLCBcIkhhbmRsZSB0aGUgZXZlbnQgdXNpbmcgdGhlIG9uRXJyb3IoKSBwcm9wIHRvIG1ha2UgdGhpcyBtZXNzYWdlIGRpc2FwcGVhci5cIik7XG4gICAgfVxuICB9LCBbaGFuZGxlLCBvbkVycm9yXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjMoXCJpZnJhbWVcIiwge1xuICAgIC4uLnByb3BzMixcbiAgICByZWYsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3IsXG4gICAgb25Mb2FkOiBkaWRMb2FkXG4gIH0pO1xufTtcbnZhciBJRnJhbWUgPSBmb3J3YXJkUmVmNyhJRnJhbWVSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9JbWcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY4LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEzLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNyxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDYsXG4gIHVzZVJlZiBhcyB1c2VSZWYxM1xufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9yQ291bnQpIHtcbiAgcmV0dXJuIDEwMDAgKiAyICoqIChlcnJvckNvdW50IC0gMSk7XG59XG52YXIgSW1nUmVmRm9yd2FyZGluZyA9ICh7XG4gIG9uRXJyb3IsXG4gIG1heFJldHJpZXMgPSAyLFxuICBzcmMsXG4gIHBhdXNlV2hlbkxvYWRpbmcsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIG9uSW1hZ2VGcmFtZSxcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgaW1hZ2VSZWYgPSB1c2VSZWYxMyhudWxsKTtcbiAgY29uc3QgZXJyb3JzID0gdXNlUmVmMTMoe30pO1xuICBjb25zdCB7IGRlbGF5UGxheWJhY2sgfSA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyNihTZXF1ZW5jZUNvbnRleHQpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJzcmNcIiBwcm9wIHdhcyBwYXNzZWQgdG8gPEltZz4uJyk7XG4gIH1cbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTcocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGltYWdlUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCByZXRyeUluID0gdXNlQ2FsbGJhY2sxMygodGltZW91dCkgPT4ge1xuICAgIGlmICghaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50U3JjID0gaW1hZ2VSZWYuY3VycmVudC5zcmM7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3U3JjID0gaW1hZ2VSZWYuY3VycmVudD8uc3JjO1xuICAgICAgaWYgKG5ld1NyYyAhPT0gY3VycmVudFNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbWFnZVJlZi5jdXJyZW50LnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgIGltYWdlUmVmLmN1cnJlbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIG5ld1NyYyk7XG4gICAgfSwgdGltZW91dCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZGlkR2V0RXJyb3IgPSB1c2VDYWxsYmFjazEzKChlKSA9PiB7XG4gICAgaWYgKCFlcnJvcnMuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID0gKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgKyAxO1xuICAgIGlmIChvbkVycm9yICYmIChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApID4gbWF4UmV0cmllcykge1xuICAgICAgb25FcnJvcihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGNvbnN0IGJhY2tvZmYgPSBleHBvbmVudGlhbEJhY2tvZmYoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKTtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGxvYWQgaW1hZ2Ugd2l0aCBzb3VyY2UgJHtpbWFnZVJlZi5jdXJyZW50Py5zcmN9LCByZXRyeWluZyBhZ2FpbiBpbiAke2JhY2tvZmZ9bXNgKTtcbiAgICAgIHJldHJ5SW4oYmFja29mZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbmNlbFJlbmRlcihcIkVycm9yIGxvYWRpbmcgaW1hZ2Ugd2l0aCBzcmM6IFwiICsgaW1hZ2VSZWYuY3VycmVudD8uc3JjKTtcbiAgfSwgW21heFJldHJpZXMsIG9uRXJyb3IsIHJldHJ5SW5dKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBpc1ByZW1vdW50aW5nID0gQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKTtcbiAgICB1c2VMYXlvdXRFZmZlY3Q2KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgaWYgKGltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbWFnZVJlZi5jdXJyZW50LnNyYyA9IGFjdHVhbFNyYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGltYWdlUmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyKFwiTG9hZGluZyA8SW1nPiB3aXRoIHNyYz1cIiArIGFjdHVhbFNyYywge1xuICAgICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB1bmJsb2NrID0gcGF1c2VXaGVuTG9hZGluZyAmJiAhaXNQcmVtb3VudGluZyA/IGRlbGF5UGxheWJhY2soKS51bmJsb2NrIDogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9O1xuICAgICAgbGV0IHVubW91bnRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHVubW91bnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IDApIHtcbiAgICAgICAgICBkZWxldGUgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXTtcbiAgICAgICAgICBjb25zb2xlLmluZm8oYFJldHJ5IHN1Y2Nlc3NmdWwgLSAke2ltYWdlUmVmLmN1cnJlbnQ/LnNyY30gaXMgbm93IGxvYWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgb25JbWFnZUZyYW1lPy4oY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmICghaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgaWYgKGN1cnJlbnQuY29tcGxldGUpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC5kZWNvZGUoKS50aGVuKG9uQ29tcGxldGUpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICBpZiAoY3VycmVudC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIGFjdHVhbFNyYyxcbiAgICAgIGRlbGF5UGxheWJhY2ssXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIHBhdXNlV2hlbkxvYWRpbmcsXG4gICAgICBpc1ByZW1vdW50aW5nLFxuICAgICAgb25JbWFnZUZyYW1lXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNChcImltZ1wiLCB7XG4gICAgLi4ucHJvcHMyLFxuICAgIHJlZjogaW1hZ2VSZWYsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3JcbiAgfSk7XG59O1xudmFyIEltZyA9IGZvcndhcmRSZWY4KEltZ1JlZkZvcndhcmRpbmcpO1xuLy8gc3JjL2ludGVybmFscy50c1xuaW1wb3J0IHsgY3JlYXRlUmVmIGFzIGNyZWF0ZVJlZjMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NvbXBvc2l0aW9uTWFuYWdlci50c3hcbmltcG9ydCBSZWFjdDIyLCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTQsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTgsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzIzLFxuICB1c2VSZWYgYXMgdXNlUmVmMTQsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTVcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBjb21wb3NpdGlvbnNSZWYgPSBSZWFjdDIyLmNyZWF0ZVJlZigpO1xudmFyIENvbXBvc2l0aW9uTWFuYWdlclByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIG51bWJlck9mQXVkaW9UYWdzLFxuICBvbmx5UmVuZGVyQ29tcG9zaXRpb24sXG4gIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhXG59KSA9PiB7XG4gIGNvbnN0IFtjb21wb3NpdGlvbnMsIHNldENvbXBvc2l0aW9uc10gPSB1c2VTdGF0ZTE1KFtdKTtcbiAgY29uc3QgY3VycmVudGNvbXBvc2l0aW9uc1JlZiA9IHVzZVJlZjE0KGNvbXBvc2l0aW9ucyk7XG4gIGNvbnN0IFtmb2xkZXJzLCBzZXRGb2xkZXJzXSA9IHVzZVN0YXRlMTUoW10pO1xuICBjb25zdCBbY2FudmFzQ29udGVudCwgc2V0Q2FudmFzQ29udGVudF0gPSB1c2VTdGF0ZTE1KG51bGwpO1xuICBjb25zdCB1cGRhdGVDb21wb3NpdGlvbnMgPSB1c2VDYWxsYmFjazE0KCh1cGRhdGVDb21wcykgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVDb21wcyhjb21wcyk7XG4gICAgICBjdXJyZW50Y29tcG9zaXRpb25zUmVmLmN1cnJlbnQgPSB1cGRhdGVkO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrMTQoKGNvbXApID0+IHtcbiAgICB1cGRhdGVDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBpZiAoY29tcHMuZmluZCgoYzIpID0+IGMyLmlkID09PSBjb21wLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGNvbXBvc2l0aW9uIHdpdGggaWQgJHtjb21wLmlkfSBhcmUgcmVnaXN0ZXJlZC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gWy4uLmNvbXBzLCBjb21wXS5zbGljZSgpLnNvcnQoKGEyLCBiMikgPT4gYTIubm9uY2UgLSBiMi5ub25jZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sIFt1cGRhdGVDb21wb3NpdGlvbnNdKTtcbiAgY29uc3QgdW5yZWdpc3RlckNvbXBvc2l0aW9uID0gdXNlQ2FsbGJhY2sxNCgoaWQpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICByZXR1cm4gY29tcHMuZmlsdGVyKChjMikgPT4gYzIuaWQgIT09IGlkKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCByZWdpc3RlckZvbGRlciA9IHVzZUNhbGxiYWNrMTQoKG5hbWUsIHBhcmVudCkgPT4ge1xuICAgIHNldEZvbGRlcnMoKHByZXZGb2xkZXJzKSA9PiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5wcmV2Rm9sZGVycyxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGFyZW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlckZvbGRlciA9IHVzZUNhbGxiYWNrMTQoKG5hbWUsIHBhcmVudCkgPT4ge1xuICAgIHNldEZvbGRlcnMoKHByZXZGb2xkZXJzKSA9PiB7XG4gICAgICByZXR1cm4gcHJldkZvbGRlcnMuZmlsdGVyKChwKSA9PiAhKHAubmFtZSA9PT0gbmFtZSAmJiBwLnBhcmVudCA9PT0gcGFyZW50KSk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTgoY29tcG9zaXRpb25zUmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbXBvc2l0aW9uczogKCkgPT4gY3VycmVudGNvbXBvc2l0aW9uc1JlZi5jdXJyZW50XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjMikgPT4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiID8gYzIuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGwpO1xuICBjb25zdCB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyA9IHVzZUNhbGxiYWNrMTQoKGlkLCBuZXdEZWZhdWx0UHJvcHMpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkID0gY29tcHMubWFwKChjMikgPT4ge1xuICAgICAgICBpZiAoYzIuaWQgPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmMyLFxuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiBuZXdEZWZhdWx0UHJvcHNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjMjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbzIzKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcG9zaXRpb25zLFxuICAgICAgZm9sZGVycyxcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgY2FudmFzQ29udGVudFxuICAgIH07XG4gIH0sIFtjb21wb3NpdGlvbnMsIGZvbGRlcnMsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCBjYW52YXNDb250ZW50XSk7XG4gIGNvbnN0IHNldHRlcnMgPSB1c2VNZW1vMjMoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgICAgcmVnaXN0ZXJGb2xkZXIsXG4gICAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgICAgc2V0Q2FudmFzQ29udGVudCxcbiAgICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzLFxuICAgICAgb25seVJlbmRlckNvbXBvc2l0aW9uXG4gICAgfTtcbiAgfSwgW1xuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgcmVnaXN0ZXJGb2xkZXIsXG4gICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHVucmVnaXN0ZXJGb2xkZXIsXG4gICAgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMsXG4gICAgb25seVJlbmRlckNvbXBvc2l0aW9uXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI1KENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShDb21wb3NpdGlvblNldHRlcnMuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBzZXR0ZXJzLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KFJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShSZXNvbHZlQ29tcG9zaXRpb25Db25maWcsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9zaXRpb24/LmNvbXBvbmVudCA/PyBudWxsLFxuICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9kZWZhdWx0LWNzcy50c1xudmFyIGV4cG9ydHNfZGVmYXVsdF9jc3MgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydHNfZGVmYXVsdF9jc3MsIHtcbiAgbWFrZURlZmF1bHRQcmV2aWV3Q1NTOiAoKSA9PiBtYWtlRGVmYXVsdFByZXZpZXdDU1MsXG4gIGluamVjdENTUzogKCkgPT4gaW5qZWN0Q1NTLFxuICBPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRTogKCkgPT4gT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUVcbn0pO1xudmFyIGluamVjdGVkID0ge307XG52YXIgaW5qZWN0Q1NTID0gKGNzcykgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmplY3RlZFtjc3NdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICBoZWFkLnByZXBlbmQoc3R5bGUpO1xuICBpbmplY3RlZFtjc3NdID0gdHJ1ZTtcbn07XG52YXIgT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUUgPSBcIl9fcmVtb3Rpb25fb2ZmdGhyZWFkdmlkZW9cIjtcbnZhciBtYWtlRGVmYXVsdFByZXZpZXdDU1MgPSAoc2NvcGUsIGJhY2tncm91bmRDb2xvcikgPT4ge1xuICBpZiAoIXNjb3BlKSB7XG4gICAgcmV0dXJuIGBcbiAgICAqIHtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgIGJvZHkge1xuICAgICAgbWFyZ2luOiAwO1xuXHQgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3J9O1xuICAgIH1cbiAgICAuJHtPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRX0ge1xuICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICR7c2NvcGV9ICoge1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgJHtzY29wZX0gKjotd2Via2l0LWZ1bGwtc2NyZWVuIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgICAke3Njb3BlfSAuJHtPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRX0ge1xuICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICB9XG4gIGA7XG59O1xuXG4vLyBzcmMvZ2V0LXByZXZpZXctZG9tLWVsZW1lbnQudHNcbnZhciBSRU1PVElPTl9TVFVESU9fQ09OVEFJTkVSX0VMRU1FTlQgPSBcIl9fcmVtb3Rpb24tc3R1ZGlvLWNvbnRhaW5lclwiO1xudmFyIGdldFByZXZpZXdEb21FbGVtZW50ID0gKCkgPT4ge1xuICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5UKTtcbn07XG5cbi8vIHNyYy9yZWdpc3Rlci1yb290LnRzXG52YXIgUm9vdCA9IG51bGw7XG52YXIgbGlzdGVuZXJzID0gW107XG52YXIgcmVnaXN0ZXJSb290ID0gKGNvbXApID0+IHtcbiAgaWYgKCFjb21wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgUmVhY3QgY29tcG9uZW50IHRvIHJlZ2lzdGVyUm9vdCgpLCBidXQgJHtKU09OLnN0cmluZ2lmeShjb21wKX0gd2FzIHBhc3NlZC5gKTtcbiAgfVxuICBpZiAoUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlZ2lzdGVyUm9vdCgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuXCIpO1xuICB9XG4gIFJvb3QgPSBjb21wO1xuICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4ge1xuICAgIGwoY29tcCk7XG4gIH0pO1xufTtcbnZhciBnZXRSb290ID0gKCkgPT4ge1xuICByZXR1cm4gUm9vdDtcbn07XG52YXIgd2FpdEZvclJvb3QgPSAoZm4pID0+IHtcbiAgaWYgKFJvb3QpIHtcbiAgICBmbihSb290KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbiAgbGlzdGVuZXJzLnB1c2goZm4pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKGwpID0+IGwgIT09IGZuKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9SZW1vdGlvblJvb3QudHN4XG5pbXBvcnQge1xuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTgsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q3LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yNCxcbiAgdXNlUmVmIGFzIHVzZVJlZjE1LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE2XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVtb3Rpb25Sb290ID0gKHtcbiAgY2hpbGRyZW4sXG4gIG51bWJlck9mQXVkaW9UYWdzLFxuICBsb2dMZXZlbCxcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YVxufSkgPT4ge1xuICBjb25zdCBbcmVtb3Rpb25Sb290SWRdID0gdXNlU3RhdGUxNigoKSA9PiBTdHJpbmcocmFuZG9tKG51bGwpKSk7XG4gIGNvbnN0IFtmcmFtZSwgc2V0RnJhbWVdID0gdXNlU3RhdGUxNigoKSA9PiBnZXRJbml0aWFsRnJhbWVTdGF0ZSgpKTtcbiAgY29uc3QgW3BsYXlpbmcsIHNldFBsYXlpbmddID0gdXNlU3RhdGUxNihmYWxzZSk7XG4gIGNvbnN0IGltcGVyYXRpdmVQbGF5aW5nID0gdXNlUmVmMTUoZmFsc2UpO1xuICBjb25zdCBbZmFzdFJlZnJlc2hlcywgc2V0RmFzdFJlZnJlc2hlc10gPSB1c2VTdGF0ZTE2KDApO1xuICBjb25zdCBbcGxheWJhY2tSYXRlLCBzZXRQbGF5YmFja1JhdGVdID0gdXNlU3RhdGUxNigxKTtcbiAgY29uc3QgYXVkaW9BbmRWaWRlb1RhZ3MgPSB1c2VSZWYxNShbXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0NygoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fc2V0RnJhbWUgPSAoZiwgY29tcG9zaXRpb24sIGF0dGVtcHQpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW90aW9uX2F0dGVtcHQgPSBhdHRlbXB0O1xuICAgICAgICBjb25zdCBpZCA9IGRlbGF5UmVuZGVyKGBTZXR0aW5nIHRoZSBjdXJyZW50IGZyYW1lIHRvICR7Zn1gKTtcbiAgICAgICAgbGV0IGFzeW5jVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2V0RnJhbWUoKHMpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50RnJhbWUgPSBzW2NvbXBvc2l0aW9uXSA/PyB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lO1xuICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgPT09IGYpIHtcbiAgICAgICAgICAgIGFzeW5jVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgICBbY29tcG9zaXRpb25dOiBmXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhc3luY1VwZGF0ZSkge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBjb250aW51ZVJlbmRlcihpZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllciA9IGZhbHNlO1xuICAgIH0sIFtdKTtcbiAgfVxuICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWluZyxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgcm9vdElkOiByZW1vdGlvblJvb3RJZCxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHNldFBsYXliYWNrUmF0ZSxcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzXG4gICAgfTtcbiAgfSwgW2ZyYW1lLCBwbGF5YmFja1JhdGUsIHBsYXlpbmcsIHJlbW90aW9uUm9vdElkXSk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbzI0KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhbWUsXG4gICAgICBzZXRQbGF5aW5nXG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBub25jZUNvbnRleHQgPSB1c2VNZW1vMjQoKCkgPT4ge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Tm9uY2U6ICgpID0+IGNvdW50ZXIrKyxcbiAgICAgIGZhc3RSZWZyZXNoZXNcbiAgICB9O1xuICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICB1c2VFZmZlY3QxOCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfbW9kdWxlX18gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfX3dlYnBhY2tfbW9kdWxlX18uaG90KSB7XG4gICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuYWRkU3RhdHVzSGFuZGxlcigoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgIHNldEZhc3RSZWZyZXNoZXMoKGkpID0+IGkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBsb2dnaW5nID0gdXNlTWVtbzI0KCgpID0+IHtcbiAgICByZXR1cm4geyBsb2dMZXZlbCwgbW91bnRUaW1lOiBEYXRlLm5vdygpIH07XG4gIH0sIFtsb2dMZXZlbF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI2KExvZ0xldmVsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBsb2dnaW5nLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoTm9uY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogbm9uY2VDb250ZXh0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRpbWVsaW5lQ29udGV4dFZhbHVlLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFNldFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KEVkaXRvclByb3BzUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoUHJlZmV0Y2hQcm92aWRlciwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KENvbXBvc2l0aW9uTWFuYWdlclByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICAgICAgICAgICAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KEJ1ZmZlcmluZ1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL3NldHVwLWVudi12YXJpYWJsZXMudHNcbnZhciBnZXRFbnZWYXJpYWJsZXMgPSAoKSA9PiB7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICBjb25zdCBwYXJhbSA9IHdpbmRvdy5yZW1vdGlvbl9lbnZWYXJpYWJsZXM7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5KU09OLnBhcnNlKHBhcmFtKSwgTk9ERV9FTlY6IFwicHJvZHVjdGlvblwiIH07XG4gIH1cbiAgaWYgKGZhbHNlKSB7fVxuICByZXR1cm4ge1xuICAgIE5PREVfRU5WOiBcInByb2R1Y3Rpb25cIlxuICB9O1xufTtcbnZhciBzZXR1cEVudlZhcmlhYmxlcyA9ICgpID0+IHtcbiAgY29uc3QgZW52ID0gZ2V0RW52VmFyaWFibGVzKCk7XG4gIGlmICghd2luZG93LnByb2Nlc3MpIHtcbiAgICB3aW5kb3cucHJvY2VzcyA9IHt9O1xuICB9XG4gIGlmICghd2luZG93LnByb2Nlc3MuZW52KSB7XG4gICAgd2luZG93LnByb2Nlc3MuZW52ID0ge307XG4gIH1cbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICB3aW5kb3cucHJvY2Vzcy5lbnZba2V5XSA9IGVudltrZXldO1xuICB9KTtcbn07XG5cbi8vIHNyYy91c2UtY3VycmVudC1zY2FsZS50c1xuaW1wb3J0IFJlYWN0MjQsIHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTggfSBmcm9tIFwicmVhY3RcIjtcbnZhciBDdXJyZW50U2NhbGVDb250ZXh0ID0gUmVhY3QyNC5jcmVhdGVDb250ZXh0KG51bGwpO1xudmFyIFByZXZpZXdTaXplQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxOCh7XG4gIHNldFNpemU6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHNpemU6IHsgc2l6ZTogXCJhdXRvXCIsIHRyYW5zbGF0aW9uOiB7IHg6IDAsIHk6IDAgfSB9XG59KTtcbnZhciBjYWxjdWxhdGVTY2FsZSA9ICh7XG4gIGNhbnZhc1NpemUsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoLFxuICBwcmV2aWV3U2l6ZVxufSkgPT4ge1xuICBjb25zdCBoZWlnaHRSYXRpbyA9IGNhbnZhc1NpemUuaGVpZ2h0IC8gY29tcG9zaXRpb25IZWlnaHQ7XG4gIGNvbnN0IHdpZHRoUmF0aW8gPSBjYW52YXNTaXplLndpZHRoIC8gY29tcG9zaXRpb25XaWR0aDtcbiAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihoZWlnaHRSYXRpbywgd2lkdGhSYXRpbyk7XG4gIHJldHVybiBwcmV2aWV3U2l6ZSA9PT0gXCJhdXRvXCIgPyByYXRpbyA6IE51bWJlcihwcmV2aWV3U2l6ZSk7XG59O1xudmFyIHVzZUN1cnJlbnRTY2FsZSA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGhhc0NvbnRleHQgPSBSZWFjdDI0LnVzZUNvbnRleHQoQ3VycmVudFNjYWxlQ29udGV4dCk7XG4gIGNvbnN0IHpvb21Db250ZXh0ID0gUmVhY3QyNC51c2VDb250ZXh0KFByZXZpZXdTaXplQ29udGV4dCk7XG4gIGNvbnN0IGNvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGlmIChoYXNDb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZyA9PT0gbnVsbCB8fCB6b29tQ29udGV4dCA9PT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zPy5kb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICBcInVzZUN1cnJlbnRTY2FsZSgpIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBhIFJlbW90aW9uIGNvbnRleHQuXCIsXG4gICAgICBcIlRoaXMgaG9vayBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBiZWluZyByZW5kZXJlZCBieSBSZW1vdGlvbi5cIixcbiAgICAgIFwiSWYgeW91IHdhbnQgdG8gdGhpcyBob29rIHRvIHJldHVybiAxIG91dHNpZGUgb2YgUmVtb3Rpb24sIHBhc3Mge2RvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb246IHRydWV9IGFzIGFuIG9wdGlvbi5cIixcbiAgICAgIFwiSWYgeW91IHRoaW5rIHlvdSBjYWxsZWQgdGhpcyBob29rIGluIGEgUmVtb3Rpb24gY29tcG9uZW50LCBtYWtlIHN1cmUgYWxsIHZlcnNpb25zIG9mIFJlbW90aW9uIGFyZSBhbGlnbmVkLlwiXG4gICAgXS5qb2luKGBcbmApKTtcbiAgfVxuICBpZiAoaGFzQ29udGV4dC50eXBlID09PSBcInNjYWxlXCIpIHtcbiAgICByZXR1cm4gaGFzQ29udGV4dC5zY2FsZTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlU2NhbGUoe1xuICAgIGNhbnZhc1NpemU6IGhhc0NvbnRleHQuY2FudmFzU2l6ZSxcbiAgICBjb21wb3NpdGlvbkhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICBjb21wb3NpdGlvbldpZHRoOiBjb25maWcud2lkdGgsXG4gICAgcHJldmlld1NpemU6IHpvb21Db250ZXh0LnNpemUuc2l6ZVxuICB9KTtcbn07XG5cbi8vIHNyYy93YXRjaC1zdGF0aWMtZmlsZS50c1xudmFyIFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUyA9IFwicmVtb3Rpb25fc3RhdGljRmlsZXNDaGFuZ2VkXCI7XG52YXIgd2F0Y2hTdGF0aWNGaWxlID0gKGZpbGVOYW1lLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3YXRjaFN0YXRpY0ZpbGUoKSBoYXMgbW92ZWQgaW50byB0aGUgYEByZW1vdGlvbi9zdHVkaW9gIHBhY2thZ2UuIFVwZGF0ZSB5b3VyIGltcG9ydHMuXCIpO1xuICB9XG4gIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIHdhdGNoU3RhdGljRmlsZSgpIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gU3R1ZGlvLlwiKTtcbiAgICByZXR1cm4geyBjYW5jZWw6ICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9IH07XG4gIH1cbiAgY29uc3Qgd2l0aG91dFN0YXRpY0Jhc2UgPSBmaWxlTmFtZS5zdGFydHNXaXRoKHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSA/IGZpbGVOYW1lLnJlcGxhY2Uod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UsIFwiXCIpIDogZmlsZU5hbWU7XG4gIGNvbnN0IHdpdGhvdXRMZWFkaW5nU2xhc2ggPSB3aXRob3V0U3RhdGljQmFzZS5zdGFydHNXaXRoKFwiL1wiKSA/IHdpdGhvdXRTdGF0aWNCYXNlLnNsaWNlKDEpIDogd2l0aG91dFN0YXRpY0Jhc2U7XG4gIGxldCBwcmV2RmlsZURhdGEgPSB3aW5kb3cucmVtb3Rpb25fc3RhdGljRmlsZXMuZmluZCgoZmlsZSkgPT4gZmlsZS5uYW1lID09PSB3aXRob3V0TGVhZGluZ1NsYXNoKTtcbiAgY29uc3QgY2hlY2tGaWxlID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3Qgc3RhdGljRmlsZXMgPSBldmVudC5kZXRhaWwuZmlsZXM7XG4gICAgY29uc3QgbmV3RmlsZURhdGEgPSBzdGF0aWNGaWxlcy5maW5kKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IHdpdGhvdXRMZWFkaW5nU2xhc2gpO1xuICAgIGlmICghbmV3RmlsZURhdGEpIHtcbiAgICAgIGlmIChwcmV2RmlsZURhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICAgIHByZXZGaWxlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZGaWxlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHByZXZGaWxlRGF0YS5sYXN0TW9kaWZpZWQgIT09IG5ld0ZpbGVEYXRhLmxhc3RNb2RpZmllZCkge1xuICAgICAgY2FsbGJhY2sobmV3RmlsZURhdGEpO1xuICAgICAgcHJldkZpbGVEYXRhID0gbmV3RmlsZURhdGE7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsIGNoZWNrRmlsZSk7XG4gIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTLCBjaGVja0ZpbGUpO1xuICB9O1xuICByZXR1cm4geyBjYW5jZWwgfTtcbn07XG5cbi8vIHNyYy93cmFwLXJlbW90aW9uLWNvbnRleHQudHN4XG5pbXBvcnQgUmVhY3QyNSwgeyB1c2VNZW1vIGFzIHVzZU1lbW8yNSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiB1c2VSZW1vdGlvbkNvbnRleHRzKCkge1xuICBjb25zdCBjb21wb3NpdGlvbk1hbmFnZXJDdHggPSBSZWFjdDI1LnVzZUNvbnRleHQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgdGltZWxpbmVDb250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChTZXRUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3Qgbm9uY2VDb250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0ID0gUmVhY3QyNS51c2VDb250ZXh0KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBwcmVsb2FkQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChQcmVsb2FkQ29udGV4dCk7XG4gIGNvbnN0IHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3Qgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCBidWZmZXJNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjUudXNlQ29udGV4dChCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICBjb25zdCBsb2dMZXZlbENvbnRleHQgPSBSZWFjdDI1LnVzZUNvbnRleHQoTG9nTGV2ZWxDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW8yNSgoKSA9PiAoe1xuICAgIGNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICB0aW1lbGluZUNvbnRleHQsXG4gICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgIHNlcXVlbmNlQ29udGV4dCxcbiAgICBub25jZUNvbnRleHQsXG4gICAgY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQsXG4gICAgcHJlbG9hZENvbnRleHQsXG4gICAgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCxcbiAgICByZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgIHNlcXVlbmNlTWFuYWdlckNvbnRleHQsXG4gICAgYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgbG9nTGV2ZWxDb250ZXh0XG4gIH0pLCBbXG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBzZXF1ZW5jZUNvbnRleHQsXG4gICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBwcmVsb2FkQ29udGV4dCxcbiAgICByZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LFxuICAgIHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsXG4gICAgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICBidWZmZXJNYW5hZ2VyQ29udGV4dCxcbiAgICBsb2dMZXZlbENvbnRleHRcbiAgXSk7XG59XG52YXIgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHRzIH0gPSBwcm9wczI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjcoTG9nTGV2ZWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRzLmxvZ0xldmVsQ29udGV4dCxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KENhblVzZVJlbW90aW9uSG9va3MuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0cy5jYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoTm9uY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0cy5ub25jZUNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoUHJlbG9hZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICB2YWx1ZTogY29udGV4dHMucHJlbG9hZENvbnRleHQsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhDb21wb3NpdGlvbk1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5jb21wb3NpdGlvbk1hbmFnZXJDdHgsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMucmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5yZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnRpbWVsaW5lQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhTZXRUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuc2V0VGltZWxpbmVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoU2VxdWVuY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuc2VxdWVuY2VDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhCdWZmZXJpbmdDb250ZXh0UmVhY3QuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLmJ1ZmZlck1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9pbnRlcm5hbHMudHNcbnZhciBjb21wb3NpdGlvblNlbGVjdG9yUmVmID0gY3JlYXRlUmVmMygpO1xudmFyIEludGVybmFscyA9IHtcbiAgdXNlVW5zYWZlVmlkZW9Db25maWcsXG4gIFRpbWVsaW5lOiBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLFxuICBDb21wb3NpdGlvbk1hbmFnZXIsXG4gIENvbXBvc2l0aW9uU2V0dGVycyxcbiAgU2VxdWVuY2VNYW5hZ2VyLFxuICBTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0LFxuICBSZW1vdGlvblJvb3QsXG4gIHVzZVZpZGVvLFxuICBnZXRSb290LFxuICB1c2VNZWRpYVZvbHVtZVN0YXRlLFxuICB1c2VNZWRpYU11dGVkU3RhdGUsXG4gIHVzZUxhenlDb21wb25lbnQsXG4gIHRydXRoeSxcbiAgU2VxdWVuY2VDb250ZXh0LFxuICB1c2VSZW1vdGlvbkNvbnRleHRzLFxuICBSZW1vdGlvbkNvbnRleHRQcm92aWRlcixcbiAgQ1NTVXRpbHM6IGV4cG9ydHNfZGVmYXVsdF9jc3MsXG4gIHNldHVwRW52VmFyaWFibGVzLFxuICBNZWRpYVZvbHVtZUNvbnRleHQsXG4gIFNldE1lZGlhVm9sdW1lQ29udGV4dCxcbiAgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0LFxuICBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlcixcbiAgaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlLFxuICBpc0NvbXBvc2l0aW9uSWRWYWxpZCxcbiAgZ2V0UHJldmlld0RvbUVsZW1lbnQsXG4gIGNvbXBvc2l0aW9uc1JlZixcbiAgcG9ydGFsTm9kZSxcbiAgd2FpdEZvclJvb3QsXG4gIENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlcixcbiAgQ2FuVXNlUmVtb3Rpb25Ib29rcyxcbiAgUHJlZmV0Y2hQcm92aWRlcixcbiAgRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyLFxuICBJc1BsYXllckNvbnRleHRQcm92aWRlcixcbiAgdXNlSXNQbGF5ZXIsXG4gIEVkaXRvclByb3BzUHJvdmlkZXIsXG4gIEVkaXRvclByb3BzQ29udGV4dCxcbiAgdXNlUHJlbG9hZCxcbiAgTm9uY2VDb250ZXh0LFxuICByZXNvbHZlVmlkZW9Db25maWcsXG4gIHVzZVJlc29sdmVkVmlkZW9Db25maWcsXG4gIHJlc29sdmVDb21wb3NpdGlvbnNSZWYsXG4gIFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyxcbiAgUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5ULFxuICBSZW5kZXJBc3NldE1hbmFnZXIsXG4gIHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gIHVzZVRpbWVsaW5lU2V0RnJhbWUsXG4gIGlzSW9zU2FmYXJpLFxuICBXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsXG4gIGFkZFNlcXVlbmNlU3RhY2tUcmFjZXMsXG4gIHVzZU1lZGlhU3RhcnRzQXQsXG4gIEJ1ZmZlcmluZ1Byb3ZpZGVyLFxuICBCdWZmZXJpbmdDb250ZXh0UmVhY3QsXG4gIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMsXG4gIEN1cnJlbnRTY2FsZUNvbnRleHQsXG4gIFByZXZpZXdTaXplQ29udGV4dCxcbiAgY2FsY3VsYXRlU2NhbGUsXG4gIGVkaXRvclByb3BzUHJvdmlkZXJSZWYsXG4gIFBST1BTX1VQREFURURfRVhURVJOQUxMWSxcbiAgdmFsaWRhdGVSZW5kZXJBc3NldCxcbiAgTG9nLFxuICBMb2dMZXZlbENvbnRleHQsXG4gIHVzZUxvZ0xldmVsLFxuICBwbGF5YmFja0xvZ2dpbmcsXG4gIHRpbWVWYWx1ZVJlZixcbiAgY29tcG9zaXRpb25TZWxlY3RvclJlZlxufTtcbi8vIHNyYy9pbnRlcnBvbGF0ZS1jb2xvcnMudHNcbnZhciBOVU1CRVIgPSBcIlstK10/XFxcXGQqXFxcXC4/XFxcXGQrXCI7XG52YXIgUEVSQ0VOVEFHRSA9IE5VTUJFUiArIFwiJVwiO1xuZnVuY3Rpb24gY2FsbCguLi5hcmdzKSB7XG4gIHJldHVybiBcIlxcXFwoXFxcXHMqKFwiICsgYXJncy5qb2luKFwiKVxcXFxzKixcXFxccyooXCIpICsgXCIpXFxcXHMqXFxcXClcIjtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXJzKCkge1xuICBjb25zdCBjYWNoZWRNYXRjaGVycyA9IHtcbiAgICByZ2I6IHVuZGVmaW5lZCxcbiAgICByZ2JhOiB1bmRlZmluZWQsXG4gICAgaHNsOiB1bmRlZmluZWQsXG4gICAgaHNsYTogdW5kZWZpbmVkLFxuICAgIGhleDM6IHVuZGVmaW5lZCxcbiAgICBoZXg0OiB1bmRlZmluZWQsXG4gICAgaGV4NTogdW5kZWZpbmVkLFxuICAgIGhleDY6IHVuZGVmaW5lZCxcbiAgICBoZXg4OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGNhY2hlZE1hdGNoZXJzLnJnYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiID0gbmV3IFJlZ0V4cChcInJnYlwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiYSA9IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbCA9IG5ldyBSZWdFeHAoXCJoc2xcIiArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaHNsYSA9IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4MyA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDQgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4NiA9IC9eIyhbMC05YS1mQS1GXXs2fSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg4ID0gL14jKFswLTlhLWZBLUZdezh9KSQvO1xuICB9XG4gIHJldHVybiBjYWNoZWRNYXRjaGVycztcbn1cbmZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHtcbiAgICB0ICs9IDE7XG4gIH1cbiAgaWYgKHQgPiAxKSB7XG4gICAgdCAtPSAxO1xuICB9XG4gIGlmICh0IDwgMSAvIDYpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgfVxuICBpZiAodCA8IDEgLyAyKSB7XG4gICAgcmV0dXJuIHE7XG4gIH1cbiAgaWYgKHQgPCAyIC8gMykge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gIGNvbnN0IGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICBjb25zdCBiMiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiMiAqIDI1NSkgPDwgODtcbn1cbmZ1bmN0aW9uIHBhcnNlMjU1KHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpbnQgPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGludCA+IDI1NSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIGludDtcbn1cbmZ1bmN0aW9uIHBhcnNlMzYwKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gKGludCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG59XG5mdW5jdGlvbiBwYXJzZTEoc3RyKSB7XG4gIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIGlmIChudW0gPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKG51bSA+IDEpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDI1NSk7XG59XG5mdW5jdGlvbiBwYXJzZVBlcmNlbnRhZ2Uoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIGlmIChpbnQgPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGludCA+IDEwMCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBpbnQgLyAxMDA7XG59XG52YXIgY29sb3JOYW1lcyA9IHtcbiAgdHJhbnNwYXJlbnQ6IDAsXG4gIGFsaWNlYmx1ZTogNDA0Mjg1MDMwMyxcbiAgYW50aXF1ZXdoaXRlOiA0MjA5NzYwMjU1LFxuICBhcXVhOiAxNjc3NzIxNSxcbiAgYXF1YW1hcmluZTogMjE0NzQ3MjYzOSxcbiAgYXp1cmU6IDQwNDMzMDkwNTUsXG4gIGJlaWdlOiA0MTI2NTMwODE1LFxuICBiaXNxdWU6IDQyOTMxODI3MTksXG4gIGJsYWNrOiAyNTUsXG4gIGJsYW5jaGVkYWxtb25kOiA0MjkzNjQzNzc1LFxuICBibHVlOiA2NTUzNSxcbiAgYmx1ZXZpb2xldDogMjMxODEzMTk2NyxcbiAgYnJvd246IDI3NzEwMDQxNTksXG4gIGJ1cmx5d29vZDogMzczNjYzNTM5MSxcbiAgYnVybnRzaWVubmE6IDM5MzQxNTAxNDMsXG4gIGNhZGV0Ymx1ZTogMTYwNDIzMTQyMyxcbiAgY2hhcnRyZXVzZTogMjE0NzQxODM2NyxcbiAgY2hvY29sYXRlOiAzNTMwMTA0NTc1LFxuICBjb3JhbDogNDI4NjUzMzg4NyxcbiAgY29ybmZsb3dlcmJsdWU6IDE2ODc1NDczOTEsXG4gIGNvcm5zaWxrOiA0Mjk0NDk5NTgzLFxuICBjcmltc29uOiAzNjkyMzEzODU1LFxuICBjeWFuOiAxNjc3NzIxNSxcbiAgZGFya2JsdWU6IDM1ODM5LFxuICBkYXJrY3lhbjogOTE0NTM0MyxcbiAgZGFya2dvbGRlbnJvZDogMzA5NTc5MjYzOSxcbiAgZGFya2dyYXk6IDI4NDY0Njg2MDcsXG4gIGRhcmtncmVlbjogNjU1Mzg1NSxcbiAgZGFya2dyZXk6IDI4NDY0Njg2MDcsXG4gIGRhcmtraGFraTogMzE4MjkxNDU1OSxcbiAgZGFya21hZ2VudGE6IDIzMzIwNjg4NjMsXG4gIGRhcmtvbGl2ZWdyZWVuOiAxNDMzMDg3OTk5LFxuICBkYXJrb3JhbmdlOiA0Mjg3MzY1Mzc1LFxuICBkYXJrb3JjaGlkOiAyNTcwMjQzMzI3LFxuICBkYXJrcmVkOiAyMzMyMDMzMjc5LFxuICBkYXJrc2FsbW9uOiAzOTE4OTUzMjE1LFxuICBkYXJrc2VhZ3JlZW46IDI0MTE0OTk1MTksXG4gIGRhcmtzbGF0ZWJsdWU6IDEyMTE5OTMwODcsXG4gIGRhcmtzbGF0ZWdyYXk6IDc5MzcyNjk3NSxcbiAgZGFya3NsYXRlZ3JleTogNzkzNzI2OTc1LFxuICBkYXJrdHVycXVvaXNlOiAxMzU1NDE3NSxcbiAgZGFya3Zpb2xldDogMjQ4MzA4MjIzOSxcbiAgZGVlcHBpbms6IDQyNzk1Mzg2ODcsXG4gIGRlZXBza3libHVlOiAxMjU4MjkxMSxcbiAgZGltZ3JheTogMTc2ODUxNjA5NSxcbiAgZGltZ3JleTogMTc2ODUxNjA5NSxcbiAgZG9kZ2VyYmx1ZTogNTEyODE5MTk5LFxuICBmaXJlYnJpY2s6IDI5ODg1ODE2MzEsXG4gIGZsb3JhbHdoaXRlOiA0Mjk0NjM1Nzc1LFxuICBmb3Jlc3RncmVlbjogNTc5NTQzODA3LFxuICBmdWNoc2lhOiA0Mjc4MjU1NjE1LFxuICBnYWluc2Jvcm86IDM3MDU0NjIwMTUsXG4gIGdob3N0d2hpdGU6IDQxNzcwNjgwMzEsXG4gIGdvbGQ6IDQyOTIyODA1NzUsXG4gIGdvbGRlbnJvZDogMzY2ODI1NDk3NSxcbiAgZ3JheTogMjE1NTkwNTI3OSxcbiAgZ3JlZW46IDgzODg4NjMsXG4gIGdyZWVueWVsbG93OiAyOTE5MTgyMzM1LFxuICBncmV5OiAyMTU1OTA1Mjc5LFxuICBob25leWRldzogNDA0MzMwNTIxNSxcbiAgaG90cGluazogNDI4NTExNzY5NSxcbiAgaW5kaWFucmVkOiAzNDQ1MzgyMzk5LFxuICBpbmRpZ286IDEyNTgzMjQ3MzUsXG4gIGl2b3J5OiA0Mjk0OTYzNDU1LFxuICBraGFraTogNDA0MTY0MTIxNSxcbiAgbGF2ZW5kZXI6IDM4NzM4OTcyMTUsXG4gIGxhdmVuZGVyYmx1c2g6IDQyOTM5ODE2OTUsXG4gIGxhd25ncmVlbjogMjA5Njg5MDExMSxcbiAgbGVtb25jaGlmZm9uOiA0Mjk0NjI2ODE1LFxuICBsaWdodGJsdWU6IDI5MTY2NzMyNzksXG4gIGxpZ2h0Y29yYWw6IDQwMzQ5NTM0NzEsXG4gIGxpZ2h0Y3lhbjogMzc3NDg3MzU5OSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDQyMTA3NDIwMTUsXG4gIGxpZ2h0Z3JheTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRncmVlbjogMjQzMTU1Mzc5MSxcbiAgbGlnaHRncmV5OiAzNTUzODc0OTQzLFxuICBsaWdodHBpbms6IDQyOTAxNjcyOTUsXG4gIGxpZ2h0c2FsbW9uOiA0Mjg4NzA3MzI3LFxuICBsaWdodHNlYWdyZWVuOiA1NDg1ODAwOTUsXG4gIGxpZ2h0c2t5Ymx1ZTogMjI3ODQ4ODgzMSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c2xhdGVncmV5OiAyMDA1NDQxMDIzLFxuICBsaWdodHN0ZWVsYmx1ZTogMjk2NTY5MjE1OSxcbiAgbGlnaHR5ZWxsb3c6IDQyOTQ5NTkzNTksXG4gIGxpbWU6IDE2NzExOTM1LFxuICBsaW1lZ3JlZW46IDg1MjMwODczNSxcbiAgbGluZW46IDQyMTAwOTE3NzUsXG4gIG1hZ2VudGE6IDQyNzgyNTU2MTUsXG4gIG1hcm9vbjogMjE0NzQ4MzkwMyxcbiAgbWVkaXVtYXF1YW1hcmluZTogMTcyNDc1NDY4NyxcbiAgbWVkaXVtYmx1ZTogNTI3MzUsXG4gIG1lZGl1bW9yY2hpZDogMzEyNjE4NzAwNyxcbiAgbWVkaXVtcHVycGxlOiAyNDczNjQ3MTAzLFxuICBtZWRpdW1zZWFncmVlbjogMTAxODM5MzA4NyxcbiAgbWVkaXVtc2xhdGVibHVlOiAyMDcwNDc0NDk1LFxuICBtZWRpdW1zcHJpbmdncmVlbjogMTY0MjM2NzksXG4gIG1lZGl1bXR1cnF1b2lzZTogMTIyMTcwOTA1NSxcbiAgbWVkaXVtdmlvbGV0cmVkOiAzMzQwMDc2NTQzLFxuICBtaWRuaWdodGJsdWU6IDQyMTA5NzcyNyxcbiAgbWludGNyZWFtOiA0MTI3MTkzODU1LFxuICBtaXN0eXJvc2U6IDQyOTMxOTAxNDMsXG4gIG1vY2Nhc2luOiA0MjkzMTc4ODc5LFxuICBuYXZham93aGl0ZTogNDI5Mjc4MzYxNSxcbiAgbmF2eTogMzMwMjMsXG4gIG9sZGxhY2U6IDQyNjA3NTExMDMsXG4gIG9saXZlOiAyMTU1ODcyNTExLFxuICBvbGl2ZWRyYWI6IDE4MDQ0Nzc0MzksXG4gIG9yYW5nZTogNDI4OTAwMzc3NSxcbiAgb3JhbmdlcmVkOiA0MjgyNzEyMzE5LFxuICBvcmNoaWQ6IDM2NjQ4MjgxNTksXG4gIHBhbGVnb2xkZW5yb2Q6IDQwMDgyMjU1MzUsXG4gIHBhbGVncmVlbjogMjU2NjYyNTUzNSxcbiAgcGFsZXR1cnF1b2lzZTogMjk1MTY3MTU1MSxcbiAgcGFsZXZpb2xldHJlZDogMzY4MTU4ODIyMyxcbiAgcGFwYXlhd2hpcDogNDI5MzkwNzk2NyxcbiAgcGVhY2hwdWZmOiA0MjkyNTI0NTQzLFxuICBwZXJ1OiAzNDQ4MDYxOTUxLFxuICBwaW5rOiA0MjkwODI1MjE1LFxuICBwbHVtOiAzNzE4MzA3MzI3LFxuICBwb3dkZXJibHVlOiAyOTY3NTI5MjE1LFxuICBwdXJwbGU6IDIxNDc1MTY2NzEsXG4gIHJlYmVjY2FwdXJwbGU6IDE3MTQ2NTc3OTEsXG4gIHJlZDogNDI3ODE5MDMzNSxcbiAgcm9zeWJyb3duOiAzMTYzNTI1MTE5LFxuICByb3lhbGJsdWU6IDEwOTc0NTgxNzUsXG4gIHNhZGRsZWJyb3duOiAyMzM2NTYwMTI3LFxuICBzYWxtb246IDQyMDI3MjIwNDcsXG4gIHNhbmR5YnJvd246IDQxMDQ0MTM0MzksXG4gIHNlYWdyZWVuOiA3ODA4ODM5NjcsXG4gIHNlYXNoZWxsOiA0Mjk0MzA3NTgzLFxuICBzaWVubmE6IDI2ODk3NDAyODcsXG4gIHNpbHZlcjogMzIzMzg1Nzc5MSxcbiAgc2t5Ymx1ZTogMjI3ODQ4NDk5MSxcbiAgc2xhdGVibHVlOiAxNzg0MzM1ODcxLFxuICBzbGF0ZWdyYXk6IDE4ODc0NzM5MTksXG4gIHNsYXRlZ3JleTogMTg4NzQ3MzkxOSxcbiAgc25vdzogNDI5NDYzODMzNSxcbiAgc3ByaW5nZ3JlZW46IDE2NzQ0NDQ3LFxuICBzdGVlbGJsdWU6IDExODI5NzExMzUsXG4gIHRhbjogMzUzNTA0NzkzNSxcbiAgdGVhbDogODQyMTYzMSxcbiAgdGhpc3RsZTogMzYzNjQ1MTU4MyxcbiAgdG9tYXRvOiA0Mjg0Njk2NTc1LFxuICB0dXJxdW9pc2U6IDEwODg0NzUzOTEsXG4gIHZpb2xldDogNDAwMTU1ODI3MSxcbiAgd2hlYXQ6IDQxMjUwMTI5OTEsXG4gIHdoaXRlOiA0Mjk0OTY3Mjk1LFxuICB3aGl0ZXNtb2tlOiA0MTI2NTM3MjE1LFxuICB5ZWxsb3c6IDQyOTQ5MDIwMTUsXG4gIHllbGxvd2dyZWVuOiAyNTk3MTM5MTk5XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgY29uc3QgbWF0Y2hlcnMgPSBnZXRNYXRjaGVycygpO1xuICBsZXQgbWF0Y2g7XG4gIGlmIChtYXRjaGVycy5oZXg2KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAoY29sb3JOYW1lc1tjb2xvcl0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb2xvck5hbWVzW2NvbG9yXTtcbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYmEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXgzKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDgpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg4LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg0KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBtYXRjaFs0XSArIG1hdGNoWzRdLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oc2wpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oc2xhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjb2xvciBzdHJpbmcgJHtjb2xvcn0gcHJvdmlkZWRgKTtcbn1cbnZhciBvcGFjaXR5ID0gKGMyKSA9PiB7XG4gIHJldHVybiAoYzIgPj4gMjQgJiAyNTUpIC8gMjU1O1xufTtcbnZhciByZWQgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDE2ICYgMjU1O1xufTtcbnZhciBncmVlbiA9IChjMikgPT4ge1xuICByZXR1cm4gYzIgPj4gOCAmIDI1NTtcbn07XG52YXIgYmx1ZSA9IChjMikgPT4ge1xuICByZXR1cm4gYzIgJiAyNTU7XG59O1xudmFyIHJnYmFDb2xvciA9IChyLCBnLCBiMiwgYWxwaGEpID0+IHtcbiAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7YjJ9LCAke2FscGhhfSlgO1xufTtcbmZ1bmN0aW9uIHByb2Nlc3NDb2xvcihjb2xvcikge1xuICBjb25zdCBub3JtYWxpemVkQ29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gIHJldHVybiAobm9ybWFsaXplZENvbG9yIDw8IDI0IHwgbm9ybWFsaXplZENvbG9yID4+PiA4KSA+Pj4gMDtcbn1cbnZhciBpbnRlcnBvbGF0ZUNvbG9yc1JHQiA9ICh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzKSA9PiB7XG4gIGNvbnN0IFtyLCBnLCBiMiwgYTJdID0gW3JlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHldLm1hcCgoZikgPT4ge1xuICAgIGNvbnN0IHVucm91bmRlZCA9IGludGVycG9sYXRlKHZhbHVlLCBpbnB1dFJhbmdlLCBjb2xvcnMubWFwKChjMikgPT4gZihjMikpLCB7XG4gICAgICBleHRyYXBvbGF0ZUxlZnQ6IFwiY2xhbXBcIixcbiAgICAgIGV4dHJhcG9sYXRlUmlnaHQ6IFwiY2xhbXBcIlxuICAgIH0pO1xuICAgIGlmIChmID09PSBvcGFjaXR5KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHVucm91bmRlZC50b0ZpeGVkKDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQodW5yb3VuZGVkKTtcbiAgfSk7XG4gIHJldHVybiByZ2JhQ29sb3IociwgZywgYjIsIGEyKTtcbn07XG52YXIgaW50ZXJwb2xhdGVDb2xvcnMgPSAoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlKSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvdXRwdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIgdmFsdWVzIHByb3ZpZGVkKSBhbmQgb3V0cHV0UmFuZ2UgKFwiICsgb3V0cHV0UmFuZ2UubGVuZ3RoICsgXCIgdmFsdWVzIHByb3ZpZGVkKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NlZE91dHB1dFJhbmdlID0gb3V0cHV0UmFuZ2UubWFwKChjMikgPT4gcHJvY2Vzc0NvbG9yKGMyKSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUNvbG9yc1JHQihpbnB1dCwgaW5wdXRSYW5nZSwgcHJvY2Vzc2VkT3V0cHV0UmFuZ2UpO1xufTtcbi8vIHNyYy92YWxpZGF0ZS1mcmFtZS50c1xudmFyIHZhbGlkYXRlRnJhbWUgPSAoe1xuICBhbGxvd0Zsb2F0cyxcbiAgZHVyYXRpb25JbkZyYW1lcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBmcmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IG1pc3NpbmcgZm9yIHBhcmFtZXRlciBcImZyYW1lXCJgKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgcGFzc2VkIGZvciBcImZyYW1lXCIgaXMgbm90IGEgbnVtYmVyOiAke2ZyYW1lfWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBGcmFtZSAke2ZyYW1lfSBpcyBub3QgZmluaXRlYCk7XG4gIH1cbiAgaWYgKGZyYW1lICUgMSAhPT0gMCAmJiAhYWxsb3dGbG9hdHMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQXJndW1lbnQgZm9yIGZyYW1lIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2ZyYW1lfWApO1xuICB9XG4gIGlmIChmcmFtZSA8IDAgJiYgZnJhbWUgPCAtZHVyYXRpb25JbkZyYW1lcykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGxvd2VzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAkey1kdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChmcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgaGlnaGVzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAke2R1cmF0aW9uSW5GcmFtZXMgLSAxfWApO1xuICB9XG59O1xuXG4vLyBzcmMvdmlkZW8vb2ZmdGhyZWFkLXZpZGVvLXNvdXJjZS50c1xudmFyIGdldE9mZnRocmVhZFZpZGVvU291cmNlID0gKHtcbiAgc3JjLFxuICB0cmFuc3BhcmVudCxcbiAgY3VycmVudFRpbWUsXG4gIHRvbmVNYXBwZWRcbn0pID0+IHtcbiAgcmV0dXJuIGBodHRwOi8vbG9jYWxob3N0OiR7d2luZG93LnJlbW90aW9uX3Byb3h5UG9ydH0vcHJveHk/c3JjPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldEFic29sdXRlU3JjKHNyYykpfSZ0aW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGN1cnJlbnRUaW1lKX0mdHJhbnNwYXJlbnQ9JHtTdHJpbmcodHJhbnNwYXJlbnQpfSZ0b25lTWFwcGVkPSR7U3RyaW5nKHRvbmVNYXBwZWQpfWA7XG59O1xuLy8gc3JjL3Nlcmllcy9pbmRleC50c3hcbmltcG9ydCB7IENoaWxkcmVuLCBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY5LCB1c2VNZW1vIGFzIHVzZU1lbW8yNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvc2VyaWVzL2ZsYXR0ZW4tY2hpbGRyZW4udHN4XG5pbXBvcnQgUmVhY3QyNiBmcm9tIFwicmVhY3RcIjtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSAoY2hpbGRyZW4pID0+IHtcbiAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0MjYuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZHJlbkFycmF5LnJlZHVjZSgoZmxhdENoaWxkcmVuLCBjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBSZWFjdDI2LkZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZmxhdENoaWxkcmVuLmNvbmNhdChmbGF0dGVuQ2hpbGRyZW4oY2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgZmxhdENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiBmbGF0Q2hpbGRyZW47XG4gIH0sIFtdKTtcbn07XG5cbi8vIHNyYy9zZXJpZXMvaXMtaW5zaWRlLXNlcmllcy50c3hcbmltcG9ydCBSZWFjdDI3LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJc0luc2lkZVNlcmllc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTkoZmFsc2UpO1xudmFyIElzSW5zaWRlU2VyaWVzQ29udGFpbmVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI4KElzSW5zaWRlU2VyaWVzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciBJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI4KElzSW5zaWRlU2VyaWVzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMgPSAoKSA9PiB7XG4gIGNvbnN0IGlzSW5zaWRlU2VyaWVzID0gUmVhY3QyNy51c2VDb250ZXh0KElzSW5zaWRlU2VyaWVzQ29udGV4dCk7XG4gIGlmICghaXNJbnNpZGVTZXJpZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGNvbXBvbmVudCBtdXN0IGJlIGluc2lkZSBhIDxTZXJpZXMgLz4gY29tcG9uZW50LlwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Nlcmllcy9pbmRleC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNlcmllc1NlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHsgY2hpbGRyZW4gfSwgX3JlZikgPT4ge1xuICB1c2VSZXF1aXJlVG9CZUluc2lkZVNlcmllcygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KElzTm90SW5zaWRlU2VyaWVzUHJvdmlkZXIsIHtcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgU2VyaWVzU2VxdWVuY2UgPSBmb3J3YXJkUmVmOShTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgU2VyaWVzID0gKHByb3BzMikgPT4ge1xuICBjb25zdCBjaGlsZHJlblZhbHVlID0gdXNlTWVtbzI2KCgpID0+IHtcbiAgICBsZXQgc3RhcnRGcmFtZSA9IDA7XG4gICAgY29uc3QgZmxhdHRlbmVkQ2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMyLmNoaWxkcmVuKTtcbiAgICByZXR1cm4gQ2hpbGRyZW4ubWFwKGZsYXR0ZW5lZENoaWxkcmVuLCAoY2hpbGQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RlZENoaWxkID0gY2hpbGQ7XG4gICAgICBpZiAodHlwZW9mIGNhc3RlZENoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChjYXN0ZWRDaGlsZC50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgPFNlcmllcyAvPiBjb21wb25lbnQgb25seSBhY2NlcHRzIGEgbGlzdCBvZiA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudHMgYXMgaXRzIGNoaWxkcmVuLCBidXQgeW91IHBhc3NlZCBhIHN0cmluZyBcIiR7Y2FzdGVkQ2hpbGR9XCJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXN0ZWRDaGlsZC50eXBlICE9PSBTZXJpZXNTZXF1ZW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgPFNlcmllcyAvPiBjb21wb25lbnQgb25seSBhY2NlcHRzIGEgbGlzdCBvZiA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudHMgYXMgaXRzIGNoaWxkcmVuLCBidXQgZ290ICR7Y2FzdGVkQ2hpbGR9IGluc3RlYWRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IGBpbmRleCA9ICR7aX0sIGR1cmF0aW9uID0gJHtjYXN0ZWRDaGlsZC5wcm9wcy5kdXJhdGlvbkluRnJhbWVzfWA7XG4gICAgICBpZiAoIWNhc3RlZENoaWxkPy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50ICgke2RlYnVnSW5mb30pIHdhcyBkZXRlY3RlZCB0byBub3QgaGF2ZSBhbnkgY2hpbGRyZW4uIERlbGV0ZSBpdCB0byBmaXggdGhpcyBlcnJvci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGR1cmF0aW9uSW5GcmFtZXNQcm9wID0gY2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgY2hpbGRyZW46IF9jaGlsZHJlbixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgLi4ucGFzc2VkUHJvcHNcbiAgICAgIH0gPSBjYXN0ZWRDaGlsZC5wcm9wcztcbiAgICAgIGlmIChpICE9PSBmbGF0dGVuZWRDaGlsZHJlbi5sZW5ndGggLSAxIHx8IGR1cmF0aW9uSW5GcmFtZXNQcm9wICE9PSBJbmZpbml0eSkge1xuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lc1Byb3AsIHtcbiAgICAgICAgICBjb21wb25lbnQ6IGBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50YCxcbiAgICAgICAgICBhbGxvd0Zsb2F0czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNldCA9IGNhc3RlZENoaWxkLnByb3BzLm9mZnNldCA/PyAwO1xuICAgICAgaWYgKE51bWJlci5pc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgTmFOICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtvZmZzZXR9ICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCAlIDEgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7b2Zmc2V0fSAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRTdGFydEZyYW1lID0gc3RhcnRGcmFtZSArIG9mZnNldDtcbiAgICAgIHN0YXJ0RnJhbWUgKz0gZHVyYXRpb25JbkZyYW1lc1Byb3AgKyBvZmZzZXQ7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KFNlcXVlbmNlLCB7XG4gICAgICAgIG5hbWU6IG5hbWUgfHwgXCI8U2VyaWVzLlNlcXVlbmNlPlwiLFxuICAgICAgICBmcm9tOiBjdXJyZW50U3RhcnRGcmFtZSxcbiAgICAgICAgZHVyYXRpb25JbkZyYW1lczogZHVyYXRpb25JbkZyYW1lc1Byb3AsXG4gICAgICAgIC4uLnBhc3NlZFByb3BzLFxuICAgICAgICByZWY6IGNhc3RlZENoaWxkLnJlZixcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3Byb3BzMi5jaGlsZHJlbl0pO1xuICBpZiAoRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KElzSW5zaWRlU2VyaWVzQ29udGFpbmVyLCB7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI5KFNlcXVlbmNlLCB7XG4gICAgICAgIC4uLnByb3BzMixcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuVmFsdWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOShJc0luc2lkZVNlcmllc0NvbnRhaW5lciwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlblZhbHVlXG4gIH0pO1xufTtcblNlcmllcy5TZXF1ZW5jZSA9IFNlcmllc1NlcXVlbmNlO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhTZXJpZXNTZXF1ZW5jZSk7XG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0aW9uLXNwcmluZy1kdXJhdGlvbi50c1xudmFyIHZhbGlkYXRlU3ByaW5nRHVyYXRpb24gPSAoZHVyKSA9PiB7XG4gIGlmICh0eXBlb2YgZHVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBhIFwibnVtYmVyXCIgYnV0IGlzIFwiJHt0eXBlb2YgZHVyfVwiYCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihkdXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgaXMgTmFOLCB3aGljaCBpdCBtdXN0IG5vdCBiZScpO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICcgKyBkdXIpO1xuICB9XG4gIGlmIChkdXIgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBpcyAnICsgZHVyKTtcbiAgfVxufTtcblxuLy8gc3JjL3NwcmluZy9zcHJpbmctdXRpbHMudHNcbnZhciBkZWZhdWx0U3ByaW5nQ29uZmlnID0ge1xuICBkYW1waW5nOiAxMCxcbiAgbWFzczogMSxcbiAgc3RpZmZuZXNzOiAxMDAsXG4gIG92ZXJzaG9vdENsYW1waW5nOiBmYWxzZVxufTtcbnZhciBhZHZhbmNlQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGFkdmFuY2Uoe1xuICBhbmltYXRpb24sXG4gIG5vdyxcbiAgY29uZmlnXG59KSB7XG4gIGNvbnN0IHsgdG9WYWx1ZSwgbGFzdFRpbWVzdGFtcCwgY3VycmVudCwgdmVsb2NpdHkgfSA9IGFuaW1hdGlvbjtcbiAgY29uc3QgZGVsdGFUaW1lID0gTWF0aC5taW4obm93IC0gbGFzdFRpbWVzdGFtcCwgNjQpO1xuICBpZiAoY29uZmlnLmRhbXBpbmcgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNwcmluZyBkYW1waW5nIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIG90aGVyd2lzZSB0aGUgc3ByaW5nKCkgYW5pbWF0aW9uIHdpbGwgbmV2ZXIgZW5kLCBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3AuXCIpO1xuICB9XG4gIGNvbnN0IGMyID0gY29uZmlnLmRhbXBpbmc7XG4gIGNvbnN0IG0gPSBjb25maWcubWFzcztcbiAgY29uc3QgayA9IGNvbmZpZy5zdGlmZm5lc3M7XG4gIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgIHRvVmFsdWUsXG4gICAgbGFzdFRpbWVzdGFtcCxcbiAgICBjdXJyZW50LFxuICAgIHZlbG9jaXR5LFxuICAgIGMyLFxuICAgIG0sXG4gICAgayxcbiAgICBub3dcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGFkdmFuY2VDYWNoZVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm4gYWR2YW5jZUNhY2hlW2NhY2hlS2V5XTtcbiAgfVxuICBjb25zdCB2MCA9IC12ZWxvY2l0eTtcbiAgY29uc3QgeDAgPSB0b1ZhbHVlIC0gY3VycmVudDtcbiAgY29uc3QgemV0YSA9IGMyIC8gKDIgKiBNYXRoLnNxcnQoayAqIG0pKTtcbiAgY29uc3Qgb21lZ2EwID0gTWF0aC5zcXJ0KGsgLyBtKTtcbiAgY29uc3Qgb21lZ2ExID0gb21lZ2EwICogTWF0aC5zcXJ0KDEgLSB6ZXRhICoqIDIpO1xuICBjb25zdCB0ID0gZGVsdGFUaW1lIC8gMTAwMDtcbiAgY29uc3Qgc2luMSA9IE1hdGguc2luKG9tZWdhMSAqIHQpO1xuICBjb25zdCBjb3MxID0gTWF0aC5jb3Mob21lZ2ExICogdCk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkRW52ZWxvcGUgPSBNYXRoLmV4cCgtemV0YSAqIG9tZWdhMCAqIHQpO1xuICBjb25zdCB1bmRlckRhbXBlZEZyYWcxID0gdW5kZXJEYW1wZWRFbnZlbG9wZSAqIChzaW4xICogKCh2MCArIHpldGEgKiBvbWVnYTAgKiB4MCkgLyBvbWVnYTEpICsgeDAgKiBjb3MxKTtcbiAgY29uc3QgdW5kZXJEYW1wZWRQb3NpdGlvbiA9IHRvVmFsdWUgLSB1bmRlckRhbXBlZEZyYWcxO1xuICBjb25zdCB1bmRlckRhbXBlZFZlbG9jaXR5ID0gemV0YSAqIG9tZWdhMCAqIHVuZGVyRGFtcGVkRnJhZzEgLSB1bmRlckRhbXBlZEVudmVsb3BlICogKGNvczEgKiAodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC0gb21lZ2ExICogeDAgKiBzaW4xKTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZEVudmVsb3BlID0gTWF0aC5leHAoLW9tZWdhMCAqIHQpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gY3JpdGljYWxseURhbXBlZEVudmVsb3BlICogKHgwICsgKHYwICsgb21lZ2EwICogeDApICogdCk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eSA9IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSAqICh2MCAqICh0ICogb21lZ2EwIC0gMSkgKyB0ICogeDAgKiBvbWVnYTAgKiBvbWVnYTApO1xuICBjb25zdCBhbmltYXRpb25Ob2RlID0ge1xuICAgIHRvVmFsdWUsXG4gICAgcHJldlBvc2l0aW9uOiBjdXJyZW50LFxuICAgIGxhc3RUaW1lc3RhbXA6IG5vdyxcbiAgICBjdXJyZW50OiB6ZXRhIDwgMSA/IHVuZGVyRGFtcGVkUG9zaXRpb24gOiBjcml0aWNhbGx5RGFtcGVkUG9zaXRpb24sXG4gICAgdmVsb2NpdHk6IHpldGEgPCAxID8gdW5kZXJEYW1wZWRWZWxvY2l0eSA6IGNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eVxuICB9O1xuICBhZHZhbmNlQ2FjaGVbY2FjaGVLZXldID0gYW5pbWF0aW9uTm9kZTtcbiAgcmV0dXJuIGFuaW1hdGlvbk5vZGU7XG59XG52YXIgY2FsY3VsYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICBmcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fVxufSkge1xuICBjb25zdCBmcm9tID0gMDtcbiAgY29uc3QgdG8gPSAxO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICBmcmFtZSxcbiAgICBmcHMsXG4gICAgY29uZmlnLmRhbXBpbmcsXG4gICAgY29uZmlnLm1hc3MsXG4gICAgY29uZmlnLm92ZXJzaG9vdENsYW1waW5nLFxuICAgIGNvbmZpZy5zdGlmZm5lc3NcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldO1xuICB9XG4gIGxldCBhbmltYXRpb24gPSB7XG4gICAgbGFzdFRpbWVzdGFtcDogMCxcbiAgICBjdXJyZW50OiBmcm9tLFxuICAgIHRvVmFsdWU6IHRvLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIHByZXZQb3NpdGlvbjogMFxuICB9O1xuICBjb25zdCBmcmFtZUNsYW1wZWQgPSBNYXRoLm1heCgwLCBmcmFtZSk7XG4gIGNvbnN0IHVuZXZlblJlc3QgPSBmcmFtZUNsYW1wZWQgJSAxO1xuICBmb3IgKGxldCBmID0gMDtmIDw9IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKTsgZisrKSB7XG4gICAgaWYgKGYgPT09IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKSkge1xuICAgICAgZiArPSB1bmV2ZW5SZXN0O1xuICAgIH1cbiAgICBjb25zdCB0aW1lID0gZiAvIGZwcyAqIDEwMDA7XG4gICAgYW5pbWF0aW9uID0gYWR2YW5jZSh7XG4gICAgICBhbmltYXRpb24sXG4gICAgICBub3c6IHRpbWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4uZGVmYXVsdFNwcmluZ0NvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRpb25DYWNoZVtjYWNoZUtleV0gPSBhbmltYXRpb247XG4gIHJldHVybiBhbmltYXRpb247XG59XG5cbi8vIHNyYy9zcHJpbmcvbWVhc3VyZS1zcHJpbmcudHNcbnZhciBjYWNoZSA9IG5ldyBNYXA7XG5mdW5jdGlvbiBtZWFzdXJlU3ByaW5nKHtcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgdGhyZXNob2xkID0gMC4wMDVcbn0pIHtcbiAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aHJlc2hvbGQgbXVzdCBiZSBhIG51bWJlciwgZ290ICR7dGhyZXNob2xkfSBvZiB0eXBlICR7dHlwZW9mIHRocmVzaG9sZH1gKTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSAwKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPT09IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNOYU4odGhyZXNob2xkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaHJlc2hvbGQgaXMgTmFOXCIpO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHRocmVzaG9sZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIG5vdCBmaW5pdGVcIik7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIGJlbG93IDBcIik7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgZnBzLFxuICAgIGNvbmZpZy5kYW1waW5nLFxuICAgIGNvbmZpZy5tYXNzLFxuICAgIGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyxcbiAgICBjb25maWcuc3RpZmZuZXNzLFxuICAgIHRocmVzaG9sZFxuICBdLmpvaW4oXCItXCIpO1xuICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byB0aGUgbWVhc3VyZVNwcmluZygpIGZ1bmN0aW9uXCIsIGZhbHNlKTtcbiAgbGV0IGZyYW1lID0gMDtcbiAgbGV0IGZpbmlzaGVkRnJhbWUgPSAwO1xuICBjb25zdCBjYWxjID0gKCkgPT4ge1xuICAgIHJldHVybiBzcHJpbmdDYWxjdWxhdGlvbih7XG4gICAgICBmcHMsXG4gICAgICBmcmFtZSxcbiAgICAgIGNvbmZpZ1xuICAgIH0pO1xuICB9O1xuICBsZXQgYW5pbWF0aW9uID0gY2FsYygpO1xuICBjb25zdCBjYWxjRGlmZmVyZW5jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW5pbWF0aW9uLmN1cnJlbnQgLSBhbmltYXRpb24udG9WYWx1ZSk7XG4gIH07XG4gIGxldCBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgd2hpbGUgKGRpZmZlcmVuY2UgPj0gdGhyZXNob2xkKSB7XG4gICAgZnJhbWUrKztcbiAgICBhbmltYXRpb24gPSBjYWxjKCk7XG4gICAgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gIH1cbiAgZmluaXNoZWRGcmFtZSA9IGZyYW1lO1xuICBmb3IgKGxldCBpID0gMDtpIDwgMjA7IGkrKykge1xuICAgIGZyYW1lKys7XG4gICAgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICAgIGlmIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgICAgaSA9IDA7XG4gICAgICBmaW5pc2hlZEZyYW1lID0gZnJhbWUgKyAxO1xuICAgIH1cbiAgfVxuICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbmlzaGVkRnJhbWUpO1xuICByZXR1cm4gZmluaXNoZWRGcmFtZTtcbn1cblxuLy8gc3JjL3NwcmluZy9pbmRleC50c1xuZnVuY3Rpb24gc3ByaW5nKHtcbiAgZnJhbWU6IHBhc3NlZEZyYW1lLFxuICBmcHMsXG4gIGNvbmZpZyA9IHt9LFxuICBmcm9tID0gMCxcbiAgdG8gPSAxLFxuICBkdXJhdGlvbkluRnJhbWVzOiBwYXNzZWREdXJhdGlvbkluRnJhbWVzLFxuICBkdXJhdGlvblJlc3RUaHJlc2hvbGQsXG4gIGRlbGF5ID0gMCxcbiAgcmV2ZXJzZSA9IGZhbHNlXG59KSB7XG4gIHZhbGlkYXRlU3ByaW5nRHVyYXRpb24ocGFzc2VkRHVyYXRpb25JbkZyYW1lcyk7XG4gIHZhbGlkYXRlRnJhbWUoe1xuICAgIGZyYW1lOiBwYXNzZWRGcmFtZSxcbiAgICBkdXJhdGlvbkluRnJhbWVzOiBJbmZpbml0eSxcbiAgICBhbGxvd0Zsb2F0czogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVGcHMoZnBzLCBcInRvIHNwcmluZygpXCIsIGZhbHNlKTtcbiAgY29uc3QgbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA9IHJldmVyc2UgfHwgdHlwZW9mIHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IG5hdHVyYWxEdXJhdGlvbiA9IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPyBtZWFzdXJlU3ByaW5nKHtcbiAgICBmcHMsXG4gICAgY29uZmlnLFxuICAgIHRocmVzaG9sZDogZHVyYXRpb25SZXN0VGhyZXNob2xkXG4gIH0pIDogdW5kZWZpbmVkO1xuICBjb25zdCBuYXR1cmFsRHVyYXRpb25HZXR0ZXIgPSBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID8ge1xuICAgIGdldDogKCkgPT4gbmF0dXJhbER1cmF0aW9uXG4gIH0gOiB7XG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWQgbm90IGNhbGN1bGF0ZSBuYXR1cmFsIGR1cmF0aW9uLCB0aGlzIGlzIGFuIGVycm9yIHdpdGggUmVtb3Rpb24uIFBsZWFzZSByZXBvcnRcIik7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXZlcnNlUHJvY2Vzc2VkID0gcmV2ZXJzZSA/IChwYXNzZWREdXJhdGlvbkluRnJhbWVzID8/IG5hdHVyYWxEdXJhdGlvbkdldHRlci5nZXQoKSkgLSBwYXNzZWRGcmFtZSA6IHBhc3NlZEZyYW1lO1xuICBjb25zdCBkZWxheVByb2Nlc3NlZCA9IHJldmVyc2VQcm9jZXNzZWQgKyAocmV2ZXJzZSA/IGRlbGF5IDogLWRlbGF5KTtcbiAgY29uc3QgZHVyYXRpb25Qcm9jZXNzZWQgPSBwYXNzZWREdXJhdGlvbkluRnJhbWVzID09PSB1bmRlZmluZWQgPyBkZWxheVByb2Nlc3NlZCA6IGRlbGF5UHJvY2Vzc2VkIC8gKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgLyBuYXR1cmFsRHVyYXRpb25HZXR0ZXIuZ2V0KCkpO1xuICBpZiAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyAmJiBkZWxheVByb2Nlc3NlZCA+IHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgY29uc3Qgc3ByID0gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICAgIGZwcyxcbiAgICBmcmFtZTogZHVyYXRpb25Qcm9jZXNzZWQsXG4gICAgY29uZmlnXG4gIH0pO1xuICBjb25zdCBpbm5lciA9IGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyA/IHRvID49IGZyb20gPyBNYXRoLm1pbihzcHIuY3VycmVudCwgdG8pIDogTWF0aC5tYXgoc3ByLmN1cnJlbnQsIHRvKSA6IHNwci5jdXJyZW50O1xuICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBmcm9tID09PSAwICYmIHRvID09PSAxID8gaW5uZXIgOiBpbnRlcnBvbGF0ZShpbm5lciwgWzAsIDFdLCBbZnJvbSwgdG9dKTtcbiAgcmV0dXJuIGludGVycG9sYXRlZDtcbn1cbi8vIHNyYy9zdGF0aWMtZmlsZS50c1xudmFyIHByb2JsZW1hdGljQ2hhcmFjdGVycyA9IHtcbiAgXCIlM0FcIjogXCI6XCIsXG4gIFwiJTJGXCI6IFwiL1wiLFxuICBcIiUzRlwiOiBcIj9cIixcbiAgXCIlMjNcIjogXCIjXCIsXG4gIFwiJTVCXCI6IFwiW1wiLFxuICBcIiU1RFwiOiBcIl1cIixcbiAgXCIlNDBcIjogXCJAXCIsXG4gIFwiJTIxXCI6IFwiIVwiLFxuICBcIiUyNFwiOiBcIiRcIixcbiAgXCIlMjZcIjogXCImXCIsXG4gIFwiJTI3XCI6IFwiJ1wiLFxuICBcIiUyOFwiOiBcIihcIixcbiAgXCIlMjlcIjogXCIpXCIsXG4gIFwiJTJBXCI6IFwiKlwiLFxuICBcIiUyQlwiOiBcIitcIixcbiAgXCIlMkNcIjogXCIsXCIsXG4gIFwiJTNCXCI6IFwiO1wiXG59O1xudmFyIGRpZFdhcm4yID0ge307XG52YXIgd2Fybk9uY2UzID0gKG1lc3NhZ2UpID0+IHtcbiAgaWYgKGRpZFdhcm4yW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FybjJbbWVzc2FnZV0gPSB0cnVlO1xufTtcbnZhciBpbmNsdWRlc0hleE9mVW5zYWZlQ2hhciA9IChwYXRoKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHByb2JsZW1hdGljQ2hhcmFjdGVycykpIHtcbiAgICBpZiAocGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICByZXR1cm4geyBjb250YWluc0hleDogdHJ1ZSwgaGV4Q29kZToga2V5IH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNvbnRhaW5zSGV4OiBmYWxzZSB9O1xufTtcbnZhciB0cmltTGVhZGluZ1NsYXNoID0gKHBhdGgpID0+IHtcbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdHJpbUxlYWRpbmdTbGFzaChwYXRoLnN1YnN0cmluZygxKSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xudmFyIGlubmVyID0gKHBhdGgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdmFsdWUgXCIke3BhdGh9XCIgaXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIHRoZSBzdGF0aWMgYmFzZSAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCBzdGF0aWNGaWxlKCkgb24gaXQuYCk7XG4gICAgfVxuICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt0cmltTGVhZGluZ1NsYXNoKHBhdGgpfWA7XG4gIH1cbiAgcmV0dXJuIGAvJHt0cmltTGVhZGluZ1NsYXNoKHBhdGgpfWA7XG59O1xudmFyIGVuY29kZUJ5U3BsaXR0aW5nID0gKHBhdGgpID0+IHtcbiAgY29uc3Qgc3BsaXRCeVNsYXNoID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGNvbnN0IGVuY29kZWRBcnJheSA9IHNwbGl0QnlTbGFzaC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQpO1xuICB9KTtcbiAgY29uc3QgbWVyZ2VkID0gZW5jb2RlZEFycmF5LmpvaW4oXCIvXCIpO1xuICByZXR1cm4gbWVyZ2VkO1xufTtcbnZhciBzdGF0aWNGaWxlID0gKHBhdGgpID0+IHtcbiAgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibnVsbCB3YXMgcGFzc2VkIHRvIHN0YXRpY0ZpbGUoKVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidW5kZWZpbmVkIHdhcyBwYXNzZWQgdG8gc3RhdGljRmlsZSgpXCIpO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVtb3RlIFVSTHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIFVSTCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHN0YXRpY0ZpbGUoKS4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVtb3RlLXVybHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi5cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCByZWxhdGl2ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvVXNlcnNcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2hvbWVcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL3RtcFwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvZXRjXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9vcHRcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL3ZhclwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJDOlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJEOlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJFOlwiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IGFic29sdXRlIHBhdGhzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBuYW1lIG9mIGEgZmlsZSB0aGF0IGlzIGluc2lkZSB0aGUgcHVibGljLyBmb2xkZXIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcInB1YmxpYy9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEbyBub3QgaW5jbHVkZSB0aGUgcHVibGljLyBwcmVmaXggd2hlbiB1c2luZyBzdGF0aWNGaWxlKCkgLSBnb3QgXCIke3BhdGh9XCIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNIZXggPSBpbmNsdWRlc0hleE9mVW5zYWZlQ2hhcihwYXRoKTtcbiAgaWYgKGluY2x1ZGVzSGV4LmNvbnRhaW5zSGV4KSB7XG4gICAgd2Fybk9uY2UzKGBXQVJOSU5HOiBZb3Ugc2VlbSB0byBwYXNzIGFuIGFscmVhZHkgZW5jb2RlZCBwYXRoIChwYXRoIGNvbnRhaW5zICR7aW5jbHVkZXNIZXguaGV4Q29kZX0pLiBTaW5jZSBSZW1vdGlvbiA0LjAsIHRoZSBlbmNvZGluZyBpcyBkb25lIGJ5IHN0YXRpY0ZpbGUoKSBpdHNlbGYuIFlvdSBtYXkgd2FudCB0byByZW1vdmUgYSBlbmNvZGVVUklDb21wb25lbnQoKSB3cmFwcGluZy5gKTtcbiAgfVxuICBjb25zdCBwcmVwcm9jZXNzZWQgPSBlbmNvZGVCeVNwbGl0dGluZyhwYXRoKTtcbiAgY29uc3QgcHJlcGFyc2VkID0gaW5uZXIocHJlcHJvY2Vzc2VkKTtcbiAgaWYgKCFwcmVwYXJzZWQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gYC8ke3ByZXBhcnNlZH1gO1xuICB9XG4gIHJldHVybiBwcmVwYXJzZWQ7XG59O1xuLy8gc3JjL1N0aWxsLnRzeFxuaW1wb3J0IFJlYWN0MjkgZnJvbSBcInJlYWN0XCI7XG52YXIgU3RpbGwgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgIC4uLnByb3BzMixcbiAgICBkdXJhdGlvbkluRnJhbWVzOiAxLFxuICAgIGZwczogMVxuICB9O1xuICByZXR1cm4gUmVhY3QyOS5jcmVhdGVFbGVtZW50KENvbXBvc2l0aW9uLCBuZXdQcm9wcyk7XG59O1xuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvLnRzeFxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE1LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNyxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE5LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0OCxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjcsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTdcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MzAgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBPZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZyA9ICh7XG4gIG9uRXJyb3IsXG4gIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgcGxheWJhY2tSYXRlLFxuICBzcmMsXG4gIG11dGVkLFxuICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gIHRyYW5zcGFyZW50ID0gZmFsc2UsXG4gIHRvbmVNYXBwZWQgPSB0cnVlLFxuICB0b25lRnJlcXVlbmN5LFxuICBuYW1lLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgb25WaWRlb0ZyYW1lLFxuICBjcm9zc09yaWdpbixcbiAgLi4ucHJvcHMyXG59KSA9PiB7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BzRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AobG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IgPz8gXCJyZXBlYXRcIik7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDI3KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IG1lZGlhU3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjcoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gYHNyY2Agd2FzIHBhc3NlZCB0byA8T2ZmdGhyZWFkVmlkZW8+LlwiKTtcbiAgfVxuICBjb25zdCBpZCA9IHVzZU1lbW8yNygoKSA9PiBgb2ZmdGhyZWFkdmlkZW8tJHtyYW5kb20oc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BzRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHVzZUVmZmVjdDE5KCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3JjIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICB0eXBlOiBcInZpZGVvXCIsXG4gICAgICBzcmM6IGdldEFic29sdXRlU3JjKHNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyBudWxsLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgbXV0ZWQsXG4gICAgc3JjLFxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICBmcmFtZSxcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tXG4gIF0pO1xuICBjb25zdCBjdXJyZW50VGltZSA9IHVzZU1lbW8yNygoKSA9PiB7XG4gICAgcmV0dXJuIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkKHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgfHwgMSxcbiAgICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXRcbiAgICB9KSAvIHZpZGVvQ29uZmlnLmZwcztcbiAgfSwgW2ZyYW1lLCBtZWRpYVN0YXJ0c0F0LCBwbGF5YmFja1JhdGUsIHZpZGVvQ29uZmlnLmZwc10pO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VNZW1vMjcoKCkgPT4ge1xuICAgIHJldHVybiBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSh7XG4gICAgICBzcmMsXG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIHRyYW5zcGFyZW50LFxuICAgICAgdG9uZU1hcHBlZFxuICAgIH0pO1xuICB9LCBbdG9uZU1hcHBlZCwgY3VycmVudFRpbWUsIHNyYywgdHJhbnNwYXJlbnRdKTtcbiAgY29uc3QgW2ltYWdlU3JjLCBzZXRJbWFnZVNyY10gPSB1c2VTdGF0ZTE3KG51bGwpO1xuICB1c2VMYXlvdXRFZmZlY3Q4KCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9IFtdO1xuICAgIHNldEltYWdlU3JjKG51bGwpO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyKGBGZXRjaGluZyAke2FjdHVhbFNyY30gZnJvbSBzZXJ2ZXJgLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBjb25zdCBleGVjdXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYWN0dWFsU3JjLCB7XG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgICAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkVXBFcnJvck1lc3NhZ2UgPSBqc29uLmVycm9yLnJlcGxhY2UoL15FcnJvcjogLywgXCJcIik7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjbGVhbmVkVXBFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXR1cm5lZCBzdGF0dXMgJHtyZXMuc3RhdHVzfSB3aGlsZSBmZXRjaGluZyAke2FjdHVhbFNyY31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgY2xlYW51cC5wdXNoKCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKSk7XG4gICAgICAgIHNldEltYWdlU3JjKHtcbiAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICBoYW5kbGU6IG5ld0hhbmRsZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJhYm9ydGVkXCIpKSB7XG4gICAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke2FjdHVhbFNyY30uIFRoaXMgY291bGQgYmUgY2F1c2VkIGJ5IENocm9tZSByZWplY3RpbmcgdGhlIHJlcXVlc3QgYmVjYXVzZSB0aGUgZGlzayBzcGFjZSBpcyBsb3cuIENvbnNpZGVyIGluY3JlYXNpbmcgdGhlIGRpc2sgc2l6ZSBvZiB5b3VyIGVudmlyb25tZW50LmAsIHsgY2F1c2U6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5jZWxSZW5kZXIoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZXhlY3V0ZSgpO1xuICAgIGNsZWFudXAucHVzaCgoKSA9PiB7XG4gICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXAuZm9yRWFjaCgoYzIpID0+IGMyKCkpO1xuICAgIH07XG4gIH0sIFtcbiAgICBhY3R1YWxTcmMsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIG9uRXJyb3JcbiAgXSk7XG4gIGNvbnN0IG9uRXJyID0gdXNlQ2FsbGJhY2sxNSgoKSA9PiB7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3I/LihuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBpbWFnZSB3aXRoIHNyYyBcIiArIGltYWdlU3JjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbFJlbmRlcihcIkZhaWxlZCB0byBsb2FkIGltYWdlIHdpdGggc3JjIFwiICsgaW1hZ2VTcmMpO1xuICAgIH1cbiAgfSwgW2ltYWdlU3JjLCBvbkVycm9yXSk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IHVzZU1lbW8yNygoKSA9PiB7XG4gICAgcmV0dXJuIFtPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRSwgcHJvcHMyLmNsYXNzTmFtZV0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gIH0sIFtwcm9wczIuY2xhc3NOYW1lXSk7XG4gIGNvbnN0IG9uSW1hZ2VGcmFtZSA9IHVzZUNhbGxiYWNrMTUoKGltZykgPT4ge1xuICAgIGlmIChvblZpZGVvRnJhbWUpIHtcbiAgICAgIG9uVmlkZW9GcmFtZShpbWcpO1xuICAgIH1cbiAgfSwgW29uVmlkZW9GcmFtZV0pO1xuICBpZiAoIWltYWdlU3JjIHx8ICF3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29udGludWVSZW5kZXIoaW1hZ2VTcmMuaGFuZGxlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMChJbWcsIHtcbiAgICBzcmM6IGltYWdlU3JjLnNyYyxcbiAgICBjbGFzc05hbWUsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIG9uSW1hZ2VGcmFtZSxcbiAgICAuLi5wcm9wczIsXG4gICAgb25FcnJvcjogb25FcnJcbiAgfSk7XG59O1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JQcmV2aWV3LnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTAsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI4LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjEsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTksXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI4LFxuICB1c2VSZWYgYXMgdXNlUmVmMTYsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMThcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9lbWl0LXZpZGVvLWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjAgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VFbWl0VmlkZW9GcmFtZSA9ICh7XG4gIHJlZixcbiAgb25WaWRlb0ZyYW1lXG59KSA9PiB7XG4gIHVzZUVmZmVjdDIwKCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHJlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFvblZpZGVvRnJhbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGhhbmRsZSA9IDA7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uVmlkZW9GcmFtZShyZWYuY3VycmVudCk7XG4gICAgICBoYW5kbGUgPSByZWYuY3VycmVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW29uVmlkZW9GcmFtZSwgcmVmXSk7XG59O1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JQcmV2aWV3LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMxIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3JEZXZlbG9wbWVudFJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wczIsIHJlZikgPT4ge1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE2KG51bGwpO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnQsXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIG5hbWUsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc3R5bGUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAgIG9uRXJyb3IsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIG9uVmlkZW9GcmFtZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHMyO1xuICBjb25zdCB2b2x1bWVQcm9wRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AobG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IgPz8gXCJyZXBlYXRcIik7XG4gIGNvbnN0IHsgZnBzLCBkdXJhdGlvbkluRnJhbWVzIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQyOChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDI4KFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IG1vdW50VGltZSA9IHVzZU1vdW50VGltZSgpO1xuICBjb25zdCBbdGltZWxpbmVJZF0gPSB1c2VTdGF0ZTE4KCgpID0+IFN0cmluZyhNYXRoLnJhbmRvbSgpKSk7XG4gIGNvbnN0IGlzU2VxdWVuY2VIaWRkZW4gPSBoaWRkZW5bdGltZWxpbmVJZF0gPz8gZmFsc2U7XG4gIGlmICh0eXBlb2YgYWNjZXB0YWJsZVRpbWVTaGlmdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFjY2VwdGFibGVUaW1lU2hpZnQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgaW5zdGVhZC5cIik7XG4gIH1cbiAgY29uc3QgW21lZGlhVm9sdW1lXSA9IHVzZU1lZGlhVm9sdW1lU3RhdGUoKTtcbiAgY29uc3QgW21lZGlhTXV0ZWRdID0gdXNlTWVkaWFNdXRlZFN0YXRlKCk7XG4gIGNvbnN0IHVzZXJQcmVmZXJyZWRWb2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgZnJhbWU6IHZvbHVtZVByb3BGcmFtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWVcbiAgfSk7XG4gIHVzZU1lZGlhSW5UaW1lbGluZSh7XG4gICAgbWVkaWFSZWY6IHZpZGVvUmVmLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBtZWRpYVR5cGU6IFwidmlkZW9cIixcbiAgICBzcmMsXG4gICAgcGxheWJhY2tSYXRlOiBwcm9wczIucGxheWJhY2tSYXRlID8/IDEsXG4gICAgZGlzcGxheU5hbWU6IG5hbWUgPz8gbnVsbCxcbiAgICBpZDogdGltZWxpbmVJZCxcbiAgICBzdGFjazogX3JlbW90aW9uSW50ZXJuYWxTdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBwcmVtb3VudERpc3BsYXk6IG51bGwsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbCxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZylcbiAgfSk7XG4gIHVzZVN5bmNWb2x1bWVXaXRoTWVkaWFUYWcoe1xuICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFSZWY6IHZpZGVvUmVmXG4gIH0pO1xuICB1c2VBbXBsaWZpY2F0aW9uKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgdm9sdW1lOiB1c2VyUHJlZmVycmVkVm9sdW1lXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJ2aWRlb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4ocGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nKSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbCxcbiAgICB1c2VyUHJlZmVycmVkVm9sdW1lXG4gIH0pO1xuICBjb25zdCBhY3R1YWxGcm9tID0gcGFyZW50U2VxdWVuY2UgPyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gOiAwO1xuICBjb25zdCBkdXJhdGlvbiA9IHBhcmVudFNlcXVlbmNlID8gTWF0aC5taW4ocGFyZW50U2VxdWVuY2UuZHVyYXRpb25JbkZyYW1lcywgZHVyYXRpb25JbkZyYW1lcykgOiBkdXJhdGlvbkluRnJhbWVzO1xuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHNyYyk7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgIGFjdHVhbFNyYzogcHJlbG9hZGVkU3JjLFxuICAgIGFjdHVhbEZyb20sXG4gICAgZHVyYXRpb24sXG4gICAgZnBzXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlOShyZWYsICgpID0+IHtcbiAgICByZXR1cm4gdmlkZW9SZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB1c2VTdGF0ZTE4KCgpID0+IHBsYXliYWNrTG9nZ2luZyh7XG4gICAgbG9nTGV2ZWwsXG4gICAgbWVzc2FnZTogYE1vdW50aW5nIHZpZGVvIHdpdGggc291cmNlID0gJHthY3R1YWxTcmN9LCB2PSR7VkVSU0lPTn0sIHVzZXIgYWdlbnQ9JHt0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gXCJzZXJ2ZXJcIiA6IG5hdmlnYXRvci51c2VyQWdlbnR9YCxcbiAgICB0YWc6IFwidmlkZW9cIixcbiAgICBtb3VudFRpbWVcbiAgfSkpO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9jY3VycmVkIGluIHZpZGVvXCIsIGN1cnJlbnQ/LmVycm9yKTtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9OiAke2N1cnJlbnQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtzcmN9OiBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfSAtICR7Y3VycmVudD8uZXJyb3I/Lm1lc3NhZ2V9LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9tZWRpYS1wbGF5YmFjay1lcnJvciBmb3IgaGVscC4gUGFzcyBhbiBvbkVycm9yKCkgcHJvcCB0byBoYW5kbGUgdGhlIGVycm9yLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7c3JjfWApO1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW9cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbb25FcnJvciwgc3JjXSk7XG4gIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYxNihvbkR1cmF0aW9uKTtcbiAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50ID0gb25EdXJhdGlvbjtcbiAgdXNlRW1pdFZpZGVvRnJhbWUoeyByZWY6IHZpZGVvUmVmLCBvblZpZGVvRnJhbWUgfSk7XG4gIHVzZUVmZmVjdDIxKCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5kdXJhdGlvbikge1xuICAgICAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50Py4oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Mb2FkZWRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgfTtcbiAgfSwgW3NyY10pO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzSW9zU2FmYXJpKCkpIHtcbiAgICAgIGN1cnJlbnQucHJlbG9hZCA9IFwibWV0YWRhdGFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wcmVsb2FkID0gXCJhdXRvXCI7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IGFjdHVhbFN0eWxlID0gdXNlTWVtbzI4KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3R5bGUsXG4gICAgICBvcGFjaXR5OiBpc1NlcXVlbmNlSGlkZGVuID8gMCA6IHN0eWxlPy5vcGFjaXR5ID8/IDFcbiAgICB9O1xuICB9LCBbaXNTZXF1ZW5jZUhpZGRlbiwgc3R5bGVdKTtcbiAgY29uc3QgY3Jvc3NPcmlnaW5WYWx1ZSA9IGNyb3NzT3JpZ2luID8/IChvblZpZGVvRnJhbWUgPyBcImFub255bW91c1wiIDogdW5kZWZpbmVkKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMShcInZpZGVvXCIsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgIHBsYXlzSW5saW5lOiB0cnVlLFxuICAgIHNyYzogYWN0dWFsU3JjLFxuICAgIGxvb3A6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBzdHlsZTogYWN0dWFsU3R5bGUsXG4gICAgZGlzYWJsZVJlbW90ZVBsYXliYWNrOiB0cnVlLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0pO1xufTtcbnZhciBWaWRlb0ZvclByZXZpZXcgPSBmb3J3YXJkUmVmMTAoVmlkZW9Gb3JEZXZlbG9wbWVudFJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE9mZnRocmVhZFZpZGVvID0gKHByb3BzMikgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIG5hbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjazE2KCgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sIFtdKTtcbiAgaWYgKHR5cGVvZiBwcm9wczIuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxPZmZ0aHJlYWRWaWRlbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wczIuc3JjKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBpZiAocHJvcHMyLmltYWdlRm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxPZmZ0aHJlYWRWaWRlbz5cXGAgdGFnIGRvZXMgbm8gbG9uZ2VyIGFjY2VwdCBcXGBpbWFnZUZvcm1hdFxcYC4gVXNlIHRoZSBcXGB0cmFuc3BhcmVudFxcYCBwcm9wIGlmIHlvdSB3YW50IHRvIHJlbmRlciBhIHRyYW5zcGFyZW50IHZpZGVvLmApO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbGlkYXRlU3RhcnRGcm9tUHJvcHMoc3RhcnRGcm9tLCBlbmRBdCk7XG4gICAgY29uc3Qgc3RhcnRGcm9tRnJhbWVObyA9IHN0YXJ0RnJvbSA/PyAwO1xuICAgIGNvbnN0IGVuZEF0RnJhbWVObyA9IGVuZEF0ID8/IEluZmluaXR5O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzIoU2VxdWVuY2UsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBmcm9tOiAwIC0gc3RhcnRGcm9tRnJhbWVObyxcbiAgICAgIHNob3dJblRpbWVsaW5lOiBmYWxzZSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGVuZEF0RnJhbWVObyxcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMyKE9mZnRocmVhZFZpZGVvLCB7XG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyhwcm9wczIsIFwiVmlkZW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzIoT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIC4uLm90aGVyUHJvcHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7XG4gICAgdHJhbnNwYXJlbnQsXG4gICAgdG9uZU1hcHBlZCxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgb25WaWRlb0ZyYW1lLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAuLi5wcm9wc0ZvclByZXZpZXdcbiAgfSA9IG90aGVyUHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzIoVmlkZW9Gb3JQcmV2aWV3LCB7XG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IGZhbHNlLFxuICAgIG9uRHVyYXRpb24sXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogdHJ1ZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZSxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG9uQXV0b1BsYXlFcnJvciA/PyB1bmRlZmluZWQsXG4gICAgb25WaWRlb0ZyYW1lOiBvblZpZGVvRnJhbWUgPz8gbnVsbCxcbiAgICBjcm9zc09yaWdpbixcbiAgICAuLi5wcm9wc0ZvclByZXZpZXdcbiAgfSk7XG59O1xuLy8gc3JjL3ZpZGVvL1ZpZGVvLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTIsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTcsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMwIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjExLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIyLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUxMCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDksXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI5LFxuICB1c2VSZWYgYXMgdXNlUmVmMTdcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9zZWVrLXVudGlsLXJpZ2h0LnRzXG52YXIgcm91bmRUbzZDb21tYXMgPSAobnVtKSA9PiB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDFlNSkgLyAxZTU7XG59O1xudmFyIHNlZWtUb1RpbWUgPSAoe1xuICBlbGVtZW50LFxuICBkZXNpcmVkVGltZSxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShlbGVtZW50LmN1cnJlbnRUaW1lLCBkZXNpcmVkVGltZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FpdDogUHJvbWlzZS5yZXNvbHZlKGRlc2lyZWRUaW1lKSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge31cbiAgICB9O1xuICB9XG4gIHNlZWsoe1xuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmOiBlbGVtZW50LFxuICAgIHRpbWU6IGRlc2lyZWRUaW1lLFxuICAgIHdoeTogXCJTZWVraW5nIGR1cmluZyByZW5kZXJpbmdcIixcbiAgICBtb3VudFRpbWVcbiAgfSk7XG4gIGxldCBjYW5jZWw7XG4gIGxldCBjYW5jZWxTZWVrZWQgPSBudWxsO1xuICBjb25zdCBwcm9tID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjYW5jZWwgPSBlbGVtZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soKG5vdywgbWV0YWRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGRpc3BsYXlJbiA9IG1ldGFkYXRhLmV4cGVjdGVkRGlzcGxheVRpbWUgLSBub3c7XG4gICAgICBpZiAoZGlzcGxheUluIDw9IDApIHtcbiAgICAgICAgcmVzb2x2ZShtZXRhZGF0YS5tZWRpYVRpbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShtZXRhZGF0YS5tZWRpYVRpbWUpO1xuICAgICAgfSwgZGlzcGxheUluICsgMTUwKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHdhaXRGb3JTZWVrZWRFdmVudCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgb25Eb25lID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uRG9uZSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNhbmNlbFNlZWtlZCA9ICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHdhaXQ6IFByb21pc2UuYWxsKFtwcm9tLCB3YWl0Rm9yU2Vla2VkRXZlbnRdKS50aGVuKChbdGltZV0pID0+IHRpbWUpLFxuICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgY2FuY2VsU2Vla2VkPy4oKTtcbiAgICAgIGVsZW1lbnQuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNhbmNlbCk7XG4gICAgfVxuICB9O1xufTtcbnZhciBzZWVrVG9UaW1lTXVsdGlwbGVVbnRpbFJpZ2h0ID0gKHtcbiAgZWxlbWVudCxcbiAgZGVzaXJlZFRpbWUsXG4gIGZwcyxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBjb25zdCB0aHJlc2hvbGQgPSAxIC8gZnBzIC8gMjtcbiAgbGV0IGN1cnJlbnRDYW5jZWwgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBpZiAoTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQuZHVyYXRpb24pICYmIGVsZW1lbnQuY3VycmVudFRpbWUgPj0gZWxlbWVudC5kdXJhdGlvbiAmJiBkZXNpcmVkVGltZSA+PSBlbGVtZW50LmR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb206IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgY2FuY2VsOiAoKSA9PiB7fVxuICAgIH07XG4gIH1cbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmaXJzdFNlZWsgPSBzZWVrVG9UaW1lKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBkZXNpcmVkVGltZTogZGVzaXJlZFRpbWUgKyB0aHJlc2hvbGQsXG4gICAgICBsb2dMZXZlbCxcbiAgICAgIG1vdW50VGltZVxuICAgIH0pO1xuICAgIGZpcnN0U2Vlay53YWl0LnRoZW4oKHNlZWtlZFRvKSA9PiB7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoZGVzaXJlZFRpbWUgLSBzZWVrZWRUbyk7XG4gICAgICBpZiAoZGlmZmVyZW5jZSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ24gPSBkZXNpcmVkVGltZSA+IHNlZWtlZFRvID8gMSA6IC0xO1xuICAgICAgY29uc3QgbmV3U2VlayA9IHNlZWtUb1RpbWUoe1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBkZXNpcmVkVGltZTogc2Vla2VkVG8gKyB0aHJlc2hvbGQgKiBzaWduLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRDYW5jZWwgPSBuZXdTZWVrLmNhbmNlbDtcbiAgICAgIG5ld1NlZWsud2FpdC50aGVuKChuZXdUaW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0RpZmZlcmVuY2UgPSBNYXRoLmFicyhkZXNpcmVkVGltZSAtIG5ld1RpbWUpO1xuICAgICAgICBpZiAocm91bmRUbzZDb21tYXMobmV3RGlmZmVyZW5jZSkgPD0gcm91bmRUbzZDb21tYXModGhyZXNob2xkKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpcmRTZWVrID0gc2Vla1RvVGltZSh7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBkZXNpcmVkVGltZTogZGVzaXJlZFRpbWUgKyB0aHJlc2hvbGQsXG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Q2FuY2VsID0gdGhpcmRTZWVrLmNhbmNlbDtcbiAgICAgICAgcmV0dXJuIHRoaXJkU2Vlay53YWl0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdXJyZW50Q2FuY2VsID0gZmlyc3RTZWVrLmNhbmNlbDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGN1cnJlbnRDYW5jZWwoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvclJlbmRlcmluZ0ZvcndhcmRGdW5jdGlvbiA9ICh7XG4gIG9uRXJyb3IsXG4gIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICBwbGF5YmFja1JhdGUsXG4gIG9uRHVyYXRpb24sXG4gIHRvbmVGcmVxdWVuY3ksXG4gIG5hbWUsXG4gIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAuLi5wcm9wczJcbn0sIHJlZikgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmMTcobnVsbCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyOShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgeyByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgfSA9IHVzZUNvbnRleHQyOShSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yOSgoKSA9PiBgdmlkZW8tJHtyYW5kb20ocHJvcHMyLnNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBwcm9wczIuc3JjLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXNcbiAgXSk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2aWRlbyBjb25maWcgZm91bmRcIik7XG4gIH1cbiAgY29uc3Qgdm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgICBmcmFtZTogdm9sdW1lUHJvcHNGcmFtZSxcbiAgICBtZWRpYVZvbHVtZTogMVxuICB9KTtcbiAgdXNlRWZmZWN0MjIoKCkgPT4ge1xuICAgIGlmICghcHJvcHMyLnNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3JjIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKHByb3BzMi5tdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhwcm9wczIuc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IG51bGwsXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gIH0sIFtcbiAgICBwcm9wczIubXV0ZWQsXG4gICAgcHJvcHMyLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbVxuICBdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTEwKHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDIyKCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlID0gZGVsYXlSZW5kZXIoYFJlbmRlcmluZyA8VmlkZW8gLz4gd2l0aCBzcmM9XCIke3Byb3BzMi5zcmN9XCIgYXQgdGltZSAke2N1cnJlbnRUaW1lfWAsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0FwcHJveGltYXRlbHlUaGVTYW1lKGN1cnJlbnQuY3VycmVudFRpbWUsIGN1cnJlbnRUaW1lKSkge1xuICAgICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZERhdGFIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICB9O1xuICAgIGNvbnN0IHNlZWsyID0gc2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCh7XG4gICAgICBlbGVtZW50OiBjdXJyZW50LFxuICAgICAgZGVzaXJlZFRpbWU6IGN1cnJlbnRUaW1lLFxuICAgICAgZnBzOiB2aWRlb0NvbmZpZy5mcHMsXG4gICAgICBsb2dMZXZlbCxcbiAgICAgIG1vdW50VGltZVxuICAgIH0pO1xuICAgIHNlZWsyLnByb20udGhlbigoKSA9PiB7XG4gICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIGVuZGVkSGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50Py5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb2NjdXJyZWQgaW4gdmlkZW9cIiwgY3VycmVudD8uZXJyb3IpO1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7cHJvcHMyLnNyY306IENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9IC0gJHtjdXJyZW50Py5lcnJvcj8ubWVzc2FnZX0uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL21lZGlhLXBsYXliYWNrLWVycm9yIGZvciBoZWxwLiBQYXNzIGFuIG9uRXJyb3IoKSBwcm9wIHRvIGhhbmRsZSB0aGUgZXJyb3IuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzZWVrMi5jYW5jZWwoKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIGVuZGVkSGFuZGxlcik7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgdm9sdW1lUHJvcHNGcmFtZSxcbiAgICBwcm9wczIuc3JjLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB2aWRlb0NvbmZpZy5mcHMsXG4gICAgZnJhbWUsXG4gICAgbWVkaWFTdGFydHNBdCxcbiAgICBvbkVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWVcbiAgXSk7XG4gIGNvbnN0IHsgc3JjIH0gPSBwcm9wczI7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHVzZUxheW91dEVmZmVjdDkoKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcihcIkxvYWRpbmcgPFZpZGVvPiBkdXJhdGlvbiB3aXRoIHNyYz1cIiArIHNyYywge1xuICAgICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgICAgY29uc3QgZGlkTG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgICAgb25EdXJhdGlvbihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgIG9uRHVyYXRpb24oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtzcmMsIG9uRHVyYXRpb24sIGRlbGF5UmVuZGVyUmV0cmllcywgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHNdKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMzKFwidmlkZW9cIiwge1xuICAgIHJlZjogdmlkZW9SZWYsXG4gICAgZGlzYWJsZVJlbW90ZVBsYXliYWNrOiB0cnVlLFxuICAgIC4uLnByb3BzMlxuICB9KTtcbn07XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmcgPSBmb3J3YXJkUmVmMTEoVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24pO1xuXG4vLyBzcmMvdmlkZW8vVmlkZW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wczIsIHJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIG5hbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHN0YWNrLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHMyO1xuICBjb25zdCB7IGxvb3AsIC4uLnByb3BzT3RoZXJUaGFuTG9vcCB9ID0gcHJvcHMyO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IHsgZHVyYXRpb25zLCBzZXREdXJhdGlvbnMgfSA9IHVzZUNvbnRleHQzMChEdXJhdGlvbnNDb250ZXh0KTtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVmcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzMi5zcmMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPFZpZGVvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzMi5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQocHJvcHMyLnNyYyk7XG4gIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjazE3KChzcmMsIGR1cmF0aW9uSW5TZWNvbmRzKSA9PiB7XG4gICAgc2V0RHVyYXRpb25zKHsgdHlwZTogXCJnb3QtZHVyYXRpb25cIiwgZHVyYXRpb25JblNlY29uZHMsIHNyYyB9KTtcbiAgfSwgW3NldER1cmF0aW9uc10pO1xuICBjb25zdCBvblZpZGVvRnJhbWUgPSB1c2VDYWxsYmFjazE3KCgpID0+IHt9LCBbXSk7XG4gIGNvbnN0IGR1cmF0aW9uRmV0Y2hlZCA9IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcmVsb2FkZWRTcmMpXSA/PyBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyldO1xuICBpZiAobG9vcCAmJiBkdXJhdGlvbkZldGNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uRmV0Y2hlZCkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoVmlkZW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBkdXJhdGlvbkZldGNoZWQgKiBmcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNChMb29wLCB7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBjYWxjdWxhdGVMb29wRHVyYXRpb24oe1xuICAgICAgICBlbmRBdCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbixcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwcm9wczIucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzQoVmlkZW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gPz8gMDtcbiAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCA/PyBJbmZpbml0eTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBlbmRBdEZyYW1lTm8sXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzNChWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgcmVmXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyhwcm9wczIsIFwiVmlkZW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoVmlkZW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIG9uRHVyYXRpb24sXG4gICAgICBvblZpZGVvRnJhbWU6IG9uVmlkZW9GcmFtZSA/PyBudWxsLFxuICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgIHJlZlxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoVmlkZW9Gb3JQcmV2aWV3LCB7XG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogZmFsc2UsXG4gICAgLi4ub3RoZXJQcm9wcyxcbiAgICByZWYsXG4gICAgb25WaWRlb0ZyYW1lOiBudWxsLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgIG9uRHVyYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCA/PyBmYWxzZSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZSxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG9uQXV0b1BsYXlFcnJvciA/PyB1bmRlZmluZWRcbiAgfSk7XG59O1xudmFyIFZpZGVvID0gZm9yd2FyZFJlZjEyKFZpZGVvRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoVmlkZW8pO1xuLy8gc3JjL2luZGV4LnRzXG5jaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucygpO1xudmFyIEV4cGVyaW1lbnRhbCA9IHtcbiAgQ2xpcHBlcixcbiAgTnVsbCxcbiAgdXNlSXNQbGF5ZXJcbn07XG52YXIgcHJveHlPYmogPSB7fTtcbnZhciBDb25maWcgPSBuZXcgUHJveHkocHJveHlPYmosIHtcbiAgZ2V0KF8sIHByb3ApIHtcbiAgICBpZiAocHJvcCA9PT0gXCJCdW5kbGluZ1wiIHx8IHByb3AgPT09IFwiUmVuZGVyaW5nXCIgfHwgcHJvcCA9PT0gXCJMb2dcIiB8fCBwcm9wID09PSBcIlB1cHBldGVlclwiIHx8IHByb3AgPT09IFwiT3V0cHV0XCIpIHtcbiAgICAgIHJldHVybiBDb25maWc7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gIFRoZSBDTEkgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBSZW1vdGlvbiBDb3JlLlwiKTtcbiAgICAgIGNvbnNvbGUud2FybihcIlVwZGF0ZSB0aGUgaW1wb3J0IGZyb20gdGhlIGNvbmZpZyBmaWxlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybigpO1xuICAgICAgY29uc29sZS53YXJuKFwiLSBEZWxldGU6XCIpO1xuICAgICAgY29uc29sZS53YXJuKCdpbXBvcnQge0NvbmZpZ30gZnJvbSBcInJlbW90aW9uXCI7Jyk7XG4gICAgICBjb25zb2xlLndhcm4oXCIrIFJlcGxhY2U6XCIpO1xuICAgICAgY29uc29sZS53YXJuKCdpbXBvcnQge0NvbmZpZ30gZnJvbSBcIkByZW1vdGlvbi9jbGkvY29uZmlnXCI7Jyk7XG4gICAgICBjb25zb2xlLndhcm4oKTtcbiAgICAgIGNvbnNvbGUud2FybihcIkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvNC0wLW1pZ3JhdGlvbi5cIik7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfTtcbiAgfVxufSk7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKFNlcXVlbmNlKTtcbmV4cG9ydCB7XG4gIHdhdGNoU3RhdGljRmlsZSxcbiAgdXNlVmlkZW9Db25maWcsXG4gIHVzZUN1cnJlbnRTY2FsZSxcbiAgdXNlQ3VycmVudEZyYW1lLFxuICB1c2VCdWZmZXJTdGF0ZSxcbiAgc3RhdGljRmlsZSxcbiAgc3ByaW5nLFxuICByZWdpc3RlclJvb3QsXG4gIHJhbmRvbSxcbiAgcHJlZmV0Y2gsXG4gIG1lYXN1cmVTcHJpbmcsXG4gIGludGVycG9sYXRlQ29sb3JzLFxuICBpbnRlcnBvbGF0ZSxcbiAgZ2V0U3RhdGljRmlsZXMsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIGdldElucHV0UHJvcHMsXG4gIGRlbGF5UmVuZGVyLFxuICBjb250aW51ZVJlbmRlcixcbiAgY2FuY2VsUmVuZGVyLFxuICBWaWRlbyxcbiAgVkVSU0lPTixcbiAgU3RpbGwsXG4gIFNlcmllcyxcbiAgU2VxdWVuY2UsXG4gIE9mZnRocmVhZFZpZGVvLFxuICBMb29wLFxuICBJbnRlcm5hbHMsXG4gIEltZyxcbiAgSUZyYW1lLFxuICBGcmVlemUsXG4gIEZvbGRlckNvbnRleHQsXG4gIEZvbGRlcixcbiAgRXhwZXJpbWVudGFsLFxuICBFYXNpbmcsXG4gIENvbmZpZyxcbiAgQ29tcG9zaXRpb24sXG4gIEF1ZGlvLFxuICBBcnRpZmFjdCxcbiAgQW5pbWF0ZWRJbWFnZSxcbiAgQWJzb2x1dGVGaWxsXG59O1xuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsIm5ld1ZhbHVlIiwiY3JlYXRlQ29udGV4dCIsImVyciIsIkVycm9yIiwiam9pbiIsIkNsaXBwZXIiLCJSZWFjdCIsImdldE5vZGVFbnZTdHJpbmciLCJnZXRFbnZTdHJpbmciLCJnZXRSZW1vdGlvbkVudmlyb25tZW50IiwiaXNQbGF5ZXIiLCJ3aW5kb3ciLCJyZW1vdGlvbl9pc1BsYXllciIsImlzUmVuZGVyaW5nIiwicHJvY2VzcyIsImVudiIsInJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQiLCJpc1N0dWRpbyIsInJlbW90aW9uX2lzU3R1ZGlvIiwiaXNSZWFkT25seVN0dWRpbyIsInJlbW90aW9uX2lzUmVhZE9ubHlTdHVkaW8iLCJvcmlnaW5hbENyZWF0ZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29tcG9uZW50c1RvQWRkU3RhY2tzVG8iLCJlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzIiwicHJveHkiLCJQcm94eSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ0FycmF5IiwiaW5jbHVkZXMiLCJmaXJzdCIsInByb3BzIiwicmVzdCIsIm5ld1Byb3BzIiwic3RhY2siLCJSZWZsZWN0IiwiYWRkU2VxdWVuY2VTdGFja1RyYWNlcyIsImNvbXBvbmVudCIsInB1c2giLCJjcmVhdGVDb250ZXh0MiIsInVzZUNvbnRleHQiLCJqc3giLCJJc1BsYXllckNvbnRleHQiLCJJc1BsYXllckNvbnRleHRQcm92aWRlciIsImNoaWxkcmVuIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUlzUGxheWVyIiwidHJ1dGh5IiwiQm9vbGVhbiIsIlZFUlNJT04iLCJjaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucyIsImdsb2JhbFRoaXMiLCJyZW1vdGlvbl9pbXBvcnRlZCIsImFscmVhZHlJbXBvcnRlZCIsIlR5cGVFcnJvciIsImZpbHRlciIsIk51bGwiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZFJlZjIiLCJ1c2VDb250ZXh0MTAiLCJ1c2VFZmZlY3QiLCJ1c2VFZmZlY3QzIiwidXNlTWVtbyIsInVzZU1lbW85IiwidXNlU3RhdGUiLCJ1c2VTdGF0ZTQiLCJqc3gyIiwiaGFzVGFpbHdpbmRDbGFzc05hbWUiLCJjbGFzc05hbWUiLCJjbGFzc1ByZWZpeCIsInNvbWUiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwiQWJzb2x1dGVGaWxsUmVmRm9yd2FyZGluZyIsInJlZiIsInN0eWxlIiwib3RoZXIiLCJhY3R1YWxTdHlsZSIsInBvc2l0aW9uIiwidG9wIiwidW5kZWZpbmVkIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwid2lkdGgiLCJoZWlnaHQiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsIkFic29sdXRlRmlsbCIsImNyZWF0ZUNvbnRleHQzIiwiU2VxdWVuY2VDb250ZXh0IiwiUmVhY3QzIiwidXNlQ2FsbGJhY2siLCJ1c2VNZW1vMiIsImpzeDMiLCJTZXF1ZW5jZU1hbmFnZXIiLCJyZWdpc3RlclNlcXVlbmNlIiwidW5yZWdpc3RlclNlcXVlbmNlIiwic2VxdWVuY2VzIiwiU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCIsImhpZGRlbiIsInNldEhpZGRlbiIsIlNlcXVlbmNlTWFuYWdlclByb3ZpZGVyIiwic2V0U2VxdWVuY2VzIiwic2VxIiwic2VxcyIsInMiLCJpZCIsInNlcXVlbmNlQ29udGV4dCIsImhpZGRlbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0NCIsInVzZUNvbnRleHQyIiwidXNlUmVmIiwidXNlU3RhdGUyIiwiTm9uY2VDb250ZXh0IiwiZ2V0Tm9uY2UiLCJmYXN0UmVmcmVzaGVzIiwidXNlTm9uY2UiLCJjb250ZXh0Iiwibm9uY2UiLCJzZXROb25jZSIsImxhc3RDb250ZXh0IiwiY3VycmVudCIsImV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUiLCJ1c2VUaW1lbGluZVNldEZyYW1lIiwidXNlVGltZWxpbmVQb3NpdGlvbiIsInVzZVBsYXlpbmdTdGF0ZSIsInBlcnNpc3RDdXJyZW50RnJhbWUiLCJnZXRJbml0aWFsRnJhbWVTdGF0ZSIsImdldEZyYW1lRm9yQ29tcG9zaXRpb24iLCJUaW1lbGluZUNvbnRleHQiLCJTZXRUaW1lbGluZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0OCIsInVzZUNvbnRleHQ1IiwidXNlTWVtbzYiLCJ1c2VDb250ZXh0NCIsInVzZU1lbW81IiwiY3JlYXRlQ29udGV4dDUiLCJDb21wb3NpdGlvbk1hbmFnZXIiLCJjb21wb3NpdGlvbnMiLCJmb2xkZXJzIiwiY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEiLCJjYW52YXNDb250ZW50IiwiQ29tcG9zaXRpb25TZXR0ZXJzIiwicmVnaXN0ZXJDb21wb3NpdGlvbiIsInVucmVnaXN0ZXJDb21wb3NpdGlvbiIsInJlZ2lzdGVyRm9sZGVyIiwidW5yZWdpc3RlckZvbGRlciIsInNldENhbnZhc0NvbnRlbnQiLCJ1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyIsIm9ubHlSZW5kZXJDb21wb3NpdGlvbiIsImNyZWF0ZUNvbnRleHQ3IiwiY3JlYXRlUmVmIiwidXNlQ2FsbGJhY2szIiwidXNlQ29udGV4dDMiLCJ1c2VFZmZlY3QyIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUltcGVyYXRpdmVIYW5kbGUyIiwidXNlTWVtbzQiLCJ1c2VTdGF0ZTMiLCJSZWFjdDQiLCJjcmVhdGVDb250ZXh0NiIsInVzZUNhbGxiYWNrMiIsInVzZU1lbW8zIiwianN4NCIsIkVkaXRvclByb3BzQ29udGV4dCIsInVwZGF0ZVByb3BzIiwicmVzZXRVbnNhdmVkIiwiZWRpdG9yUHJvcHNQcm92aWRlclJlZiIsInRpbWVWYWx1ZVJlZiIsIkVkaXRvclByb3BzUHJvdmlkZXIiLCJzZXRQcm9wcyIsImRlZmF1bHRQcm9wcyIsInByZXYiLCJnZXRQcm9wcyIsImN0eCIsIkRBVEVfVE9LRU4iLCJGSUxFX1RPS0VOIiwic2VyaWFsaXplSlNPTldpdGhEYXRlIiwiZGF0YSIsImluZGVudCIsInN0YXRpY0Jhc2UiLCJjdXN0b21EYXRlVXNlZCIsImN1c3RvbUZpbGVVc2VkIiwibWFwVXNlZCIsInNldFVzZWQiLCJzZXJpYWxpemVkU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImtleSIsIml0ZW0iLCJEYXRlIiwidG9JU09TdHJpbmciLCJNYXAiLCJTZXQiLCJyZXBsYWNlIiwibWVzc2FnZSIsImRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMiLCJwYXJzZSIsIl8iLCJyZW1vdGlvbl9zdGF0aWNCYXNlIiwic2VyaWFsaXplVGhlbkRlc2VyaWFsaXplIiwic2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8iLCJkaWRXYXJuU1NSSW1wb3J0Iiwid2Fybk9uY2VTU1JJbXBvcnQiLCJjb25zb2xlIiwid2FybiIsImdldElucHV0UHJvcHMiLCJwYXJhbSIsInJlbW90aW9uX2lucHV0UHJvcHMiLCJwYXJzZWQiLCJ2YWxpZENvZGVjcyIsInZhbGlkYXRlRGVmYXVsdENvZGVjIiwiZGVmYXVsdENvZGVjIiwibG9jYXRpb24iLCJ2YWxpZGF0ZURpbWVuc2lvbiIsImFtb3VudCIsIm5hbWVPZlByb3AiLCJpc05hTiIsIk51bWJlciIsImlzRmluaXRlIiwidmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzIiwiZHVyYXRpb25JbkZyYW1lcyIsIm9wdGlvbnMiLCJhbGxvd0Zsb2F0cyIsInZhbGlkYXRlRnBzIiwiZnBzIiwiaXNHaWYiLCJ2YWxpZGF0ZUNhbGN1bGF0ZWQiLCJjYWxjdWxhdGVkIiwiY29tcG9zaXRpb25JZCIsImNvbXBvc2l0aW9uRnBzIiwiY29tcG9zaXRpb25IZWlnaHQiLCJjb21wb3NpdGlvbldpZHRoIiwiY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzIiwiY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIiwiZGVmYXVsdEVycm9yTG9jYXRpb24iLCJkZWZhdWx0T3V0TmFtZSIsInJlc29sdmVWaWRlb0NvbmZpZyIsImNhbGN1bGF0ZU1ldGFkYXRhIiwic2lnbmFsIiwib3JpZ2luYWxQcm9wcyIsImNhbGN1bGF0ZWRQcm9tIiwiYWJvcnRTaWduYWwiLCJ0aGVuIiwiYyIsInJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2giLCJwYXJhbXMiLCJwcm9taXNlT3JSZXR1cm5WYWx1ZSIsInR5cGUiLCJyZXN1bHQiLCJlcnJvciIsImpzeDUiLCJSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0IiwicmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiIsIm5lZWRzUmVzb2x1dGlvbiIsImNvbXBvc2l0aW9uIiwiUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZIiwiUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnIiwiY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbiIsInNlbGVjdGVkQ29tcG9zaXRpb24iLCJmaW5kIiwicmVuZGVyTW9kYWxDb21wb3NpdGlvbiIsImFsbEVkaXRvclByb3BzIiwiaW5wdXRQcm9wcyIsInJlc29sdmVkQ29uZmlncyIsInNldFJlc29sdmVkQ29uZmlncyIsInNlbGVjdGVkRWRpdG9yUHJvcHMiLCJyZW5kZXJNb2RhbFByb3BzIiwiaGFzUmVzb2x1dGlvbiIsImRvUmVzb2x1dGlvbiIsImNvbWJpbmVkUHJvcHMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiciIsInByb21Pck5vdCIsImFib3J0ZWQiLCJjYXRjaCIsImN1cnJlbnRDb21wb3NpdGlvbiIsInJlbG9hZEN1cnJlbnRseVNlbGVjdGVkQ29tcG9zaXRpb24iLCJlZGl0b3JQcm9wcyIsImlzVGhlU2FtZSIsImN1cnJlbnREZWZhdWx0UHJvcHMiLCJjYW5SZXNvbHZlIiwic2hvdWxkSWdub3JlVXBkYXRlIiwicmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGUiLCJhYm9ydCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsInJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMiLCJzdGF0aWNDb21wcyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ1c2VSZXNvbHZlZFZpZGVvQ29uZmlnIiwicHJlZmVycmVkQ29tcG9zaXRpb25JZCIsInVzZVZpZGVvIiwic2VsZWN0ZWQiLCJyZXNvbHZlZCIsImZyYW1lIiwicGxheWluZyIsInBsYXliYWNrUmF0ZSIsInJvb3RJZCIsImltcGVyYXRpdmVQbGF5aW5nIiwic2V0UGxheWJhY2tSYXRlIiwiYXVkaW9BbmRWaWRlb1RhZ3MiLCJzZXRGcmFtZSIsInNldFBsYXlpbmciLCJtYWtlS2V5IiwidGltZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJnZXRJdGVtIiwib2JqIiwicmVtb3Rpb25faW5pdGlhbEZyYW1lIiwidmlkZW9Db25maWciLCJzdGF0ZSIsInVuY2xhbXBlZCIsIk1hdGgiLCJtaW4iLCJ1c2VDb250ZXh0NyIsImNyZWF0ZUNvbnRleHQ5IiwianN4NiIsIkNhblVzZVJlbW90aW9uSG9va3MiLCJDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIiLCJ1c2VDb250ZXh0NiIsInVzZU1lbW83IiwidXNlVW5zYWZlVmlkZW9Db25maWciLCJjdHhXaWR0aCIsImN0eEhlaWdodCIsImN0eER1cmF0aW9uIiwidmlkZW8iLCJ1c2VWaWRlb0NvbmZpZyIsInVzZUNvbnRleHQ5IiwidXNlTWVtbzgiLCJ1c2VDb250ZXh0OCIsInVzZUN1cnJlbnRGcmFtZSIsImNhblVzZVJlbW90aW9uSG9va3MiLCJjb250ZXh0T2Zmc2V0IiwiY3VtdWxhdGVkRnJvbSIsInJlbGF0aXZlRnJvbSIsImpzeDciLCJGcmVlemUiLCJmcmFtZVRvRnJlZXplIiwiYWN0aXZlIiwiaXNBY3RpdmUiLCJ0aW1lbGluZUNvbnRleHQiLCJ0aW1lbGluZVZhbHVlIiwianN4OCIsIlJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsImZyb20iLCJJbmZpbml0eSIsInNob3dJblRpbWVsaW5lIiwiX3JlbW90aW9uSW50ZXJuYWxMb29wRGlzcGxheSIsImxvb3BEaXNwbGF5IiwiX3JlbW90aW9uSW50ZXJuYWxTdGFjayIsIl9yZW1vdGlvbkludGVybmFsUHJlbW91bnREaXNwbGF5IiwicHJlbW91bnREaXNwbGF5IiwibGF5b3V0IiwiU3RyaW5nIiwicmFuZG9tIiwicGFyZW50U2VxdWVuY2UiLCJhYnNvbHV0ZUZyYW1lIiwicGFyZW50U2VxdWVuY2VEdXJhdGlvbiIsImFjdHVhbER1cmF0aW9uSW5GcmFtZXMiLCJtYXgiLCJwcmVtb3VudGluZyIsIl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZyIsImNvbnRleHRWYWx1ZSIsInBhcmVudEZyb20iLCJ0aW1lbGluZUNsaXBOYW1lIiwiZHVyYXRpb24iLCJkaXNwbGF5TmFtZSIsInBhcmVudCIsImVuZFRocmVzaG9sZCIsImNlaWwiLCJjb250ZW50Iiwic3R5bGVJZlRoZXJlIiwiZGVmYXVsdFN0eWxlIiwiaXNTZXF1ZW5jZUhpZGRlbiIsIlJlZ3VsYXJTZXF1ZW5jZSIsIlByZW1vdW50ZWRTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsInBhc3NlZFN0eWxlIiwicHJlbW91bnRGb3IiLCJzdHlsZVdoaWxlUHJlbW91bnRlZCIsIm90aGVyUHJvcHMiLCJwcmVtb3VudGluZ0FjdGl2ZSIsIm9wYWNpdHkiLCJwb2ludGVyRXZlbnRzIiwiU2VxdWVuY2UiLCJQcmVtb3VudGVkU2VxdWVuY2UiLCJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsImZvcndhcmRSZWYzIiwidXNlRWZmZWN0NCIsInVzZUltcGVyYXRpdmVIYW5kbGU0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlUmVmMyIsInVzZVN0YXRlNSIsImlzRXJyb3JMaWtlIiwiY2FuY2VsUmVuZGVyIiwicmVtb3Rpb25fY2FuY2VsbGVkRXJyb3IiLCJsb2dMZXZlbHMiLCJnZXROdW1iZXJGb3JMb2dMZXZlbCIsImxldmVsIiwiaW5kZXhPZiIsImlzRXF1YWxPckJlbG93TG9nTGV2ZWwiLCJjdXJyZW50TGV2ZWwiLCJMb2ciLCJ0cmFjZSIsImxvZ0xldmVsIiwiYXJncyIsImxvZyIsInZlcmJvc2UiLCJpbmZvIiwicmVtb3Rpb25fcmVuZGVyUmVhZHkiLCJoYW5kbGVzIiwicmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyIsIkRFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4iLCJERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUIiwiREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOIiwiREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOIiwiZGVmYXVsdFRpbWVvdXQiLCJkZWxheVJlbmRlciIsImxhYmVsIiwiaGFuZGxlIiwiY2FsbGVkIiwidGltZW91dFRvVXNlIiwidGltZW91dEluTWlsbGlzZWNvbmRzIiwicmV0cmllc0xlZnQiLCJyZXRyaWVzIiwicmVtb3Rpb25fYXR0ZW1wdCIsInN0YXJ0VGltZSIsIm5vdyIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY29udGludWVSZW5kZXIiLCJoIiwiY2xlYXJUaW1lb3V0IiwicmVtb3Rpb25fbG9nTGV2ZWwiLCJsZW5ndGgiLCJSZWFjdDgiLCJ1c2VDYWxsYmFjazQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlMyIsInVzZVJlZjIiLCJqc3g5IiwiY2FsY0FyZ3MiLCJmaXQiLCJmcmFtZVNpemUiLCJjYW52YXNTaXplIiwicmF0aW8iLCJjZW50ZXJYIiwiY2VudGVyWSIsIkNhbnZhc1JlZkZvcndhcmRpbmdGdW5jdGlvbiIsImNhbnZhc1JlZiIsImRyYXciLCJpbWFnZURhdGEiLCJjYW52YXMiLCJjYW52YXNXaWR0aCIsImRpc3BsYXlXaWR0aCIsImNhbnZhc0hlaWdodCIsImRpc3BsYXlIZWlnaHQiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiZ2V0Q2FudmFzIiwiY2xlYXIiLCJjbGVhclJlY3QiLCJDYW52YXMiLCJDQUNIRV9TSVpFIiwiZ2V0QWN0dWFsVGltZSIsImxvb3BCZWhhdmlvciIsImR1cmF0aW9uRm91bmQiLCJ0aW1lSW5TZWMiLCJkZWNvZGVJbWFnZSIsInJlc29sdmVkU3JjIiwiY3VycmVudFRpbWUiLCJpbml0aWFsTG9vcEJlaGF2aW9yIiwiSW1hZ2VEZWNvZGVyIiwicmVzIiwiZmV0Y2giLCJib2R5IiwiZGVjb2RlciIsImhlYWRlcnMiLCJjb21wbGV0ZWQiLCJzZWxlY3RlZFRyYWNrIiwidHJhY2tzIiwiY2FjaGUiLCJnZXRGcmFtZUJ5SW5kZXgiLCJmcmFtZUluZGV4IiwiZm91bmRJbkNhY2hlIiwiZGVjb2RlIiwiY29tcGxldGVGcmFtZXNPbmx5IiwiaW1hZ2UiLCJ0aW1lSW5TZWNvbmRzIiwidGltZXN0YW1wIiwiY2xlYXJDYWNoZSIsImNsb3NlVG9UaW1lSW5TZWMiLCJpdGVtc0luQ2FjaGUiLCJzb3J0QnlDbG9zZXN0VG9DdXJyZW50VGltZSIsInNvcnQiLCJhIiwiYiIsImFEaWZmIiwiYWJzIiwiYkRpZmYiLCJpIiwiZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlciIsImFjdHVhbFRpbWVJblNlYyIsImZyYW1lc0JlZm9yZSIsImJpZ2dlc3RJbmRleCIsIm1hcCIsImYiLCJmcmFtZUNvdW50IiwiZ2V0RnJhbWUiLCJjbG9zZXN0IiwicmVzb2x2ZUFuaW1hdGVkSW1hZ2VTb3VyY2UiLCJzcmMiLCJVUkwiLCJvcmlnaW4iLCJocmVmIiwianN4MTAiLCJBbmltYXRlZEltYWdlIiwib25FcnJvciIsIm1vdW50U3RhdGUiLCJpc01vdW50ZWQiLCJpbWFnZURlY29kZXIiLCJzZXRJbWFnZURlY29kZXIiLCJkZWNvZGVIYW5kbGUiLCJjdXJyZW50VGltZVJlZiIsImQiLCJkZWxheSIsInZpZGVvRnJhbWUiLCJ1c2VDb250ZXh0MTEiLCJ1c2VFZmZlY3Q1IiwidXNlU3RhdGU3IiwiY3JlYXRlQ29udGV4dDEwIiwidXNlQ2FsbGJhY2s1IiwidXNlTGF5b3V0RWZmZWN0MiIsInVzZU1lbW8xMCIsInVzZVN0YXRlNiIsInZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZSIsImZpbGVuYW1lIiwidHJpbSIsIm1hdGNoIiwidmFsaWRhdGVDb250ZW50IiwiVWludDhBcnJheSIsInZhbGlkYXRlUmVuZGVyQXNzZXQiLCJhcnRpZmFjdCIsImNvbnRlbnRUeXBlIiwianN4MTEiLCJSZW5kZXJBc3NldE1hbmFnZXIiLCJyZWdpc3RlclJlbmRlckFzc2V0IiwidW5yZWdpc3RlclJlbmRlckFzc2V0IiwicmVuZGVyQXNzZXRzIiwiUmVuZGVyQXNzZXRNYW5hZ2VyUHJvdmlkZXIiLCJzZXRSZW5kZXJBc3NldHMiLCJyZW5kZXJBc3NldCIsImFzc2V0cyIsImFzc3RzIiwicmVtb3Rpb25fY29sbGVjdEFzc2V0cyIsIkFydGlmYWN0VGh1bWJuYWlsIiwiU3ltYm9sIiwiQXJ0aWZhY3QiLCJidG9hIiwiVGV4dERlY29kZXIiLCJUaHVtYm5haWwiLCJmb3J3YXJkUmVmNiIsInVzZUNhbGxiYWNrMTEiLCJ1c2VDb250ZXh0MjMiLCJnZXRBYnNvbHV0ZVNyYyIsInJlbGF0aXZlU3JjIiwiY2FsY3VsYXRlTG9vcER1cmF0aW9uIiwiZW5kQXQiLCJtZWRpYUR1cmF0aW9uIiwic3RhcnRGcm9tIiwiYWN0dWFsRHVyYXRpb24iLCJmbG9vciIsIlJlYWN0OSIsImNyZWF0ZUNvbnRleHQxMSIsInVzZU1lbW8xMSIsImpzeDEyIiwiTG9vcENvbnRleHQiLCJ1c2VMb29wIiwiTG9vcCIsInRpbWVzIiwiY3VycmVudEZyYW1lIiwiY29tcER1cmF0aW9uIiwibWF4VGltZXMiLCJhY3R1YWxUaW1lcyIsIm1heEZyYW1lIiwiaXRlcmF0aW9uIiwic3RhcnQiLCJudW1iZXJPZlRpbWVzIiwic3RhcnRPZmZzZXQiLCJsb29wQ29udGV4dCIsInVzZUNvbnRleHQxMiIsInBsYXliYWNrTG9nZ2luZyIsInRhZyIsIm1vdW50VGltZSIsInRhZ3MiLCJjcmVhdGVDb250ZXh0MTIiLCJ1c2VFZmZlY3Q2IiwidXNlU3RhdGU4IiwianN4MTMiLCJQcmVsb2FkQ29udGV4dCIsInByZWxvYWRzIiwidXBkYXRlcnMiLCJzZXRQcmVsb2FkcyIsInVwZGF0ZXIiLCJmb3JFYWNoIiwidSIsIlByZWZldGNoUHJvdmlkZXIiLCJfcHJlbG9hZHMiLCJfc2V0UHJlbG9hZHMiLCJ1cGRhdGVyRnVuY3Rpb24iLCJyZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQiLCJoYXNoSW5kZXgiLCJnZXRTcmNXaXRob3V0SGFzaCIsInNsaWNlIiwidXNlUHJlbG9hZCIsInByZWxvYWRzMiIsImhhc2hGcmFnbWVudEluZGV4Iiwid2l0aG91dEhhc2hGcmFnbWVudCIsImJsb2JUb0Jhc2U2NCIsImJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWQiLCJkYXRhVXJsIiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJnZXRCbG9iRnJvbVJlYWRlciIsImNvbnRlbnRMZW5ndGgiLCJvblByb2dyZXNzIiwicmVjZWl2ZWRMZW5ndGgiLCJjaHVua3MiLCJkb25lIiwicmVhZCIsImxvYWRlZEJ5dGVzIiwidG90YWxCeXRlcyIsImNodW5rc0FsbCIsImNodW5rIiwiQmxvYiIsInByZWZldGNoIiwibWV0aG9kIiwic3JjV2l0aG91dEhhc2giLCJmcmVlIiwid2FpdFVudGlsRG9uZSIsImNhbmNlbGVkIiwib2JqZWN0VXJsIiwicmVqIiwiY2FuQmVBYm9ydGVkIiwiY3JlZGVudGlhbHMiLCJvayIsInN0YXR1cyIsImhlYWRlckNvbnRlbnRUeXBlIiwiaGFzUHJvcGVyQ29udGVudFR5cGUiLCJnZXRSZWFkZXIiLCJwYXJzZUludCIsImJ1ZiIsImFjdHVhbEJsb2IiLCJjcmVhdGVPYmplY3RVUkwiLCJ1cmwiLCJwIiwicmV2b2tlT2JqZWN0VVJMIiwiY29weSIsInZhbGlkYXRlTWVkaWFQcm9wcyIsInZvbHVtZSIsInZhbGlkYXRlU3RhcnRGcm9tUHJvcHMiLCJjcmVhdGVDb250ZXh0MTMiLCJ1c2VNZW1vMTIiLCJ1c2VSZWR1Y2VyIiwianN4MTQiLCJkdXJhdGlvblJlZHVjZXIiLCJhY3Rpb24iLCJhYnNvbHV0ZVNyYyIsImR1cmF0aW9uSW5TZWNvbmRzIiwiRHVyYXRpb25zQ29udGV4dCIsImR1cmF0aW9ucyIsInNldER1cmF0aW9ucyIsIkR1cmF0aW9uc0NvbnRleHRQcm92aWRlciIsImZvcndhcmRSZWY0IiwidXNlQ29udGV4dDIxIiwidXNlRWZmZWN0MTQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlNSIsInVzZU1lbW8xOSIsInVzZVJlZjExIiwidXNlU3RhdGUxMyIsImNyZWF0ZUNvbnRleHQxNCIsIlJlYWN0MTIiLCJMb2dMZXZlbENvbnRleHQiLCJ1c2VMb2dMZXZlbCIsInVzZU1vdW50VGltZSIsIm11bGJlcnJ5MzIiLCJ0IiwiaW11bCIsImhhc2hDb2RlIiwic3RyIiwiY2hyIiwiaGFzaCIsImNoYXJDb2RlQXQiLCJzZWVkIiwiZHVtbXkiLCJ1c2VMYXlvdXRFZmZlY3QzIiwidXNlUmVmNCIsIndhcm5lZCIsIndhcm5PbmNlIiwiZ2V0U2hvdWxkQW1wbGlmeSIsInVzZUFtcGxpZmljYXRpb24iLCJtZWRpYVJlZiIsInNob3VsZEFtcGxpZnkiLCJhdWRpb1N0dWZmUmVmIiwiY3VycmVudFZvbHVtZVJlZiIsIkF1ZGlvQ29udGV4dCIsImF1ZGlvQ29udGV4dCIsImxhdGVuY3lIaW50Iiwic291cmNlIiwiTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlIiwibWVkaWFFbGVtZW50IiwiZ2Fpbk5vZGUiLCJHYWluTm9kZSIsImdhaW4iLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJ2YWx1ZVRvU2V0IiwidXNlQ29udGV4dDE1IiwidXNlRWZmZWN0NyIsInVzZU1lbW8xMyIsInVzZVN0YXRlOSIsInVzZUNvbnRleHQxNCIsInVzZU1lZGlhU3RhcnRzQXQiLCJzdGFydHNBdCIsInVzZUZyYW1lRm9yVm9sdW1lUHJvcCIsImJlaGF2aW9yIiwibG9vcCIsImdldEFzc2V0RGlzcGxheU5hbWUiLCJ0ZXN0Iiwic3Vic3RyaW5nIiwic3BsaXR0ZWQiLCJzcGxpdCIsImZsYXQiLCJwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yIiwibWVkaWFUeXBlIiwib25BdXRvUGxheUVycm9yIiwicmVhc29uIiwicHJvbSIsInBsYXkiLCJtdXRlZCIsImV2YWx1YXRlVm9sdW1lIiwibWVkaWFWb2x1bWUiLCJldmFsdWF0ZWQiLCJkaWRXYXJuIiwid2Fybk9uY2UyIiwidXNlTWVkaWFJblRpbWVsaW5lIiwiaXNQcmVtb3VudGluZyIsImFjdHVhbEZyb20iLCJpbml0aWFsVm9sdW1lIiwiZG9lc1ZvbHVtZUNoYW5nZSIsInZvbHVtZXMiLCJBcnJheSIsImZpbGwiLCJOT0RFX0VOViIsInN0YXJ0TWVkaWFGcm9tIiwidXNlQ2FsbGJhY2s4IiwidXNlQ29udGV4dDE4IiwidXNlRWZmZWN0MTEiLCJ1c2VSZWY5IiwidXNlQ2FsbGJhY2s3IiwidXNlTWVtbzE2IiwidXNlUmVmNiIsInVzZUNvbnRleHQxNyIsInVzZU1lbW8xNSIsIlJlYWN0MTMiLCJ1c2VDYWxsYmFjazYiLCJ1c2VDb250ZXh0MTYiLCJ1c2VFZmZlY3Q4IiwidXNlTGF5b3V0RWZmZWN0NCIsInVzZU1lbW8xNCIsInVzZVJlZjUiLCJ1c2VTdGF0ZTEwIiwianN4MTUiLCJ1c2VCdWZmZXJNYW5hZ2VyIiwiYmxvY2tzIiwic2V0QmxvY2tzIiwib25CdWZmZXJpbmdDYWxsYmFja3MiLCJzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrcyIsIm9uUmVzdW1lQ2FsbGJhY2tzIiwic2V0T25SZXN1bWVDYWxsYmFja3MiLCJidWZmZXJpbmciLCJhZGRCbG9jayIsImJsb2NrIiwidW5ibG9jayIsIm5ld0FyciIsImJ4IiwibGlzdGVuRm9yQnVmZmVyaW5nIiwiY2FsbGJhY2siLCJyZW1vdmUiLCJjYiIsImxpc3RlbkZvclJlc3VtZSIsIkJ1ZmZlcmluZ0NvbnRleHRSZWFjdCIsIkJ1ZmZlcmluZ1Byb3ZpZGVyIiwiYnVmZmVyTWFuYWdlciIsInVzZUlzUGxheWVyQnVmZmVyaW5nIiwiaXNCdWZmZXJpbmciLCJzZXRJc0J1ZmZlcmluZyIsIm9uQnVmZmVyIiwib25SZXN1bWUiLCJ1c2VCdWZmZXJTdGF0ZSIsImJ1ZmZlciIsImRlbGF5UGxheWJhY2siLCJpc1NhZmFyaVdlYmtpdCIsImlzU2FmYXJpIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lIiwib25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQiLCJwYXVzZVdoZW5CdWZmZXJpbmciLCJidWZmZXJpbmdSZWYiLCJidWZmZXJVbnRpbEZpcnN0RnJhbWUiLCJyZXF1ZXN0ZWRUaW1lIiwicmVhZHlTdGF0ZSIsIkhBVkVfRU5PVUdIX0RBVEEiLCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrIiwicGxheWJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25jZSIsIm9uRW5kZWRPclBhdXNlT3JDYW5QbGF5IiwiZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQiLCJtZWRpYVRpbWUiLCJhZGRFdmVudExpc3RlbmVyIiwidXNlUmVmNyIsInRvU2Vjb25kcyIsInJvdW5kIiwiaXNJb3NTYWZhcmkiLCJpc0lwYWRJUG9kSVBob25lIiwiaXNBcHBsZVdlYktpdCIsImlzSU9TU2FmYXJpQW5kQmxvYiIsImFjdHVhbFNyYyIsImdldFZpZGVvRnJhZ21lbnRTdGFydCIsImdldFZpZGVvRnJhZ21lbnRFbmQiLCJhcHBlbmRWaWRlb0ZyYWdtZW50IiwiZXhpc3RpbmdIYXNoIiwid2l0aFN0YXJ0SGFzaCIsImlzU3Vic2V0T2ZEdXJhdGlvbiIsInByZXZTdGFydEZyb20iLCJuZXdTdGFydEZyb20iLCJwcmV2RHVyYXRpb24iLCJuZXdEdXJhdGlvbiIsInByZXZpb3VzRnJvbSIsIm5ld0Zyb20iLCJwcmV2aW91c0VuZCIsIm5ld0VuZCIsInVzZUFwcGVuZFZpZGVvRnJhZ21lbnQiLCJpbml0aWFsQWN0dWFsU3JjIiwiaW5pdGlhbEFjdHVhbEZyb20iLCJpbml0aWFsRHVyYXRpb24iLCJhY3R1YWxGcm9tUmVmIiwiYXBwZW5kZWQiLCJzZWVrIiwid2h5IiwidGltZVRvU2V0IiwidG9GaXhlZCIsInVzZUVmZmVjdDkiLCJ1c2VTdGF0ZTExIiwidXNlTWVkaWFCdWZmZXJpbmciLCJlbGVtZW50Iiwic2hvdWxkQnVmZmVyIiwiY2xlYW51cEZucyIsIkhBVkVfRlVUVVJFX0RBVEEiLCJsb2FkIiwiY2xlYW51cCIsImRpZERvU29tZXRoaW5nIiwiZm4iLCJwcmV2aW91cyIsImJsb2NrTWVkaWEiLCJvbkNhblBsYXkiLCJpbml0IiwiY2xlYW51cFJlYXNvbiIsIm9uV2FpdGluZyIsInVzZUVmZmVjdDEwIiwidXNlUmVmOCIsInVzZVJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSIsImxhc3RTZWVrIiwidmlkZW9UYWciLCJjYW5jZWwiLCJyZXF1ZXN0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VUb0xhc3RTZWVrIiwiY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrIiwiaW50ZXJwb2xhdGVGdW5jdGlvbiIsImlucHV0IiwiaW5wdXRSYW5nZSIsIm91dHB1dFJhbmdlIiwiZXh0cmFwb2xhdGVMZWZ0IiwiZXh0cmFwb2xhdGVSaWdodCIsImVhc2luZyIsImlucHV0TWluIiwiaW5wdXRNYXgiLCJvdXRwdXRNaW4iLCJvdXRwdXRNYXgiLCJyYW5nZSIsImZpbmRSYW5nZSIsImNoZWNrVmFsaWRJbnB1dFJhbmdlIiwiYXJyIiwiY2hlY2tJbmZpbml0ZVJhbmdlIiwiaW50ZXJwb2xhdGUiLCJudW0iLCJnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCIsImdldE1lZGlhVGltZSIsImV4cGVjdGVkRnJhbWUiLCJtc1BlckZyYW1lIiwiYWxyZWFkeVdhcm5lZCIsIndhcm5BYm91dE5vblNlZWthYmxlTWVkaWEiLCJzZWVrYWJsZSIsImVuZCIsIm1zZyIsInVzZU1lZGlhUGxheWJhY2siLCJsb2NhbFBsYXliYWNrUmF0ZSIsIm9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IiLCJhY2NlcHRhYmxlVGltZXNoaWZ0IiwidXNlclByZWZlcnJlZFZvbHVtZSIsImdsb2JhbFBsYXliYWNrUmF0ZSIsIm1lZGlhU3RhcnRzQXQiLCJsYXN0U2Vla0R1ZVRvU2hpZnQiLCJpc1ZhcmlhYmxlRnBzVmlkZW9NYXAiLCJkZXNpcmVkVW5jbGFtcGVkVGltZSIsImlzTWVkaWFUYWdCdWZmZXJpbmciLCJhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiIsIkRFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0siLCJERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTiIsImRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0IiwiaXNQbGF5ZXJCdWZmZXJpbmciLCJwYXVzZWQiLCJwYXVzZSIsImlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQiLCJwbGF5ZXJCdWZmZXJpbmdOb3RTdGF0ZUJ1dExpdmUiLCJ0YWdOYW1lIiwicGxheWJhY2tSYXRlVG9TZXQiLCJzaG91bGRCZVRpbWUiLCJtZWRpYVRhZ1RpbWUiLCJydmNUaW1lIiwiaXNWYXJpYWJsZUZwc1ZpZGVvIiwidGltZVNoaWZ0TWVkaWFUYWciLCJ0aW1lU2hpZnRSdmNUYWciLCJ0aW1lU2hpZnQiLCJzZWVrVGhyZXNob2xkIiwibWFrZXNTZW5zZVRvU2VlayIsImlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyIsInBhdXNlZENvbmRpdGlvbiIsImVuZGVkIiwiZmlyc3RGcmFtZUNvbmRpdGlvbiIsInVzZUNhbGxiYWNrOSIsInVzZUVmZmVjdDEyIiwiRkxPQVRJTkdfUE9JTlRfRVJST1JfVEhSRVNIT0xEIiwiaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSIsIm51bTEiLCJudW0yIiwidXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyIsInZvbHVtZVByb3BGcmFtZSIsImFkanVzdFZvbHVtZSIsIm1lZGlhIiwiaGFuZGxlVm9sdW1lQ2hhbmdlIiwiY3JlYXRlQ29udGV4dDE1IiwidXNlQ29udGV4dDE5IiwidXNlTWVtbzE3IiwiTWVkaWFWb2x1bWVDb250ZXh0IiwibWVkaWFNdXRlZCIsIlNldE1lZGlhVm9sdW1lQ29udGV4dCIsInNldE1lZGlhTXV0ZWQiLCJzZXRNZWRpYVZvbHVtZSIsInVzZU1lZGlhVm9sdW1lU3RhdGUiLCJ1c2VNZWRpYU11dGVkU3RhdGUiLCJSZWFjdDE0IiwiY3JlYXRlQ29udGV4dDE2IiwiY3JlYXRlUmVmMiIsInVzZUNhbGxiYWNrMTAiLCJ1c2VDb250ZXh0MjAiLCJ1c2VFZmZlY3QxMyIsInVzZU1lbW8xOCIsInVzZVJlZjEwIiwidXNlU3RhdGUxMiIsImpzeDE2IiwianN4cyIsIkVNUFRZX0FVRElPIiwiY29tcGFyZVByb3BzIiwib2JqMSIsIm9iajIiLCJrZXlzQSIsImtleXMiLCJrZXlzQiIsImRpZFByb3BDaGFuZ2UiLCJuZXdQcm9wIiwicHJldlByb3AiLCJ0b1N0cmluZyIsIlNoYXJlZEF1ZGlvQ29udGV4dCIsIlNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyIiwibnVtYmVyT2ZBdWRpb1RhZ3MiLCJhdWRpb3MiLCJpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3MiLCJyZWZzIiwidGFrZW5BdWRpb3MiLCJyZXJlbmRlckF1ZGlvcyIsInJlZ2lzdGVyQXVkaW8iLCJhdWQiLCJhdWRpb0lkIiwiZm91bmQiLCJmaXJzdEZyZWVBdWRpbyIsImZpbmRJbmRleCIsImNsb25lZCIsIm5ld0VsZW0iLCJlbCIsInVucmVnaXN0ZXJBdWRpbyIsImluZGV4IiwidXBkYXRlQXVkaW8iLCJjaGFuZ2VkIiwicHJldkEiLCJwbGF5QWxsQXVkaW9zIiwicmVzZXRBdWRpbyIsInByZWxvYWQiLCJ1c2VTaGFyZWRBdWRpbyIsImVsZW0iLCJlZmZlY3RUb1VzZSIsInVzZUluc2VydGlvbkVmZmVjdCIsImRvY3VtZW50IiwianN4MTciLCJBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uIiwiaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cyIsInNob3VsZFByZU1vdW50QXVkaW9UYWdzIiwib25EdXJhdGlvbiIsImFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMiLCJfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbiIsIl9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCIsImFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciIsImxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yIiwibmF0aXZlUHJvcHMiLCJwcmVsb2FkZWRTcmMiLCJ0aW1lbGluZUlkIiwicHJvcHNUb1Bhc3MiLCJhdWRpb1JlZiIsImN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2siLCJvbkxvYWRlZE1ldGFkYXRhIiwiQXVkaW9Gb3JQcmV2aWV3IiwiZm9yd2FyZFJlZjUiLCJ1c2VDb250ZXh0MjIiLCJ1c2VFZmZlY3QxNSIsInVzZUltcGVyYXRpdmVIYW5kbGU2IiwidXNlTGF5b3V0RWZmZWN0NSIsInVzZU1lbW8yMCIsInVzZVJlZjEyIiwianN4MTgiLCJBdWRpb0ZvclJlbmRlcmluZ1JlZkZvcndhcmRpbmdGdW5jdGlvbiIsInZvbHVtZVByb3AiLCJ0b25lRnJlcXVlbmN5IiwiZGVsYXlSZW5kZXJSZXRyaWVzIiwiZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMiLCJyZW1vdGlvbl9hdWRpb0VuYWJsZWQiLCJtZWRpYUZyYW1lIiwiYXVkaW9TdGFydEZyYW1lIiwibmVlZHNUb1JlbmRlckF1ZGlvVGFnIiwibmV3SGFuZGxlIiwiZGlkTG9hZCIsIkF1ZGlvRm9yUmVuZGVyaW5nIiwianN4MTkiLCJBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbiIsInByb3BzT3RoZXJUaGFuTG9vcCIsImVudmlyb25tZW50IiwiZSIsImN1cnJlbnRUYXJnZXQiLCJlcnJNZXNzYWdlIiwiZHVyYXRpb25GZXRjaGVkIiwiQXVkaW8iLCJzdGFydEZyb21GcmFtZU5vIiwiZW5kQXRGcmFtZU5vIiwiU3VzcGVuc2UiLCJ1c2VDb250ZXh0MjUiLCJ1c2VFZmZlY3QxNyIsImNyZWF0ZVBvcnRhbCIsImNyZWF0ZUNvbnRleHQxNyIsInVzZUNvbnRleHQyNCIsInVzZUVmZmVjdDE2IiwidXNlTWVtbzIxIiwiZ2V0UmVnZXgiLCJpc0ZvbGRlck5hbWVWYWxpZCIsInZhbGlkYXRlRm9sZGVyTmFtZSIsImludmFsaWRGb2xkZXJOYW1lRXJyb3JNZXNzYWdlIiwianN4MjAiLCJGb2xkZXJDb250ZXh0IiwiZm9sZGVyTmFtZSIsInBhcmVudE5hbWUiLCJGb2xkZXIiLCJwYXJlbnROYW1lQXJyIiwianN4MjEiLCJqc3hzMiIsInJvdGF0ZSIsInRyYW5zZm9ybSIsIklDT05fU0laRSIsImNvbG9yIiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiY29udGFpbmVyIiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiTG9hZGluZyIsInZpZXdCb3giLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVqb2luIiwiX3BvcnRhbE5vZGUiLCJwb3J0YWxOb2RlIiwiY29udGFpbmVyTm9kZSIsImFwcGVuZENoaWxkIiwiUmVhY3QxOCIsInVzZU1lbW8yMiIsInVzZUxhenlDb21wb25lbnQiLCJjb21wUHJvcHMiLCJjb21wb25lbnROYW1lIiwibm9TdXNwZW5zZSIsImxhenkiLCJkZWZhdWx0IiwibGF6eUNvbXBvbmVudCIsImdldFJlZ2V4MiIsImlzQ29tcG9zaXRpb25JZFZhbGlkIiwidmFsaWRhdGVDb21wb3NpdGlvbklkIiwiaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlIiwidmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyIsImlzQXJyYXkiLCJqc3gyMiIsIkZhbGxiYWNrIiwiZmFsbGJhY2siLCJJbm5lckNvbXBvc2l0aW9uIiwic2NoZW1hIiwiY29tcE1hbmFnZXIiLCJjYW5Vc2VDb21wb3NpdGlvbiIsInBhcmVudEZvbGRlck5hbWUiLCJDb21wIiwiQ29tcG9zaXRpb24iLCJwcm9wczIiLCJORVdUT05fSVRFUkFUSU9OUyIsIk5FV1RPTl9NSU5fU0xPUEUiLCJTVUJESVZJU0lPTl9QUkVDSVNJT04iLCJTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyIsImtTcGxpbmVUYWJsZVNpemUiLCJrU2FtcGxlU3RlcFNpemUiLCJmbG9hdDMyQXJyYXlTdXBwb3J0ZWQiLCJGbG9hdDMyQXJyYXkiLCJhQTEiLCJhQTIiLCJjYWxjQmV6aWVyIiwiYVQiLCJnZXRTbG9wZSIsImJpbmFyeVN1YmRpdmlkZSIsImFYIiwiX2FBIiwiX2FCIiwibVgxIiwibVgyIiwiY3VycmVudFgiLCJjdXJyZW50VCIsImFBIiwiYUIiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsIl9hR3Vlc3NUIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImJlemllciIsIm1ZMSIsIm1ZMiIsInNhbXBsZVZhbHVlcyIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIngiLCJFYXNpbmciLCJzdGVwMCIsIm4iLCJzdGVwMSIsImxpbmVhciIsImVhc2UiLCJxdWFkIiwiY3ViaWMiLCJwb2x5Iiwic2luIiwiY29zIiwiUEkiLCJjaXJjbGUiLCJzcXJ0IiwiZXhwIiwiZWxhc3RpYyIsImJvdW5jaW5lc3MiLCJiYWNrIiwiYm91bmNlIiwidDJfIiwidDIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImluIiwib3V0IiwiaW5PdXQiLCJFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyIsIndhcm5lZFNlcnZlciIsIndhcm5lZFBsYXllciIsIndhcm5TZXJ2ZXJPbmNlIiwid2FyblBsYXllck9uY2UiLCJnZXRTdGF0aWNGaWxlcyIsInJlbW90aW9uX3N0YXRpY0ZpbGVzIiwiZm9yd2FyZFJlZjciLCJ1c2VDYWxsYmFjazEyIiwidXNlU3RhdGUxNCIsImpzeDIzIiwiSUZyYW1lUmVmRm9yd2FyZGluZyIsIm9uTG9hZCIsImRpZEdldEVycm9yIiwiSUZyYW1lIiwiZm9yd2FyZFJlZjgiLCJ1c2VDYWxsYmFjazEzIiwidXNlQ29udGV4dDI2IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTciLCJ1c2VMYXlvdXRFZmZlY3Q2IiwidXNlUmVmMTMiLCJqc3gyNCIsImV4cG9uZW50aWFsQmFja29mZiIsImVycm9yQ291bnQiLCJJbWdSZWZGb3J3YXJkaW5nIiwibWF4UmV0cmllcyIsInBhdXNlV2hlbkxvYWRpbmciLCJvbkltYWdlRnJhbWUiLCJpbWFnZVJlZiIsImVycm9ycyIsInJldHJ5SW4iLCJjdXJyZW50U3JjIiwibmV3U3JjIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiYmFja29mZiIsInVubW91bnRlZCIsIm9uQ29tcGxldGUiLCJjb21wbGV0ZSIsIkltZyIsImNyZWF0ZVJlZjMiLCJSZWFjdDIyIiwidXNlQ2FsbGJhY2sxNCIsInVzZUltcGVyYXRpdmVIYW5kbGU4IiwidXNlTWVtbzIzIiwidXNlUmVmMTQiLCJ1c2VTdGF0ZTE1IiwianN4MjUiLCJjb21wb3NpdGlvbnNSZWYiLCJDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciIsInNldENvbXBvc2l0aW9ucyIsImN1cnJlbnRjb21wb3NpdGlvbnNSZWYiLCJzZXRGb2xkZXJzIiwidXBkYXRlQ29tcG9zaXRpb25zIiwidXBkYXRlQ29tcHMiLCJjb21wcyIsInVwZGF0ZWQiLCJjb21wIiwiYzIiLCJhMiIsImIyIiwicHJldkZvbGRlcnMiLCJnZXRDb21wb3NpdGlvbnMiLCJuZXdEZWZhdWx0UHJvcHMiLCJzZXR0ZXJzIiwiZXhwb3J0c19kZWZhdWx0X2NzcyIsIm1ha2VEZWZhdWx0UHJldmlld0NTUyIsImluamVjdENTUyIsIk9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FIiwiaW5qZWN0ZWQiLCJjc3MiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjcmVhdGVUZXh0Tm9kZSIsInByZXBlbmQiLCJzY29wZSIsImJhY2tncm91bmRDb2xvciIsIlJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCIsImdldFByZXZpZXdEb21FbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJSb290IiwibGlzdGVuZXJzIiwicmVnaXN0ZXJSb290IiwibCIsImdldFJvb3QiLCJ3YWl0Rm9yUm9vdCIsInVzZUVmZmVjdDE4IiwidXNlTGF5b3V0RWZmZWN0NyIsInVzZU1lbW8yNCIsInVzZVJlZjE1IiwidXNlU3RhdGUxNiIsImpzeDI2IiwiUmVtb3Rpb25Sb290IiwicmVtb3Rpb25Sb290SWQiLCJzZXRGYXN0UmVmcmVzaGVzIiwicmVtb3Rpb25fc2V0RnJhbWUiLCJhdHRlbXB0IiwiYXN5bmNVcGRhdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lbGluZUNvbnRleHRWYWx1ZSIsInNldFRpbWVsaW5lQ29udGV4dFZhbHVlIiwibm9uY2VDb250ZXh0IiwiY291bnRlciIsIl9fd2VicGFja19tb2R1bGVfXyIsImhvdCIsImFkZFN0YXR1c0hhbmRsZXIiLCJsb2dnaW5nIiwiZ2V0RW52VmFyaWFibGVzIiwicmVtb3Rpb25fZW52VmFyaWFibGVzIiwic2V0dXBFbnZWYXJpYWJsZXMiLCJSZWFjdDI0IiwiY3JlYXRlQ29udGV4dDE4IiwiQ3VycmVudFNjYWxlQ29udGV4dCIsIlByZXZpZXdTaXplQ29udGV4dCIsInNldFNpemUiLCJzaXplIiwidHJhbnNsYXRpb24iLCJ5IiwiY2FsY3VsYXRlU2NhbGUiLCJwcmV2aWV3U2l6ZSIsImhlaWdodFJhdGlvIiwid2lkdGhSYXRpbyIsInVzZUN1cnJlbnRTY2FsZSIsImhhc0NvbnRleHQiLCJ6b29tQ29udGV4dCIsImNvbmZpZyIsImRvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb24iLCJzY2FsZSIsIldBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUyIsIndhdGNoU3RhdGljRmlsZSIsImZpbGVOYW1lIiwid2l0aG91dFN0YXRpY0Jhc2UiLCJ3aXRob3V0TGVhZGluZ1NsYXNoIiwicHJldkZpbGVEYXRhIiwiZmlsZSIsImNoZWNrRmlsZSIsImV2ZW50Iiwic3RhdGljRmlsZXMiLCJmaWxlcyIsIm5ld0ZpbGVEYXRhIiwibGFzdE1vZGlmaWVkIiwiUmVhY3QyNSIsInVzZU1lbW8yNSIsImpzeDI3IiwidXNlUmVtb3Rpb25Db250ZXh0cyIsImNvbXBvc2l0aW9uTWFuYWdlckN0eCIsInNldFRpbWVsaW5lQ29udGV4dCIsImNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0IiwicHJlbG9hZENvbnRleHQiLCJyZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0IiwicmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCIsInNlcXVlbmNlTWFuYWdlckNvbnRleHQiLCJidWZmZXJNYW5hZ2VyQ29udGV4dCIsImxvZ0xldmVsQ29udGV4dCIsIlJlbW90aW9uQ29udGV4dFByb3ZpZGVyIiwiY29udGV4dHMiLCJjb21wb3NpdGlvblNlbGVjdG9yUmVmIiwiSW50ZXJuYWxzIiwiVGltZWxpbmUiLCJDU1NVdGlscyIsIk5VTUJFUiIsIlBFUkNFTlRBR0UiLCJjYWxsIiwiZ2V0TWF0Y2hlcnMiLCJjYWNoZWRNYXRjaGVycyIsInJnYiIsInJnYmEiLCJoc2wiLCJoc2xhIiwiaGV4MyIsImhleDQiLCJoZXg1IiwiaGV4NiIsImhleDgiLCJSZWdFeHAiLCJodWUycmdiIiwicSIsImhzbFRvUmdiIiwiZyIsInBhcnNlMjU1IiwiaW50IiwicGFyc2UzNjAiLCJwYXJzZUZsb2F0IiwicGFyc2UxIiwicGFyc2VQZXJjZW50YWdlIiwiY29sb3JOYW1lcyIsInRyYW5zcGFyZW50IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJidXJudHNpZW5uYSIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIm5vcm1hbGl6ZUNvbG9yIiwibWF0Y2hlcnMiLCJleGVjIiwicmdiYUNvbG9yIiwiYWxwaGEiLCJwcm9jZXNzQ29sb3IiLCJub3JtYWxpemVkQ29sb3IiLCJpbnRlcnBvbGF0ZUNvbG9yc1JHQiIsImNvbG9ycyIsInVucm91bmRlZCIsImludGVycG9sYXRlQ29sb3JzIiwicHJvY2Vzc2VkT3V0cHV0UmFuZ2UiLCJ2YWxpZGF0ZUZyYW1lIiwiUmFuZ2VFcnJvciIsImdldE9mZnRocmVhZFZpZGVvU291cmNlIiwidG9uZU1hcHBlZCIsInJlbW90aW9uX3Byb3h5UG9ydCIsImVuY29kZVVSSUNvbXBvbmVudCIsIkNoaWxkcmVuIiwiZm9yd2FyZFJlZjkiLCJ1c2VNZW1vMjYiLCJSZWFjdDI2IiwiZmxhdHRlbkNoaWxkcmVuIiwiY2hpbGRyZW5BcnJheSIsInRvQXJyYXkiLCJmbGF0Q2hpbGRyZW4iLCJjaGlsZCIsIkZyYWdtZW50IiwiY29uY2F0IiwiUmVhY3QyNyIsImNyZWF0ZUNvbnRleHQxOSIsImpzeDI4IiwiSXNJbnNpZGVTZXJpZXNDb250ZXh0IiwiSXNJbnNpZGVTZXJpZXNDb250YWluZXIiLCJJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyIiwidXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMiLCJpc0luc2lkZVNlcmllcyIsImpzeDI5IiwiU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJfcmVmIiwiU2VyaWVzU2VxdWVuY2UiLCJTZXJpZXMiLCJjaGlsZHJlblZhbHVlIiwic3RhcnRGcmFtZSIsImZsYXR0ZW5lZENoaWxkcmVuIiwiY2FzdGVkQ2hpbGQiLCJkZWJ1Z0luZm8iLCJkdXJhdGlvbkluRnJhbWVzUHJvcCIsIl9jaGlsZHJlbiIsInBhc3NlZFByb3BzIiwib2Zmc2V0IiwiY3VycmVudFN0YXJ0RnJhbWUiLCJ2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uIiwiZHVyIiwiZGVmYXVsdFNwcmluZ0NvbmZpZyIsImRhbXBpbmciLCJtYXNzIiwic3RpZmZuZXNzIiwib3ZlcnNob290Q2xhbXBpbmciLCJhZHZhbmNlQ2FjaGUiLCJhZHZhbmNlIiwiYW5pbWF0aW9uIiwidG9WYWx1ZSIsImxhc3RUaW1lc3RhbXAiLCJ2ZWxvY2l0eSIsImRlbHRhVGltZSIsIm0iLCJrIiwiY2FjaGVLZXkiLCJ2MCIsIngwIiwiemV0YSIsIm9tZWdhMCIsIm9tZWdhMSIsInNpbjEiLCJjb3MxIiwidW5kZXJEYW1wZWRFbnZlbG9wZSIsInVuZGVyRGFtcGVkRnJhZzEiLCJ1bmRlckRhbXBlZFBvc2l0aW9uIiwidW5kZXJEYW1wZWRWZWxvY2l0eSIsImNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSIsImNyaXRpY2FsbHlEYW1wZWRQb3NpdGlvbiIsImNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eSIsImFuaW1hdGlvbk5vZGUiLCJwcmV2UG9zaXRpb24iLCJjYWxjdWxhdGlvbkNhY2hlIiwic3ByaW5nQ2FsY3VsYXRpb24iLCJ0byIsImZyYW1lQ2xhbXBlZCIsInVuZXZlblJlc3QiLCJtZWFzdXJlU3ByaW5nIiwidGhyZXNob2xkIiwiaGFzIiwiZmluaXNoZWRGcmFtZSIsImNhbGMiLCJjYWxjRGlmZmVyZW5jZSIsInNwcmluZyIsInBhc3NlZEZyYW1lIiwicGFzc2VkRHVyYXRpb25JbkZyYW1lcyIsImR1cmF0aW9uUmVzdFRocmVzaG9sZCIsInJldmVyc2UiLCJuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uIiwibmF0dXJhbER1cmF0aW9uIiwibmF0dXJhbER1cmF0aW9uR2V0dGVyIiwicmV2ZXJzZVByb2Nlc3NlZCIsImRlbGF5UHJvY2Vzc2VkIiwiZHVyYXRpb25Qcm9jZXNzZWQiLCJzcHIiLCJpbm5lciIsImludGVycG9sYXRlZCIsInByb2JsZW1hdGljQ2hhcmFjdGVycyIsImRpZFdhcm4yIiwid2Fybk9uY2UzIiwiaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIiLCJwYXRoIiwiY29udGFpbnNIZXgiLCJoZXhDb2RlIiwidHJpbUxlYWRpbmdTbGFzaCIsImVuY29kZUJ5U3BsaXR0aW5nIiwic3BsaXRCeVNsYXNoIiwiZW5jb2RlZEFycmF5IiwibWVyZ2VkIiwic3RhdGljRmlsZSIsImluY2x1ZGVzSGV4IiwicHJlcHJvY2Vzc2VkIiwicHJlcGFyc2VkIiwiUmVhY3QyOSIsIlN0aWxsIiwidXNlQ2FsbGJhY2sxNiIsInVzZUNhbGxiYWNrMTUiLCJ1c2VDb250ZXh0MjciLCJ1c2VFZmZlY3QxOSIsInVzZUxheW91dEVmZmVjdDgiLCJ1c2VNZW1vMjciLCJ1c2VTdGF0ZTE3IiwianN4MzAiLCJPZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZyIsIm9uVmlkZW9GcmFtZSIsImNyb3NzT3JpZ2luIiwidm9sdW1lUHJvcHNGcmFtZSIsImltYWdlU3JjIiwic2V0SW1hZ2VTcmMiLCJyZW1vdGlvbl92aWRlb0VuYWJsZWQiLCJleGVjdXRlIiwianNvbiIsImNsZWFuZWRVcEVycm9yTWVzc2FnZSIsImNhdXNlIiwib25FcnIiLCJpbWciLCJmb3J3YXJkUmVmMTAiLCJ1c2VDb250ZXh0MjgiLCJ1c2VFZmZlY3QyMSIsInVzZUltcGVyYXRpdmVIYW5kbGU5IiwidXNlTWVtbzI4IiwidXNlUmVmMTYiLCJ1c2VTdGF0ZTE4IiwidXNlRWZmZWN0MjAiLCJ1c2VFbWl0VmlkZW9GcmFtZSIsImpzeDMxIiwiVmlkZW9Gb3JEZXZlbG9wbWVudFJlZkZvcndhcmRpbmdGdW5jdGlvbiIsInZpZGVvUmVmIiwiYWNjZXB0YWJsZVRpbWVTaGlmdCIsImVycm9ySGFuZGxlciIsImNvZGUiLCJjcm9zc09yaWdpblZhbHVlIiwicGxheXNJbmxpbmUiLCJkaXNhYmxlUmVtb3RlUGxheWJhY2siLCJWaWRlb0ZvclByZXZpZXciLCJqc3gzMiIsIk9mZnRocmVhZFZpZGVvIiwiaW1hZ2VGb3JtYXQiLCJwcm9wc0ZvclByZXZpZXciLCJmb3J3YXJkUmVmMTIiLCJ1c2VDYWxsYmFjazE3IiwidXNlQ29udGV4dDMwIiwiZm9yd2FyZFJlZjExIiwidXNlQ29udGV4dDI5IiwidXNlRWZmZWN0MjIiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlMTAiLCJ1c2VMYXlvdXRFZmZlY3Q5IiwidXNlTWVtbzI5IiwidXNlUmVmMTciLCJyb3VuZFRvNkNvbW1hcyIsInNlZWtUb1RpbWUiLCJkZXNpcmVkVGltZSIsIndhaXQiLCJjYW5jZWxTZWVrZWQiLCJtZXRhZGF0YSIsImRpc3BsYXlJbiIsImV4cGVjdGVkRGlzcGxheVRpbWUiLCJ3YWl0Rm9yU2Vla2VkRXZlbnQiLCJvbkRvbmUiLCJzZWVrVG9UaW1lTXVsdGlwbGVVbnRpbFJpZ2h0IiwiY3VycmVudENhbmNlbCIsImZpcnN0U2VlayIsInNlZWtlZFRvIiwic2lnbiIsIm5ld1NlZWsiLCJuZXdUaW1lIiwibmV3RGlmZmVyZW5jZSIsInRoaXJkU2VlayIsImpzeDMzIiwiVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24iLCJsb2FkZWREYXRhSGFuZGxlciIsImVuZGVkSGFuZGxlciIsInNlZWsyIiwiVmlkZW9Gb3JSZW5kZXJpbmciLCJqc3gzNCIsIlZpZGVvRm9yd2FyZGluZ0Z1bmN0aW9uIiwiVmlkZW8iLCJFeHBlcmltZW50YWwiLCJwcm94eU9iaiIsIkNvbmZpZyIsInByb3AiLCJleGl0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/remotion/dist/esm/no-react.mjs":
/*!*********************************************************!*\
  !*** ../../node_modules/remotion/dist/esm/no-react.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/delay-render.ts\nif (false) {}\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithCustomFields = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n        }\n        return value;\n    });\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/no-react.ts\nvar NoReactInternals = {\n    processColor,\n    truthy,\n    validateFps,\n    validateDimension,\n    validateDurationInFrames,\n    validateDefaultAndInputProps,\n    validateFrame,\n    serializeJSONWithDate,\n    bundleName: \"bundle.js\",\n    bundleMapName: \"bundle.js.map\",\n    deserializeJSONWithCustomFields,\n    DELAY_RENDER_CALLSTACK_TOKEN,\n    DELAY_RENDER_RETRY_TOKEN,\n    DELAY_RENDER_CLEAR_TOKEN,\n    DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n    getOffthreadVideoSource,\n    getExpectedMediaFrameUncorrected,\n    ENABLE_V5_BREAKING_CHANGES,\n    MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n    MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n    colorNames,\n    DATE_TOKEN,\n    FILE_TOKEN\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JlbW90aW9uL2Rpc3QvZXNtL25vLXJlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxxQkFBcUI7QUFDckIsU0FBU0Esb0JBQW9CQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxPQUFPO0lBQ2xFLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxnQkFBZ0IsRUFBRUMsTUFBTSxFQUFFLEdBQUdIO0lBQ3RELElBQUlJLFNBQVNQO0lBQ2IsTUFBTSxDQUFDUSxVQUFVQyxTQUFTLEdBQUdSO0lBQzdCLE1BQU0sQ0FBQ1MsV0FBV0MsVUFBVSxHQUFHVDtJQUMvQixJQUFJSyxTQUFTQyxVQUFVO1FBQ3JCLElBQUlKLG9CQUFvQixZQUFZO1lBQ2xDLE9BQU9HO1FBQ1Q7UUFDQSxJQUFJSCxvQkFBb0IsU0FBUztZQUMvQkcsU0FBU0M7UUFDWCxPQUFPLElBQUlKLG9CQUFvQixRQUFRO1lBQ3JDLE1BQU1RLFFBQVFILFdBQVdEO1lBQ3pCRCxTQUFTLENBQUMsQ0FBQ0EsU0FBU0MsUUFBTyxJQUFLSSxRQUFRQSxLQUFJLElBQUtBLFFBQVFKO1FBQzNELE9BQU8sSUFBSUosb0JBQW9CLFVBQVUsQ0FBQztJQUM1QztJQUNBLElBQUlHLFNBQVNFLFVBQVU7UUFDckIsSUFBSUoscUJBQXFCLFlBQVk7WUFDbkMsT0FBT0U7UUFDVDtRQUNBLElBQUlGLHFCQUFxQixTQUFTO1lBQ2hDRSxTQUFTRTtRQUNYLE9BQU8sSUFBSUoscUJBQXFCLFFBQVE7WUFDdEMsTUFBTU8sUUFBUUgsV0FBV0Q7WUFDekJELFNBQVMsQ0FBQyxDQUFDQSxTQUFTQyxRQUFPLElBQUtJLFFBQVFBLEtBQUksSUFBS0EsUUFBUUo7UUFDM0QsT0FBTyxJQUFJSCxxQkFBcUIsVUFBVSxDQUFDO0lBQzdDO0lBQ0EsSUFBSUssY0FBY0MsV0FBVztRQUMzQixPQUFPRDtJQUNUO0lBQ0FILFNBQVMsQ0FBQ0EsU0FBU0MsUUFBTyxJQUFNQyxDQUFBQSxXQUFX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S0FBYTtBQUNyRztBQUVBLHNCQUFzQjtBQUN0QixJQUFJRSxpQkFBaUIsQ0FBQ0M7SUFDcEIsSUFBSSxJQUE2QixFQUFFO1FBQ2pDLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPLElBQUlDLElBQUlELGFBQWEzUCxPQUFPNlAsTUFBTSxFQUFFQyxJQUFJO0FBQ2pEO0FBRUEsc0NBQXNDO0FBQ3RDLElBQUlDLDBCQUEwQixDQUFDLEVBQzdCQyxHQUFHLEVBQ0gzTCxXQUFXLEVBQ1g0TCxXQUFXLEVBQ1hDLFVBQVUsRUFDWDtJQUNDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRWxRLE9BQU9tUSxrQkFBa0IsQ0FBQyxXQUFXLEVBQUVDLG1CQUFtQlYsZUFBZU0sTUFBTSxNQUFNLEVBQUVJLG1CQUFtQkgsYUFBYSxhQUFhLEVBQUVJLE9BQU9oTSxhQUFhLFlBQVksRUFBRWdNLE9BQU9ILGFBQWE7QUFDek47QUFFQSxrQkFBa0I7QUFDbEIsSUFBSUksbUJBQW1CO0lBQ3JCdEM7SUFDQW5PO0lBQ0F1UDtJQUNBUDtJQUNBSztJQUNBVjtJQUNBTDtJQUNBMU47SUFDQThQLFlBQVk7SUFDWkMsZUFBZTtJQUNmMU87SUFDQTNCO0lBQ0FFO0lBQ0FDO0lBQ0FtUSw0QkFBNEJyUTtJQUM1QjJQO0lBQ0FSO0lBQ0FyQjtJQUNBd0Msa0JBQWtCeEMsNkJBQTZCLEtBQUs7SUFDcER5QyxpQkFBaUJ6Qyw2QkFBNkIsVUFBVTtJQUN4RDlKO0lBQ0E3RDtJQUNBQztBQUNGO0FBS0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrdXNob2duZS9Eb2N1bWVudHMvQVBQUy9iYXphYXItdmlkL2JhemFhci12aWQvbm9kZV9tb2R1bGVzL3JlbW90aW9uL2Rpc3QvZXNtL25vLXJlYWN0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBlYXNpbmcgfSA9IG9wdGlvbnM7XG4gIGxldCByZXN1bHQgPSBpbnB1dDtcbiAgY29uc3QgW2lucHV0TWluLCBpbnB1dE1heF0gPSBpbnB1dFJhbmdlO1xuICBjb25zdCBbb3V0cHV0TWluLCBvdXRwdXRNYXhdID0gb3V0cHV0UmFuZ2U7XG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImV4dGVuZFwiKSB7fVxuICB9XG4gIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWF4O1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHtcbiAgICByZXR1cm4gb3V0cHV0TWluO1xuICB9XG4gIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTtpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGFycikge1xuICBmb3IgKGxldCBpID0gMTtpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCEoYXJyW2ldID4gYXJyW2kgLSAxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRSYW5nZSBtdXN0IGJlIHN0cmljdGx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0luZmluaXRlUmFuZ2UobmFtZSwgYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHNcIik7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IG51bWJlcnNgKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBmaW5pdGUgbnVtYmVycywgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgKFwiICsgaW5wdXRSYW5nZS5sZW5ndGggKyBcIikgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcImlucHV0UmFuZ2VcIiwgaW5wdXRSYW5nZSk7XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcIm91dHB1dFJhbmdlXCIsIG91dHB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG4gIGNvbnN0IGVhc2luZyA9IG9wdGlvbnM/LmVhc2luZyA/PyAoKG51bSkgPT4gbnVtKTtcbiAgbGV0IGV4dHJhcG9sYXRlTGVmdCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlTGVmdCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVMZWZ0O1xuICB9XG4gIGxldCBleHRyYXBvbGF0ZVJpZ2h0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBvcHRpb25zLmV4dHJhcG9sYXRlUmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW50ZXJwb2xhdGUgYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKTtcbiAgcmV0dXJuIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIFtpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdXSwgW291dHB1dFJhbmdlW3JhbmdlXSwgb3V0cHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIHtcbiAgICBlYXNpbmcsXG4gICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgIGV4dHJhcG9sYXRlUmlnaHRcbiAgfSk7XG59XG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcbi8vIHNyYy90cnV0aHkudHNcbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59XG5cbi8vIHNyYy9kZWxheS1yZW5kZXIudHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMgPSB7fTtcbn1cbnZhciBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOID0gXCJUaGUgZGVsYXlSZW5kZXIgd2FzIGNhbGxlZDpcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUID0gXCJSZXRyaWVzIGxlZnQ6IFwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiA9IFwiLSBSZW5kZXJpbmcgdGhlIGZyYW1lIHdpbGwgYmUgcmV0cmllZC5cIjtcbnZhciBERUxBWV9SRU5ERVJfQ0xFQVJfVE9LRU4gPSBcImhhbmRsZSB3YXMgY2xlYXJlZCBhZnRlclwiO1xuXG4vLyBzcmMvaW5wdXQtcHJvcHMtc2VyaWFsaXphdGlvbi50c1xudmFyIERBVEVfVE9LRU4gPSBcInJlbW90aW9uLWRhdGU6XCI7XG52YXIgRklMRV9UT0tFTiA9IFwicmVtb3Rpb24tZmlsZTpcIjtcbnZhciBzZXJpYWxpemVKU09OV2l0aERhdGUgPSAoe1xuICBkYXRhLFxuICBpbmRlbnQsXG4gIHN0YXRpY0Jhc2Vcbn0pID0+IHtcbiAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gIGxldCBjdXN0b21GaWxlVXNlZCA9IGZhbHNlO1xuICBsZXQgbWFwVXNlZCA9IGZhbHNlO1xuICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0RBVEVfVE9LRU59JHtpdGVtLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIHN0YXRpY0Jhc2UgIT09IG51bGwgJiYgaXRlbS5zdGFydHNXaXRoKHN0YXRpY0Jhc2UpKSB7XG4gICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0ZJTEVfVE9LRU59JHtpdGVtLnJlcGxhY2Uoc3RhdGljQmFzZSArIFwiL1wiLCBcIlwiKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGluZGVudCk7XG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFN0cmluZywgY3VzdG9tRGF0ZVVzZWQsIGN1c3RvbUZpbGVVc2VkLCBtYXBVc2VkLCBzZXRVc2VkIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhc3NlZCBpbnB1dCBwcm9wcyB0byBKU09OOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgfVxufTtcbnZhciBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzID0gKGRhdGEpID0+IHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChGSUxFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3ZhbHVlLnJlcGxhY2UoRklMRV9UT0tFTiwgXCJcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn07XG5cbi8vIHNyYy9pbnRlcnBvbGF0ZS1jb2xvcnMudHNcbnZhciBOVU1CRVIgPSBcIlstK10/XFxcXGQqXFxcXC4/XFxcXGQrXCI7XG52YXIgUEVSQ0VOVEFHRSA9IE5VTUJFUiArIFwiJVwiO1xuZnVuY3Rpb24gY2FsbCguLi5hcmdzKSB7XG4gIHJldHVybiBcIlxcXFwoXFxcXHMqKFwiICsgYXJncy5qb2luKFwiKVxcXFxzKixcXFxccyooXCIpICsgXCIpXFxcXHMqXFxcXClcIjtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXJzKCkge1xuICBjb25zdCBjYWNoZWRNYXRjaGVycyA9IHtcbiAgICByZ2I6IHVuZGVmaW5lZCxcbiAgICByZ2JhOiB1bmRlZmluZWQsXG4gICAgaHNsOiB1bmRlZmluZWQsXG4gICAgaHNsYTogdW5kZWZpbmVkLFxuICAgIGhleDM6IHVuZGVmaW5lZCxcbiAgICBoZXg0OiB1bmRlZmluZWQsXG4gICAgaGV4NTogdW5kZWZpbmVkLFxuICAgIGhleDY6IHVuZGVmaW5lZCxcbiAgICBoZXg4OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGNhY2hlZE1hdGNoZXJzLnJnYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiID0gbmV3IFJlZ0V4cChcInJnYlwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiYSA9IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbCA9IG5ldyBSZWdFeHAoXCJoc2xcIiArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaHNsYSA9IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4MyA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDQgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4NiA9IC9eIyhbMC05YS1mQS1GXXs2fSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg4ID0gL14jKFswLTlhLWZBLUZdezh9KSQvO1xuICB9XG4gIHJldHVybiBjYWNoZWRNYXRjaGVycztcbn1cbmZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHtcbiAgICB0ICs9IDE7XG4gIH1cbiAgaWYgKHQgPiAxKSB7XG4gICAgdCAtPSAxO1xuICB9XG4gIGlmICh0IDwgMSAvIDYpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgfVxuICBpZiAodCA8IDEgLyAyKSB7XG4gICAgcmV0dXJuIHE7XG4gIH1cbiAgaWYgKHQgPCAyIC8gMykge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gIGNvbnN0IGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICBjb25zdCBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChyICogMjU1KSA8PCAyNCB8IE1hdGgucm91bmQoZyAqIDI1NSkgPDwgMTYgfCBNYXRoLnJvdW5kKGIgKiAyNTUpIDw8IDg7XG59XG5mdW5jdGlvbiBwYXJzZTI1NShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAyNTUpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBpbnQ7XG59XG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIChpbnQgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChudW0gPiAxKSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuZnVuY3Rpb24gcGFyc2VQZXJjZW50YWdlKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAxMDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gaW50IC8gMTAwO1xufVxudmFyIGNvbG9yTmFtZXMgPSB7XG4gIHRyYW5zcGFyZW50OiAwLFxuICBhbGljZWJsdWU6IDQwNDI4NTAzMDMsXG4gIGFudGlxdWV3aGl0ZTogNDIwOTc2MDI1NSxcbiAgYXF1YTogMTY3NzcyMTUsXG4gIGFxdWFtYXJpbmU6IDIxNDc0NzI2MzksXG4gIGF6dXJlOiA0MDQzMzA5MDU1LFxuICBiZWlnZTogNDEyNjUzMDgxNSxcbiAgYmlzcXVlOiA0MjkzMTgyNzE5LFxuICBibGFjazogMjU1LFxuICBibGFuY2hlZGFsbW9uZDogNDI5MzY0Mzc3NSxcbiAgYmx1ZTogNjU1MzUsXG4gIGJsdWV2aW9sZXQ6IDIzMTgxMzE5NjcsXG4gIGJyb3duOiAyNzcxMDA0MTU5LFxuICBidXJseXdvb2Q6IDM3MzY2MzUzOTEsXG4gIGJ1cm50c2llbm5hOiAzOTM0MTUwMTQzLFxuICBjYWRldGJsdWU6IDE2MDQyMzE0MjMsXG4gIGNoYXJ0cmV1c2U6IDIxNDc0MTgzNjcsXG4gIGNob2NvbGF0ZTogMzUzMDEwNDU3NSxcbiAgY29yYWw6IDQyODY1MzM4ODcsXG4gIGNvcm5mbG93ZXJibHVlOiAxNjg3NTQ3MzkxLFxuICBjb3Juc2lsazogNDI5NDQ5OTU4MyxcbiAgY3JpbXNvbjogMzY5MjMxMzg1NSxcbiAgY3lhbjogMTY3NzcyMTUsXG4gIGRhcmtibHVlOiAzNTgzOSxcbiAgZGFya2N5YW46IDkxNDUzNDMsXG4gIGRhcmtnb2xkZW5yb2Q6IDMwOTU3OTI2MzksXG4gIGRhcmtncmF5OiAyODQ2NDY4NjA3LFxuICBkYXJrZ3JlZW46IDY1NTM4NTUsXG4gIGRhcmtncmV5OiAyODQ2NDY4NjA3LFxuICBkYXJra2hha2k6IDMxODI5MTQ1NTksXG4gIGRhcmttYWdlbnRhOiAyMzMyMDY4ODYzLFxuICBkYXJrb2xpdmVncmVlbjogMTQzMzA4Nzk5OSxcbiAgZGFya29yYW5nZTogNDI4NzM2NTM3NSxcbiAgZGFya29yY2hpZDogMjU3MDI0MzMyNyxcbiAgZGFya3JlZDogMjMzMjAzMzI3OSxcbiAgZGFya3NhbG1vbjogMzkxODk1MzIxNSxcbiAgZGFya3NlYWdyZWVuOiAyNDExNDk5NTE5LFxuICBkYXJrc2xhdGVibHVlOiAxMjExOTkzMDg3LFxuICBkYXJrc2xhdGVncmF5OiA3OTM3MjY5NzUsXG4gIGRhcmtzbGF0ZWdyZXk6IDc5MzcyNjk3NSxcbiAgZGFya3R1cnF1b2lzZTogMTM1NTQxNzUsXG4gIGRhcmt2aW9sZXQ6IDI0ODMwODIyMzksXG4gIGRlZXBwaW5rOiA0Mjc5NTM4Njg3LFxuICBkZWVwc2t5Ymx1ZTogMTI1ODI5MTEsXG4gIGRpbWdyYXk6IDE3Njg1MTYwOTUsXG4gIGRpbWdyZXk6IDE3Njg1MTYwOTUsXG4gIGRvZGdlcmJsdWU6IDUxMjgxOTE5OSxcbiAgZmlyZWJyaWNrOiAyOTg4NTgxNjMxLFxuICBmbG9yYWx3aGl0ZTogNDI5NDYzNTc3NSxcbiAgZm9yZXN0Z3JlZW46IDU3OTU0MzgwNyxcbiAgZnVjaHNpYTogNDI3ODI1NTYxNSxcbiAgZ2FpbnNib3JvOiAzNzA1NDYyMDE1LFxuICBnaG9zdHdoaXRlOiA0MTc3MDY4MDMxLFxuICBnb2xkOiA0MjkyMjgwNTc1LFxuICBnb2xkZW5yb2Q6IDM2NjgyNTQ5NzUsXG4gIGdyYXk6IDIxNTU5MDUyNzksXG4gIGdyZWVuOiA4Mzg4ODYzLFxuICBncmVlbnllbGxvdzogMjkxOTE4MjMzNSxcbiAgZ3JleTogMjE1NTkwNTI3OSxcbiAgaG9uZXlkZXc6IDQwNDMzMDUyMTUsXG4gIGhvdHBpbms6IDQyODUxMTc2OTUsXG4gIGluZGlhbnJlZDogMzQ0NTM4MjM5OSxcbiAgaW5kaWdvOiAxMjU4MzI0NzM1LFxuICBpdm9yeTogNDI5NDk2MzQ1NSxcbiAga2hha2k6IDQwNDE2NDEyMTUsXG4gIGxhdmVuZGVyOiAzODczODk3MjE1LFxuICBsYXZlbmRlcmJsdXNoOiA0MjkzOTgxNjk1LFxuICBsYXduZ3JlZW46IDIwOTY4OTAxMTEsXG4gIGxlbW9uY2hpZmZvbjogNDI5NDYyNjgxNSxcbiAgbGlnaHRibHVlOiAyOTE2NjczMjc5LFxuICBsaWdodGNvcmFsOiA0MDM0OTUzNDcxLFxuICBsaWdodGN5YW46IDM3NzQ4NzM1OTksXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiA0MjEwNzQyMDE1LFxuICBsaWdodGdyYXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0Z3JlZW46IDI0MzE1NTM3OTEsXG4gIGxpZ2h0Z3JleTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRwaW5rOiA0MjkwMTY3Mjk1LFxuICBsaWdodHNhbG1vbjogNDI4ODcwNzMyNyxcbiAgbGlnaHRzZWFncmVlbjogNTQ4NTgwMDk1LFxuICBsaWdodHNreWJsdWU6IDIyNzg0ODg4MzEsXG4gIGxpZ2h0c2xhdGVncmF5OiAyMDA1NDQxMDIzLFxuICBsaWdodHNsYXRlZ3JleTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzdGVlbGJsdWU6IDI5NjU2OTIxNTksXG4gIGxpZ2h0eWVsbG93OiA0Mjk0OTU5MzU5LFxuICBsaW1lOiAxNjcxMTkzNSxcbiAgbGltZWdyZWVuOiA4NTIzMDg3MzUsXG4gIGxpbmVuOiA0MjEwMDkxNzc1LFxuICBtYWdlbnRhOiA0Mjc4MjU1NjE1LFxuICBtYXJvb246IDIxNDc0ODM5MDMsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDE3MjQ3NTQ2ODcsXG4gIG1lZGl1bWJsdWU6IDUyNzM1LFxuICBtZWRpdW1vcmNoaWQ6IDMxMjYxODcwMDcsXG4gIG1lZGl1bXB1cnBsZTogMjQ3MzY0NzEwMyxcbiAgbWVkaXVtc2VhZ3JlZW46IDEwMTgzOTMwODcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMjA3MDQ3NDQ5NSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDE2NDIzNjc5LFxuICBtZWRpdW10dXJxdW9pc2U6IDEyMjE3MDkwNTUsXG4gIG1lZGl1bXZpb2xldHJlZDogMzM0MDA3NjU0MyxcbiAgbWlkbmlnaHRibHVlOiA0MjEwOTc3MjcsXG4gIG1pbnRjcmVhbTogNDEyNzE5Mzg1NSxcbiAgbWlzdHlyb3NlOiA0MjkzMTkwMTQzLFxuICBtb2NjYXNpbjogNDI5MzE3ODg3OSxcbiAgbmF2YWpvd2hpdGU6IDQyOTI3ODM2MTUsXG4gIG5hdnk6IDMzMDIzLFxuICBvbGRsYWNlOiA0MjYwNzUxMTAzLFxuICBvbGl2ZTogMjE1NTg3MjUxMSxcbiAgb2xpdmVkcmFiOiAxODA0NDc3NDM5LFxuICBvcmFuZ2U6IDQyODkwMDM3NzUsXG4gIG9yYW5nZXJlZDogNDI4MjcxMjMxOSxcbiAgb3JjaGlkOiAzNjY0ODI4MTU5LFxuICBwYWxlZ29sZGVucm9kOiA0MDA4MjI1NTM1LFxuICBwYWxlZ3JlZW46IDI1NjY2MjU1MzUsXG4gIHBhbGV0dXJxdW9pc2U6IDI5NTE2NzE1NTEsXG4gIHBhbGV2aW9sZXRyZWQ6IDM2ODE1ODgyMjMsXG4gIHBhcGF5YXdoaXA6IDQyOTM5MDc5NjcsXG4gIHBlYWNocHVmZjogNDI5MjUyNDU0MyxcbiAgcGVydTogMzQ0ODA2MTk1MSxcbiAgcGluazogNDI5MDgyNTIxNSxcbiAgcGx1bTogMzcxODMwNzMyNyxcbiAgcG93ZGVyYmx1ZTogMjk2NzUyOTIxNSxcbiAgcHVycGxlOiAyMTQ3NTE2NjcxLFxuICByZWJlY2NhcHVycGxlOiAxNzE0NjU3NzkxLFxuICByZWQ6IDQyNzgxOTAzMzUsXG4gIHJvc3licm93bjogMzE2MzUyNTExOSxcbiAgcm95YWxibHVlOiAxMDk3NDU4MTc1LFxuICBzYWRkbGVicm93bjogMjMzNjU2MDEyNyxcbiAgc2FsbW9uOiA0MjAyNzIyMDQ3LFxuICBzYW5keWJyb3duOiA0MTA0NDEzNDM5LFxuICBzZWFncmVlbjogNzgwODgzOTY3LFxuICBzZWFzaGVsbDogNDI5NDMwNzU4MyxcbiAgc2llbm5hOiAyNjg5NzQwMjg3LFxuICBzaWx2ZXI6IDMyMzM4NTc3OTEsXG4gIHNreWJsdWU6IDIyNzg0ODQ5OTEsXG4gIHNsYXRlYmx1ZTogMTc4NDMzNTg3MSxcbiAgc2xhdGVncmF5OiAxODg3NDczOTE5LFxuICBzbGF0ZWdyZXk6IDE4ODc0NzM5MTksXG4gIHNub3c6IDQyOTQ2MzgzMzUsXG4gIHNwcmluZ2dyZWVuOiAxNjc0NDQ0NyxcbiAgc3RlZWxibHVlOiAxMTgyOTcxMTM1LFxuICB0YW46IDM1MzUwNDc5MzUsXG4gIHRlYWw6IDg0MjE2MzEsXG4gIHRoaXN0bGU6IDM2MzY0NTE1ODMsXG4gIHRvbWF0bzogNDI4NDY5NjU3NSxcbiAgdHVycXVvaXNlOiAxMDg4NDc1MzkxLFxuICB2aW9sZXQ6IDQwMDE1NTgyNzEsXG4gIHdoZWF0OiA0MTI1MDEyOTkxLFxuICB3aGl0ZTogNDI5NDk2NzI5NSxcbiAgd2hpdGVzbW9rZTogNDEyNjUzNzIxNSxcbiAgeWVsbG93OiA0Mjk0OTAyMDE1LFxuICB5ZWxsb3dncmVlbjogMjU5NzEzOTE5OVxufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG5cbi8vIHNyYy92NS1mbGFnLnRzXG52YXIgRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPSBmYWxzZTtcblxuLy8gc3JjL3ZhbGlkYXRlLWZyYW1lLnRzXG52YXIgdmFsaWRhdGVGcmFtZSA9ICh7XG4gIGFsbG93RmxvYXRzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBmcmFtZVxufSkgPT4ge1xuICBpZiAodHlwZW9mIGZyYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgbWlzc2luZyBmb3IgcGFyYW1ldGVyIFwiZnJhbWVcImApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJhbWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBwYXNzZWQgZm9yIFwiZnJhbWVcIiBpcyBub3QgYSBudW1iZXI6ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEZyYW1lICR7ZnJhbWV9IGlzIG5vdCBmaW5pdGVgKTtcbiAgfVxuICBpZiAoZnJhbWUgJSAxICE9PSAwICYmICFhbGxvd0Zsb2F0cykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBBcmd1bWVudCBmb3IgZnJhbWUgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKGZyYW1lIDwgMCAmJiBmcmFtZSA8IC1kdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgbG93ZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7LWR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGZyYW1lID4gZHVyYXRpb25JbkZyYW1lcyAtIDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBoaWdoZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7ZHVyYXRpb25JbkZyYW1lcyAtIDF9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtcHJvcHMudHNcbnZhciB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzID0gKGRlZmF1bHRQcm9wcywgbmFtZSwgY29tcG9zaXRpb25JZCkgPT4ge1xuICBpZiAoIWRlZmF1bHRQcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRQcm9wcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0UHJvcHN9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGFuIGFycmF5IHdhcyBwYXNzZWQgJHtjb21wb3NpdGlvbklkID8gYGZvciBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImAgOiBcIlwifWApO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kaW1lbnNpb25zLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYW1vdW50fWApO1xuICB9XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kdXJhdGlvbi1pbi1mcmFtZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWxsb3dGbG9hdHMsIGNvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uSW5GcmFtZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZnBzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICBpZiAodHlwZW9mIGZwcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBub3QgYmUgTmFOLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChmcHMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNHaWYgJiYgZnBzID4gNTApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICB9XG59XG5cbi8vIHNyYy92aWRlby9nZXQtY3VycmVudC10aW1lLnRzXG52YXIgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQgPSAoe1xuICBmcmFtZSxcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgcmV0dXJuIGludGVycG9sYXRlKGZyYW1lLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgMV0sIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyBwbGF5YmFja1JhdGVdKTtcbn07XG5cbi8vIHNyYy9hYnNvbHV0ZS1zcmMudHNcbnZhciBnZXRBYnNvbHV0ZVNyYyA9IChyZWxhdGl2ZVNyYykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiByZWxhdGl2ZVNyYztcbiAgfVxuICByZXR1cm4gbmV3IFVSTChyZWxhdGl2ZVNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy92aWRlby9vZmZ0aHJlYWQtdmlkZW8tc291cmNlLnRzXG52YXIgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UgPSAoe1xuICBzcmMsXG4gIHRyYW5zcGFyZW50LFxuICBjdXJyZW50VGltZSxcbiAgdG9uZU1hcHBlZFxufSkgPT4ge1xuICByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6JHt3aW5kb3cucmVtb3Rpb25fcHJveHlQb3J0fS9wcm94eT9zcmM9JHtlbmNvZGVVUklDb21wb25lbnQoZ2V0QWJzb2x1dGVTcmMoc3JjKSl9JnRpbWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3VycmVudFRpbWUpfSZ0cmFuc3BhcmVudD0ke1N0cmluZyh0cmFuc3BhcmVudCl9JnRvbmVNYXBwZWQ9JHtTdHJpbmcodG9uZU1hcHBlZCl9YDtcbn07XG5cbi8vIHNyYy9uby1yZWFjdC50c1xudmFyIE5vUmVhY3RJbnRlcm5hbHMgPSB7XG4gIHByb2Nlc3NDb2xvcixcbiAgdHJ1dGh5LFxuICB2YWxpZGF0ZUZwcyxcbiAgdmFsaWRhdGVEaW1lbnNpb24sXG4gIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyxcbiAgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyxcbiAgdmFsaWRhdGVGcmFtZSxcbiAgc2VyaWFsaXplSlNPTldpdGhEYXRlLFxuICBidW5kbGVOYW1lOiBcImJ1bmRsZS5qc1wiLFxuICBidW5kbGVNYXBOYW1lOiBcImJ1bmRsZS5qcy5tYXBcIixcbiAgZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyxcbiAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfQ0xFQVJfVE9LRU4sXG4gIERFTEFZX1JFTkRFUl9BVFRFTVBUX1RPS0VOOiBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZULFxuICBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSxcbiAgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQsXG4gIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTLFxuICBNSU5fTk9ERV9WRVJTSU9OOiBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA/IDE4IDogMTYsXG4gIE1JTl9CVU5fVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyBcIjEuMS4zXCIgOiBcIjEuMC4zXCIsXG4gIGNvbG9yTmFtZXMsXG4gIERBVEVfVE9LRU4sXG4gIEZJTEVfVE9LRU5cbn07XG5leHBvcnQge1xuICByYW5kb20sXG4gIGludGVycG9sYXRlLFxuICBOb1JlYWN0SW50ZXJuYWxzXG59O1xuIl0sIm5hbWVzIjpbImludGVycG9sYXRlRnVuY3Rpb24iLCJpbnB1dCIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsIm9wdGlvbnMiLCJleHRyYXBvbGF0ZUxlZnQiLCJleHRyYXBvbGF0ZVJpZ2h0IiwiZWFzaW5nIiwicmVzdWx0IiwiaW5wdXRNaW4iLCJpbnB1dE1heCIsIm91dHB1dE1pbiIsIm91dHB1dE1heCIsInJhbmdlIiwiZmluZFJhbmdlIiwiaSIsImxlbmd0aCIsImNoZWNrVmFsaWRJbnB1dFJhbmdlIiwiYXJyIiwiRXJyb3IiLCJqb2luIiwiY2hlY2tJbmZpbml0ZVJhbmdlIiwibmFtZSIsImVsZW1lbnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImludGVycG9sYXRlIiwibnVtIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwibXVsYmVycnkzMiIsImEiLCJ0IiwiTWF0aCIsImltdWwiLCJoYXNoQ29kZSIsInN0ciIsImNociIsImhhc2giLCJjaGFyQ29kZUF0IiwicmFuZG9tIiwic2VlZCIsImR1bW15IiwidHJ1dGh5IiwidmFsdWUiLCJCb29sZWFuIiwid2luZG93IiwicmVtb3Rpb25fcmVuZGVyUmVhZHkiLCJyZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzIiwiREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTiIsIkRFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQiLCJERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4iLCJERUxBWV9SRU5ERVJfQ0xFQVJfVE9LRU4iLCJEQVRFX1RPS0VOIiwiRklMRV9UT0tFTiIsInNlcmlhbGl6ZUpTT05XaXRoRGF0ZSIsImRhdGEiLCJpbmRlbnQiLCJzdGF0aWNCYXNlIiwiY3VzdG9tRGF0ZVVzZWQiLCJjdXN0b21GaWxlVXNlZCIsIm1hcFVzZWQiLCJzZXRVc2VkIiwic2VyaWFsaXplZFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJpdGVtIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiTWFwIiwiU2V0Iiwic3RhcnRzV2l0aCIsInJlcGxhY2UiLCJlcnIiLCJtZXNzYWdlIiwiZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyIsInBhcnNlIiwiXyIsInJlbW90aW9uX3N0YXRpY0Jhc2UiLCJOVU1CRVIiLCJQRVJDRU5UQUdFIiwiY2FsbCIsImFyZ3MiLCJnZXRNYXRjaGVycyIsImNhY2hlZE1hdGNoZXJzIiwicmdiIiwicmdiYSIsImhzbCIsImhzbGEiLCJoZXgzIiwiaGV4NCIsImhleDUiLCJoZXg2IiwiaGV4OCIsIlJlZ0V4cCIsImh1ZTJyZ2IiLCJwIiwicSIsImhzbFRvUmdiIiwiaCIsInMiLCJsIiwiciIsImciLCJiIiwicm91bmQiLCJwYXJzZTI1NSIsImludCIsInBhcnNlSW50IiwicGFyc2UzNjAiLCJwYXJzZUZsb2F0IiwicGFyc2UxIiwicGFyc2VQZXJjZW50YWdlIiwiY29sb3JOYW1lcyIsInRyYW5zcGFyZW50IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJidXJudHNpZW5uYSIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIm5vcm1hbGl6ZUNvbG9yIiwiY29sb3IiLCJtYXRjaGVycyIsIm1hdGNoIiwiZXhlYyIsInByb2Nlc3NDb2xvciIsIm5vcm1hbGl6ZWRDb2xvciIsIkVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTIiwidmFsaWRhdGVGcmFtZSIsImFsbG93RmxvYXRzIiwiZHVyYXRpb25JbkZyYW1lcyIsImZyYW1lIiwiUmFuZ2VFcnJvciIsInZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJjb21wb3NpdGlvbklkIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRhdGVEaW1lbnNpb24iLCJhbW91bnQiLCJuYW1lT2ZQcm9wIiwibG9jYXRpb24iLCJpc05hTiIsInZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyIsImNvbXBvbmVudCIsInZhbGlkYXRlRnBzIiwiZnBzIiwiaXNHaWYiLCJnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCIsInBsYXliYWNrUmF0ZSIsInN0YXJ0RnJvbSIsImdldEFic29sdXRlU3JjIiwicmVsYXRpdmVTcmMiLCJVUkwiLCJvcmlnaW4iLCJocmVmIiwiZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UiLCJzcmMiLCJjdXJyZW50VGltZSIsInRvbmVNYXBwZWQiLCJyZW1vdGlvbl9wcm94eVBvcnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJTdHJpbmciLCJOb1JlYWN0SW50ZXJuYWxzIiwiYnVuZGxlTmFtZSIsImJ1bmRsZU1hcE5hbWUiLCJERUxBWV9SRU5ERVJfQVRURU1QVF9UT0tFTiIsIk1JTl9OT0RFX1ZFUlNJT04iLCJNSU5fQlVOX1ZFUlNJT04iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;