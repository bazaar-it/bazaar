"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_src_lib_evals_runner_ts";
exports.ids = ["_rsc_src_lib_evals_runner_ts"];
exports.modules = {

/***/ "(rsc)/./src/lib/evals/runner.ts":
/*!*********************************!*\
  !*** ./src/lib/evals/runner.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EvaluationRunner: () => (/* binding */ EvaluationRunner),\n/* harmony export */   evaluationRunner: () => (/* binding */ evaluationRunner),\n/* harmony export */   runEvaluation: () => (/* binding */ runEvaluation)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _config_models_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config/models.config */ \"(rsc)/./src/config/models.config.ts\");\n/* harmony import */ var _server_services_ai_aiClient_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ~/server/services/ai/aiClient.service */ \"(rsc)/./src/server/services/ai/aiClient.service.ts\");\n/* harmony import */ var _bazaar_database__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @bazaar/database */ \"(rsc)/../../packages/database/index.ts\");\n/* harmony import */ var drizzle_orm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! drizzle-orm */ \"drizzle-orm\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_bazaar_database__WEBPACK_IMPORTED_MODULE_3__, drizzle_orm__WEBPACK_IMPORTED_MODULE_4__]);\n([_bazaar_database__WEBPACK_IMPORTED_MODULE_3__, drizzle_orm__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n//src/lib/evals/runner.ts\n\n\n\n\n\n\nclass EvaluationRunner {\n    constructor(){\n        this.currentModelPack = 'claude-pack';\n        this.aiClient = new _server_services_ai_aiClient_service__WEBPACK_IMPORTED_MODULE_2__.AIClientService();\n    }\n    async runSuite(config) {\n        console.log(`ðŸš€ Running evaluation suite: ${config.suiteId}`);\n        const modelPacks = config.modelPacks || [\n            'claude-pack'\n        ];\n        console.log(`ðŸŽ¯ Using model pack${modelPacks.length > 1 ? 's' : ''}: ${modelPacks.join(', ')}`);\n        const suite = await this.loadSuite(config.suiteId);\n        const prompts = config.maxPrompts ? suite.prompts.slice(0, config.maxPrompts) : suite.prompts;\n        const allResults = [];\n        const comparisonResults = [];\n        console.log(`\\nðŸ§ª Running suite \"${suite.name}\" with model pack${modelPacks.length > 1 ? 's' : ''}: ${modelPacks.join(', ')}`);\n        // Run tests\n        for (const prompt of prompts){\n            const promptResults = {};\n            for (const modelPackId of modelPacks){\n                try {\n                    const result = await this.runSinglePrompt(prompt, modelPackId, config.verbose);\n                    promptResults[modelPackId] = result;\n                    allResults.push(result);\n                    // Show output if requested\n                    if (config.showOutputs) {\n                        this.displayPromptOutput(result, modelPackId);\n                    }\n                } catch (error) {\n                    console.log(`    âŒ ERROR: ${error}`);\n                    const errorResult = {\n                        promptId: prompt.id,\n                        prompt,\n                        modelPack: modelPackId,\n                        modelKey: 'error',\n                        provider: 'error',\n                        model: 'error',\n                        output: '',\n                        actualOutput: '',\n                        success: false,\n                        error: error instanceof Error ? error.message : String(error),\n                        metrics: {\n                            latency: 0,\n                            cost: 0,\n                            timestamp: new Date().toISOString()\n                        }\n                    };\n                    promptResults[modelPackId] = errorResult;\n                    allResults.push(errorResult);\n                }\n            }\n            // Generate comparison if multiple model packs\n            if (modelPacks.length > 1) {\n                const comparison = this.generateComparison(prompt, promptResults);\n                comparisonResults.push(comparison);\n            }\n        }\n        // Generate summary\n        const summary = this.generateSummary(allResults, modelPacks);\n        if (config.comparison && comparisonResults.length > 0) {\n            this.displayComparison(comparisonResults);\n        }\n        return {\n            results: allResults,\n            comparison: comparisonResults.length > 0 ? comparisonResults : undefined,\n            summary\n        };\n    }\n    async runSinglePrompt(prompt, modelPackId, verbose = false) {\n        console.log(`  âš¡ Testing ${prompt.type === 'image' ? 'ðŸ–¼ï¸' : 'ðŸ§ '} brain with prompt: ${prompt.name}`);\n        const startTime = Date.now();\n        const modelPack = _config_models_config__WEBPACK_IMPORTED_MODULE_1__.MODEL_PACKS[modelPackId];\n        if (!modelPack) {\n            throw new Error(`Model pack ${modelPackId} not found`);\n        }\n        // Set the active model pack for this test\n        process.env.ACTIVE_MODEL_PACK = modelPackId;\n        try {\n            let response;\n            let toolsUsed = [];\n            let codeOutput = '';\n            let imageAnalysis = '';\n            // Prepare context based on prompt type\n            const context = this.prepareContext(prompt);\n            // ðŸš¨ FIXED: Generate proper UUIDs for evaluation instead of invalid strings\n            const projectId = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID();\n            const userId = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID();\n            // ðŸš¨ CRITICAL FIX: Create user first, then project to satisfy foreign key constraints\n            try {\n                // Step 1: Create user record first\n                await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.insert(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.users).values({\n                    id: userId,\n                    name: `Eval User`,\n                    email: `eval-${userId}@test.local`,\n                    emailVerified: null,\n                    image: null,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }).onConflictDoNothing();\n                console.log(`[EvaluationRunner] Created user: ${userId}`);\n                // Step 2: Create project record  \n                await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.insert(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.projects).values({\n                    id: projectId,\n                    title: `Eval Project - ${prompt.name}`,\n                    props: {\n                        meta: {\n                            title: `Eval Project - ${prompt.name}`,\n                            duration: 300,\n                            backgroundColor: \"#1a1a1a\"\n                        },\n                        scenes: []\n                    },\n                    userId: userId,\n                    isWelcome: false,\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                }).onConflictDoNothing();\n                console.log(`[EvaluationRunner] Created project: ${projectId}`);\n            } catch (dbError) {\n                console.error(`[EvaluationRunner] Failed to create evaluation records:`, dbError);\n            // Continue anyway - the brain orchestrator might handle missing projects gracefully\n            }\n            // ðŸš¨ CRITICAL FIX: Create any existing scenes in the database\n            if (context.storyboardSoFar && context.storyboardSoFar.length > 0) {\n                try {\n                    for (const scene of context.storyboardSoFar){\n                        await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.insert(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.scenes).values({\n                            id: scene.id,\n                            projectId: projectId,\n                            name: scene.name,\n                            tsxCode: scene.tsxCode,\n                            order: scene.order || 0,\n                            duration: scene.duration || 180,\n                            props: null,\n                            createdAt: new Date(),\n                            updatedAt: new Date()\n                        }).onConflictDoNothing();\n                    }\n                    console.log(`[EvaluationRunner] Created ${context.storyboardSoFar.length} scenes for project: ${projectId}`);\n                } catch (dbError) {\n                    console.error(`[EvaluationRunner] Failed to create scenes:`, dbError);\n                // Continue anyway\n                }\n            }\n            if (prompt.type === 'image' && prompt.input.image) {\n                // âœ… FIXED: Handle image prompts with proper URL format\n                const imageUrl = prompt.input.image;\n                console.log(`    ðŸ–¼ï¸  Processing image: ${imageUrl.substring(0, 50)}...`);\n                // TODO: Update to use new orchestratorNEW and generation.ts\n                throw new Error(\"Eval runner needs to be updated to use new architecture\");\n            /*\n        response = await brainOrchestrator.processUserInput({\n          prompt: prompt.input.text || '',\n          projectId,\n          userId,\n          userContext: {\n            ...context,\n            imageUrls: [imageUrl] // Pass image as URL in userContext\n          },\n          storyboardSoFar: context.storyboardSoFar || [],\n          chatHistory: context.chatHistory || []\n        });\n\n        if (response.result?.imageAnalysis) {\n          imageAnalysis = response.result.imageAnalysis;\n        }\n        */ } else {\n                // Text-based prompts\n                // TODO: Update to use new orchestratorNEW and generation.ts\n                throw new Error(\"Eval runner needs to be updated to use new architecture\");\n            /*\n        response = await brainOrchestrator.processUserInput({\n          prompt: prompt.input.text || '',\n          projectId,\n          userId,\n          userContext: context,\n          storyboardSoFar: context.storyboardSoFar || [],\n          chatHistory: context.chatHistory || []\n        });\n        */ }\n            if (response.toolUsed) {\n                toolsUsed = [\n                    response.toolUsed\n                ];\n            }\n            if (response.result?.sceneCode) {\n                codeOutput = response.result.sceneCode;\n            }\n            const latency = Date.now() - startTime;\n            const model = modelPack.models.brain;\n            console.log(`    â±ï¸  ${latency}ms | ${model.provider}/${model.model}`);\n            if (verbose && response.reasoning) {\n                console.log(`    ðŸ¤” Reasoning: ${response.reasoning.substring(0, 100)}...`);\n            }\n            const cost = this.estimateCost(response.chatResponse || '', model.provider, model.model);\n            // ðŸš¨ CLEANUP: Remove the test records after evaluation (in proper order)\n            try {\n                await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.delete(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.scenes).where((0,drizzle_orm__WEBPACK_IMPORTED_MODULE_4__.eq)(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.scenes.projectId, projectId));\n                await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.delete(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.projects).where((0,drizzle_orm__WEBPACK_IMPORTED_MODULE_4__.eq)(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.projects.id, projectId));\n                await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.delete(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.users).where((0,drizzle_orm__WEBPACK_IMPORTED_MODULE_4__.eq)(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.users.id, userId));\n                console.log(`[EvaluationRunner] Cleaned up project: ${projectId} and user: ${userId}`);\n            } catch (cleanupError) {\n                console.warn(`[EvaluationRunner] Failed to cleanup records:`, cleanupError);\n            // Non-critical error, continue\n            }\n            return {\n                promptId: prompt.id,\n                prompt,\n                modelPack: modelPackId,\n                modelKey: 'brain',\n                provider: model.provider,\n                model: model.model,\n                output: response.chatResponse || '',\n                actualOutput: response.chatResponse || '',\n                codeOutput,\n                imageAnalysis,\n                toolsUsed,\n                reasoning: response.reasoning,\n                success: response.success,\n                error: response.error,\n                metrics: {\n                    latency,\n                    cost,\n                    timestamp: new Date().toISOString()\n                }\n            };\n        } catch (error) {\n            throw new Error(`${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    prepareContext(prompt) {\n        const context = {};\n        if (prompt.input.context) {\n            Object.assign(context, prompt.input.context);\n        }\n        // ðŸš¨ FIXED: Add scene context that matches production (with proper UUIDs)\n        if (context.existingCode) {\n            const sceneId = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID(); // Generate proper UUID\n            context.storyboardSoFar = [\n                {\n                    id: sceneId,\n                    name: context.sceneName || 'Test Scene',\n                    tsxCode: context.existingCode,\n                    duration: context.duration || 180,\n                    order: 1\n                }\n            ];\n            // Set the current scene ID for editing\n            context.sceneId = sceneId;\n        }\n        // ðŸš¨ ENHANCED: Add chat history that matches production format\n        if (!context.chatHistory && prompt.expectedBehavior?.editType) {\n            context.chatHistory = [\n                {\n                    role: 'assistant',\n                    content: 'ðŸ‘‹ **Welcome to Bazaar-Vid!** I can help you create amazing motion graphics videos. What would you like to create today?'\n                },\n                {\n                    role: 'user',\n                    content: prompt.input.text || 'Previous interaction context'\n                }\n            ];\n        }\n        // ðŸš¨ ENHANCED: Add complexity classification for editScene operations\n        if (prompt.expectedBehavior?.editType) {\n            context.editComplexity = prompt.expectedBehavior.editType; // surgical, creative, structural\n        }\n        // ðŸš¨ ENHANCED: Add expected behavior for validation\n        if (prompt.expectedBehavior) {\n            context.expectedBehavior = prompt.expectedBehavior;\n        }\n        return context;\n    }\n    displayPromptOutput(result, modelPack) {\n        console.log(`\\nðŸ“‹ ${result.prompt.name} (${modelPack})`);\n        console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n        if (result.success) {\n            console.log(`âœ… Success: ${result.metrics.latency}ms, $${result.metrics.cost?.toFixed(4)}`);\n            if (result.toolsUsed && result.toolsUsed.length > 0) {\n                console.log(`ðŸ› ï¸  Tools: ${result.toolsUsed.join(', ')}`);\n            }\n            if (result.imageAnalysis) {\n                console.log(`ðŸ–¼ï¸  Image Analysis: ${result.imageAnalysis.substring(0, 200)}...`);\n            }\n            if (result.codeOutput) {\n                console.log(`ðŸ’» Generated Code:`);\n                console.log(result.codeOutput.substring(0, 500) + (result.codeOutput.length > 500 ? '...' : ''));\n            }\n            if (result.reasoning) {\n                console.log(`ðŸ¤” Reasoning: ${result.reasoning.substring(0, 300)}...`);\n            }\n        } else {\n            console.log(`âŒ Failed: ${result.error}`);\n        }\n        console.log('');\n    }\n    generateComparison(prompt, results) {\n        const analysis = {\n            speedRanking: Object.entries(results).filter(([, r])=>r.success).sort(([, a], [, b])=>a.metrics.latency - b.metrics.latency).map(([pack])=>pack),\n            costEfficiency: Object.entries(results).filter(([, r])=>r.success && r.metrics.cost).sort(([, a], [, b])=>(a.metrics.cost || 0) - (b.metrics.cost || 0)).map(([pack])=>pack),\n            codeQuality: Object.entries(results).filter(([, r])=>r.success && r.codeOutput).map(([pack])=>pack),\n            overallRanking: []\n        };\n        // Simple overall ranking based on success, speed, and cost\n        analysis.overallRanking = Object.entries(results).map(([pack, result])=>({\n                pack,\n                score: result.success ? 100 - result.metrics.latency / 100 + (result.metrics.cost ? 50 - result.metrics.cost * 1000 : 0) : 0\n            })).sort((a, b)=>b.score - a.score).map((item)=>item.pack);\n        const winner = analysis.overallRanking[0] ? {\n            modelPack: analysis.overallRanking[0],\n            reason: 'Best overall performance',\n            scores: {\n                speed: analysis.speedRanking.indexOf(analysis.overallRanking[0]) + 1,\n                cost: analysis.costEfficiency.indexOf(analysis.overallRanking[0]) + 1,\n                quality: 1,\n                accuracy: results[analysis.overallRanking[0]]?.success ? 1 : 0\n            }\n        } : undefined;\n        return {\n            promptId: prompt.id,\n            promptName: prompt.name,\n            results,\n            winner,\n            analysis\n        };\n    }\n    displayComparison(comparisons) {\n        console.log(`\\nðŸ† MODEL COMPARISON RESULTS`);\n        console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n        for (const comp of comparisons){\n            console.log(`\\nðŸ“Š ${comp.promptName}`);\n            if (comp.winner) {\n                console.log(`   ðŸ¥‡ Winner: ${comp.winner.modelPack} (${comp.winner.reason})`);\n            }\n            console.log(`   âš¡ Speed ranking: ${comp.analysis.speedRanking.join(' > ')}`);\n            console.log(`   ðŸ’° Cost efficiency: ${comp.analysis.costEfficiency.join(' > ')}`);\n            console.log(`   ðŸŽ¯ Overall: ${comp.analysis.overallRanking.join(' > ')}`);\n        }\n    }\n    generateSummary(results, modelPacks) {\n        const totalTests = results.length;\n        const successfulTests = results.filter((r)=>r.success);\n        const averageLatency = successfulTests.reduce((sum, r)=>sum + r.metrics.latency, 0) / successfulTests.length;\n        const totalCost = results.reduce((sum, r)=>sum + (r.metrics.cost || 0), 0);\n        const errorRate = (totalTests - successfulTests.length) / totalTests * 100;\n        let modelPackPerformance;\n        if (modelPacks.length > 1) {\n            modelPackPerformance = {};\n            for (const pack of modelPacks){\n                const packResults = results.filter((r)=>r.modelPack === pack);\n                const packSuccesses = packResults.filter((r)=>r.success);\n                modelPackPerformance[pack] = {\n                    speed: packSuccesses.reduce((sum, r)=>sum + r.metrics.latency, 0) / packSuccesses.length,\n                    cost: packResults.reduce((sum, r)=>sum + (r.metrics.cost || 0), 0),\n                    errors: packResults.filter((r)=>!r.success).length,\n                    successRate: packSuccesses.length / packResults.length * 100\n                };\n            }\n        }\n        return {\n            totalTests,\n            averageLatency: Math.round(averageLatency),\n            totalCost,\n            errorRate: Math.round(errorRate),\n            modelPackPerformance\n        };\n    }\n    async loadSuite(suiteId) {\n        try {\n            const { getSuite } = await __webpack_require__.e(/*! import() */ \"_rsc_src_lib_evals_registry_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./registry */ \"(rsc)/./src/lib/evals/registry.ts\"));\n            const suite = getSuite(suiteId);\n            if (!suite) {\n                throw new Error(`Suite ${suiteId} not found`);\n            }\n            return suite;\n        } catch (error) {\n            throw new Error(`Failed to load suite ${suiteId}: ${error}`);\n        }\n    }\n    estimateCost(text, provider, model) {\n        const inputTokens = Math.ceil(text.length / 4);\n        const outputTokens = Math.ceil(text.length / 4);\n        if (provider === 'anthropic') {\n            if (model.includes('claude-3-5-sonnet')) {\n                return (inputTokens * 0.003 + outputTokens * 0.015) / 1000;\n            }\n            if (model.includes('claude-3-haiku')) {\n                return (inputTokens * 0.00025 + outputTokens * 0.00125) / 1000;\n            }\n        }\n        if (provider === 'openai') {\n            if (model.includes('gpt-4o-mini')) {\n                return (inputTokens * 0.00015 + outputTokens * 0.0006) / 1000;\n            }\n            if (model.includes('gpt-4')) {\n                return (inputTokens * 0.03 + outputTokens * 0.06) / 1000;\n            }\n        }\n        return 0.001; // Default fallback\n    }\n}\nconst evaluationRunner = new EvaluationRunner();\n/**\n * Improved JSON parsing that handles markdown-wrapped responses\n */ function parseJSONResponse(content) {\n    // Clean up the content - remove markdown code blocks if present\n    let cleanContent = content.trim();\n    // Remove markdown code block syntax if present\n    if (cleanContent.startsWith('```json')) {\n        cleanContent = cleanContent.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\n    } else if (cleanContent.startsWith('```')) {\n        cleanContent = cleanContent.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\n    }\n    // Remove any leading/trailing whitespace or newlines\n    cleanContent = cleanContent.trim();\n    try {\n        return JSON.parse(cleanContent);\n    } catch (error) {\n        console.error('[EvaluationRunner] JSON Parse Error:', {\n            originalContent: content.substring(0, 200),\n            cleanedContent: cleanContent.substring(0, 200),\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n        // Try to extract JSON from the content if it's mixed with other text\n        const jsonMatch = cleanContent.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n            try {\n                return JSON.parse(jsonMatch[0]);\n            } catch (secondError) {\n                console.error('[EvaluationRunner] Second JSON Parse attempt failed:', secondError);\n            }\n        }\n        throw new Error(`Failed to parse JSON response: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Create a project in the database for evaluation\n */ async function createEvaluationProject(projectData) {\n    try {\n        console.log(`[EvaluationRunner] Creating project: ${projectData.id}`);\n        await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.insert(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.projects).values({\n            id: projectData.id,\n            title: projectData.name,\n            props: {\n                meta: {\n                    title: projectData.name,\n                    duration: 300,\n                    backgroundColor: \"#1a1a1a\"\n                },\n                scenes: []\n            },\n            userId: projectData.userId,\n            isWelcome: false,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        }).onConflictDoNothing(); // Don't fail if project already exists\n        console.log(`[EvaluationRunner] Project created successfully: ${projectData.id}`);\n    } catch (error) {\n        console.error(`[EvaluationRunner] Failed to create project:`, error);\n        throw error;\n    }\n}\n/**\n * Create scenes in the database for evaluation context\n */ async function createEvaluationScenes(scenesData) {\n    try {\n        for (const sceneData of scenesData){\n            console.log(`[EvaluationRunner] Creating scene: ${sceneData.id}`);\n            await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.insert(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.scenes).values({\n                id: sceneData.id,\n                projectId: sceneData.projectId,\n                name: sceneData.name,\n                tsxCode: sceneData.code,\n                order: sceneData.order,\n                duration: sceneData.durationFrames,\n                props: null,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            }).onConflictDoNothing(); // Don't fail if scene already exists\n            console.log(`[EvaluationRunner] Scene created successfully: ${sceneData.id}`);\n        }\n    } catch (error) {\n        console.error(`[EvaluationRunner] Failed to create scenes:`, error);\n        throw error;\n    }\n}\n/**\n * Enhanced context preparation that creates DB records\n */ async function prepareEvaluationContext(scenario) {\n    // Generate proper UUIDs\n    const projectId = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID();\n    const sceneId = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID();\n    console.log(`[EvaluationRunner] Preparing context with projectId: ${projectId}, sceneId: ${sceneId}`);\n    // Create project data\n    const projectData = {\n        id: projectId,\n        name: `Evaluation Project - ${Date.now()}`,\n        description: 'Auto-generated project for evaluation testing',\n        userId: 'eval-user-' + crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID()\n    };\n    // Create initial scene data if needed\n    const storyboard = scenario.includeScenes ? [\n        {\n            id: sceneId,\n            projectId: projectId,\n            name: 'Welcome Scene',\n            type: 'TextScene',\n            code: `const { AbsoluteFill, useCurrentFrame, useVideoConfig, interpolate } = window.Remotion;\n\nexport default function WelcomeScene() {\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  \n  const opacity = interpolate(frame, [0, fps * 0.5], [0, 1], {\n    extrapolateLeft: \"clamp\",\n    extrapolateRight: \"clamp\"\n  });\n  \n  return (\n    <AbsoluteFill style={{ backgroundColor: \"#1a1a1a\" }}>\n      <div style={{\n        position: \"absolute\",\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translate(-50%, -50%)\",\n        textAlign: \"center\",\n        opacity\n      }}>\n        <h1 style={{\n          fontSize: \"4rem\",\n          fontWeight: \"700\",\n          color: \"#ffffff\",\n          margin: \"0\"\n        }}>\n          Welcome\n        </h1>\n      </div>\n    </AbsoluteFill>\n  );\n}`,\n            isTemplate: false,\n            order: 0,\n            durationFrames: 180\n        }\n    ] : [];\n    // Create database records\n    await createEvaluationProject(projectData);\n    if (storyboard.length > 0) {\n        await createEvaluationScenes(storyboard);\n    }\n    // Create chat history in production format\n    const chatHistory = scenario.chatHistory?.map((msg, index)=>({\n            role: msg.role,\n            content: msg.content,\n            timestamp: Date.now() - 1000 * (scenario.chatHistory.length - index)\n        })) || [];\n    return {\n        projectId,\n        storyboard,\n        chatHistory\n    };\n}\n/**\n * Cleanup evaluation data from database\n */ async function cleanupEvaluationData(projectId) {\n    try {\n        console.log(`[EvaluationRunner] Cleaning up evaluation data for project: ${projectId}`);\n        // Delete scenes first (due to FK constraint)\n        await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.delete(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.scenes).where((0,drizzle_orm__WEBPACK_IMPORTED_MODULE_4__.eq)(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.scenes.projectId, projectId));\n        console.log(`[EvaluationRunner] Deleted scenes for project: ${projectId}`);\n        // Delete project\n        await _bazaar_database__WEBPACK_IMPORTED_MODULE_3__.db.delete(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.projects).where((0,drizzle_orm__WEBPACK_IMPORTED_MODULE_4__.eq)(_bazaar_database__WEBPACK_IMPORTED_MODULE_3__.projects.id, projectId));\n        console.log(`[EvaluationRunner] Deleted project: ${projectId}`);\n    } catch (error) {\n        console.error(`[EvaluationRunner] Failed to cleanup evaluation data:`, error);\n    // Don't throw - cleanup failures shouldn't fail the evaluation\n    }\n}\n/**\n * Run evaluation with proper context and enhanced error handling\n */ async function runEvaluation(scenario) {\n    let context = null;\n    try {\n        console.log(`[EvaluationRunner] Starting evaluation: ${scenario.name}`);\n        // Prepare evaluation context with DB records\n        context = await prepareEvaluationContext(scenario);\n        // Create orchestrator instance\n        // TODO: Update to use new orchestratorNEW\n        // const orchestrator = new BrainOrchestrator();\n        throw new Error(\"Eval runner needs to be updated to use new architecture\");\n        // Execute the brain orchestrator\n        const response = await orchestrator.processUserInput({\n            prompt: scenario.input.userPrompt,\n            storyboardSoFar: context.storyboard,\n            chatHistory: context.chatHistory,\n            projectId: context.projectId,\n            userId: 'eval-user-' + crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID()\n        });\n        console.log(`[EvaluationRunner] Raw orchestrator response:`, response);\n        // Handle OrchestrationOutput format\n        if (!response.success) {\n            return {\n                success: false,\n                error: response.error || 'Orchestrator execution failed',\n                rawResponse: response,\n                scenario: scenario.name\n            };\n        }\n        // Return evaluation result with orchestrator output\n        return {\n            success: true,\n            response: response,\n            context: {\n                projectId: context.projectId,\n                storyboardLength: context.storyboard.length,\n                chatHistoryLength: context.chatHistory.length\n            },\n            scenario: scenario.name,\n            toolUsed: response.toolUsed,\n            reasoning: response.reasoning,\n            chatResponse: response.chatResponse\n        };\n    } catch (error) {\n        console.error(`[EvaluationRunner] Evaluation failed:`, error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Unknown error',\n            scenario: scenario.name,\n            context: context ? {\n                projectId: context.projectId,\n                storyboardLength: context.storyboard.length,\n                chatHistoryLength: context.chatHistory.length\n            } : null\n        };\n    } finally{\n        // Always cleanup evaluation data\n        if (context) {\n            await cleanupEvaluationData(context.projectId);\n        }\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsQ0FBQyxxQ0FBcUMsQ0FBQyxFQUFFQTtRQUN2RCxPQUFPO1lBQ0xVLFNBQVM7WUFDVFYsT0FBT0EsaUJBQWlCVyxRQUFRWCxNQUFNWSxPQUFPLEdBQUc7WUFDaEQ2SSxVQUFVQSxTQUFTbkssSUFBSTtZQUN2QitDLFNBQVNBLFVBQVU7Z0JBQ2pCRSxXQUFXRixRQUFRRSxTQUFTO2dCQUM1QitILGtCQUFrQmpJLFFBQVFzSCxVQUFVLENBQUM5SyxNQUFNO2dCQUMzQzBMLG1CQUFtQmxJLFFBQVEyQyxXQUFXLENBQUNuRyxNQUFNO1lBQy9DLElBQUk7UUFDTjtJQUNGLFNBQVU7UUFDUixpQ0FBaUM7UUFDakMsSUFBSXdELFNBQVM7WUFDWCxNQUFNMkgsc0JBQXNCM0gsUUFBUUUsU0FBUztRQUMvQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrdXNob2duZS9Eb2N1bWVudHMvQVBQUy9iYXphYXItdmlkL2JhemFhci12aWQvYXBwcy9tYWluL3NyYy9saWIvZXZhbHMvcnVubmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vc3JjL2xpYi9ldmFscy9ydW5uZXIudHNcblxuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHR5cGUgeyBFdmFsU3VpdGUsIEV2YWxQcm9tcHQsIEV2YWxSZXN1bHQsIFNlcnZpY2VUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRBY3RpdmVNb2RlbFBhY2ssIE1PREVMX1BBQ0tTLCBsaXN0QXZhaWxhYmxlUGFja3MgfSBmcm9tICcuLi8uLi9jb25maWcvbW9kZWxzLmNvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IE1vZGVsUGFjayB9IGZyb20gJy4uLy4uL2NvbmZpZy9tb2RlbHMuY29uZmlnJztcbmltcG9ydCB7IEFJQ2xpZW50U2VydmljZSB9IGZyb20gJ34vc2VydmVyL3NlcnZpY2VzL2FpL2FpQ2xpZW50LnNlcnZpY2UnO1xuaW1wb3J0IHsgZGIgfSBmcm9tIFwiQGJhemFhci9kYXRhYmFzZVwiO1xuaW1wb3J0IHsgc2NlbmVzLCBwcm9qZWN0cywgdXNlcnMgfSBmcm9tIFwiQGJhemFhci9kYXRhYmFzZVwiO1xuaW1wb3J0IHsgZXEgfSBmcm9tIFwiZHJpenpsZS1vcm1cIjtcbi8vIFRPRE86IFVwZGF0ZSBldmFsIHJ1bm5lciB0byB1c2UgbmV3IHRvb2wgYXJjaGl0ZWN0dXJlXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZhbFJ1bkNvbmZpZyB7XG4gIHN1aXRlSWQ6IHN0cmluZztcbiAgbW9kZWxQYWNrcz86IHN0cmluZ1tdO1xuICBzaG93T3V0cHV0cz86IGJvb2xlYW47XG4gIGNvbXBhcmlzb24/OiBib29sZWFuO1xuICB2ZXJib3NlPzogYm9vbGVhbjtcbiAgbWF4UHJvbXB0cz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXRhaWxlZEV2YWxSZXN1bHQgZXh0ZW5kcyBFdmFsUmVzdWx0IHtcbiAgcHJvbXB0OiBFdmFsUHJvbXB0O1xuICBhY3R1YWxPdXRwdXQ6IHN0cmluZztcbiAgY29kZU91dHB1dD86IHN0cmluZztcbiAgaW1hZ2VBbmFseXNpcz86IHN0cmluZztcbiAgdG9vbHNVc2VkPzogc3RyaW5nW107XG4gIHJlYXNvbmluZz86IHN0cmluZztcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxDb21wYXJpc29uUmVzdWx0IHtcbiAgcHJvbXB0SWQ6IHN0cmluZztcbiAgcHJvbXB0TmFtZTogc3RyaW5nO1xuICByZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBEZXRhaWxlZEV2YWxSZXN1bHQ+O1xuICB3aW5uZXI/OiB7XG4gICAgbW9kZWxQYWNrOiBzdHJpbmc7XG4gICAgcmVhc29uOiBzdHJpbmc7XG4gICAgc2NvcmVzOiB7XG4gICAgICBzcGVlZDogbnVtYmVyO1xuICAgICAgY29zdDogbnVtYmVyO1xuICAgICAgcXVhbGl0eTogbnVtYmVyO1xuICAgICAgYWNjdXJhY3k6IG51bWJlcjtcbiAgICB9O1xuICB9O1xuICBhbmFseXNpczoge1xuICAgIHNwZWVkUmFua2luZzogc3RyaW5nW107XG4gICAgY29zdEVmZmljaWVuY3k6IHN0cmluZ1tdO1xuICAgIGNvZGVRdWFsaXR5OiBzdHJpbmdbXTtcbiAgICBvdmVyYWxsUmFua2luZzogc3RyaW5nW107XG4gIH07XG59XG5cbmludGVyZmFjZSBQcm9qZWN0RGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2NlbmVEYXRhIHtcbiAgaWQ6IHN0cmluZztcbiAgcHJvamVjdElkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBjb2RlOiBzdHJpbmc7XG4gIGlzVGVtcGxhdGU6IGJvb2xlYW47XG4gIG9yZGVyOiBudW1iZXI7XG4gIGR1cmF0aW9uRnJhbWVzOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBDaGF0TWVzc2FnZSB7XG4gIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRXZhbHVhdGlvbkNvbnRleHQge1xuICBwcm9qZWN0SWQ6IHN0cmluZztcbiAgc3Rvcnlib2FyZDogU2NlbmVEYXRhW107XG4gIGNoYXRIaXN0b3J5OiBDaGF0TWVzc2FnZVtdO1xufVxuXG5leHBvcnQgY2xhc3MgRXZhbHVhdGlvblJ1bm5lciB7XG4gIHByaXZhdGUgYWlDbGllbnQ6IEFJQ2xpZW50U2VydmljZTtcbiAgcHJpdmF0ZSBjdXJyZW50TW9kZWxQYWNrOiBzdHJpbmcgPSAnY2xhdWRlLXBhY2snO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYWlDbGllbnQgPSBuZXcgQUlDbGllbnRTZXJ2aWNlKCk7XG4gIH1cblxuICBhc3luYyBydW5TdWl0ZShjb25maWc6IEV2YWxSdW5Db25maWcpOiBQcm9taXNlPHtcbiAgICByZXN1bHRzOiBEZXRhaWxlZEV2YWxSZXN1bHRbXTtcbiAgICBjb21wYXJpc29uPzogTW9kZWxDb21wYXJpc29uUmVzdWx0W107XG4gICAgc3VtbWFyeToge1xuICAgICAgdG90YWxUZXN0czogbnVtYmVyO1xuICAgICAgYXZlcmFnZUxhdGVuY3k6IG51bWJlcjtcbiAgICAgIHRvdGFsQ29zdDogbnVtYmVyO1xuICAgICAgZXJyb3JSYXRlOiBudW1iZXI7XG4gICAgICBtb2RlbFBhY2tQZXJmb3JtYW5jZT86IFJlY29yZDxzdHJpbmcsIHsgXG4gICAgICAgIHNwZWVkOiBudW1iZXI7IFxuICAgICAgICBjb3N0OiBudW1iZXI7IFxuICAgICAgICBlcnJvcnM6IG51bWJlcjsgXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiBudW1iZXI7XG4gICAgICB9PjtcbiAgICB9O1xuICB9PiB7XG4gICAgY29uc29sZS5sb2coYPCfmoAgUnVubmluZyBldmFsdWF0aW9uIHN1aXRlOiAke2NvbmZpZy5zdWl0ZUlkfWApO1xuICAgIFxuICAgIGNvbnN0IG1vZGVsUGFja3MgPSBjb25maWcubW9kZWxQYWNrcyB8fCBbJ2NsYXVkZS1wYWNrJ107XG4gICAgY29uc29sZS5sb2coYPCfjq8gVXNpbmcgbW9kZWwgcGFjayR7bW9kZWxQYWNrcy5sZW5ndGggPiAxID8gJ3MnIDogJyd9OiAke21vZGVsUGFja3Muam9pbignLCAnKX1gKTtcblxuICAgIGNvbnN0IHN1aXRlID0gYXdhaXQgdGhpcy5sb2FkU3VpdGUoY29uZmlnLnN1aXRlSWQpO1xuICAgIGNvbnN0IHByb21wdHMgPSBjb25maWcubWF4UHJvbXB0cyA/IHN1aXRlLnByb21wdHMuc2xpY2UoMCwgY29uZmlnLm1heFByb21wdHMpIDogc3VpdGUucHJvbXB0cztcbiAgICBcbiAgICBjb25zdCBhbGxSZXN1bHRzOiBEZXRhaWxlZEV2YWxSZXN1bHRbXSA9IFtdO1xuICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHRzOiBNb2RlbENvbXBhcmlzb25SZXN1bHRbXSA9IFtdO1xuXG4gICAgY29uc29sZS5sb2coYFxcbvCfp6ogUnVubmluZyBzdWl0ZSBcIiR7c3VpdGUubmFtZX1cIiB3aXRoIG1vZGVsIHBhY2ske21vZGVsUGFja3MubGVuZ3RoID4gMSA/ICdzJyA6ICcnfTogJHttb2RlbFBhY2tzLmpvaW4oJywgJyl9YCk7XG5cbiAgICAvLyBSdW4gdGVzdHNcbiAgICBmb3IgKGNvbnN0IHByb21wdCBvZiBwcm9tcHRzKSB7XG4gICAgICBjb25zdCBwcm9tcHRSZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBEZXRhaWxlZEV2YWxSZXN1bHQ+ID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgbW9kZWxQYWNrSWQgb2YgbW9kZWxQYWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuU2luZ2xlUHJvbXB0KHByb21wdCwgbW9kZWxQYWNrSWQsIGNvbmZpZy52ZXJib3NlKTtcbiAgICAgICAgICBwcm9tcHRSZXN1bHRzW21vZGVsUGFja0lkXSA9IHJlc3VsdDtcbiAgICAgICAgICBhbGxSZXN1bHRzLnB1c2gocmVzdWx0KTtcblxuICAgICAgICAgIC8vIFNob3cgb3V0cHV0IGlmIHJlcXVlc3RlZFxuICAgICAgICAgIGlmIChjb25maWcuc2hvd091dHB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVByb21wdE91dHB1dChyZXN1bHQsIG1vZGVsUGFja0lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgICDinYwgRVJST1I6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgY29uc3QgZXJyb3JSZXN1bHQ6IERldGFpbGVkRXZhbFJlc3VsdCA9IHtcbiAgICAgICAgICAgIHByb21wdElkOiBwcm9tcHQuaWQsXG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFBhY2s6IG1vZGVsUGFja0lkLFxuICAgICAgICAgICAgbW9kZWxLZXk6ICdlcnJvcicsXG4gICAgICAgICAgICBwcm92aWRlcjogJ2Vycm9yJyxcbiAgICAgICAgICAgIG1vZGVsOiAnZXJyb3InLFxuICAgICAgICAgICAgb3V0cHV0OiAnJyxcbiAgICAgICAgICAgIGFjdHVhbE91dHB1dDogJycsXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICBtZXRyaWNzOiB7XG4gICAgICAgICAgICAgIGxhdGVuY3k6IDAsXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcm9tcHRSZXN1bHRzW21vZGVsUGFja0lkXSA9IGVycm9yUmVzdWx0O1xuICAgICAgICAgIGFsbFJlc3VsdHMucHVzaChlcnJvclJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJhdGUgY29tcGFyaXNvbiBpZiBtdWx0aXBsZSBtb2RlbCBwYWNrc1xuICAgICAgaWYgKG1vZGVsUGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gdGhpcy5nZW5lcmF0ZUNvbXBhcmlzb24ocHJvbXB0LCBwcm9tcHRSZXN1bHRzKTtcbiAgICAgICAgY29tcGFyaXNvblJlc3VsdHMucHVzaChjb21wYXJpc29uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzdW1tYXJ5XG4gICAgY29uc3Qgc3VtbWFyeSA9IHRoaXMuZ2VuZXJhdGVTdW1tYXJ5KGFsbFJlc3VsdHMsIG1vZGVsUGFja3MpO1xuICAgIFxuICAgIGlmIChjb25maWcuY29tcGFyaXNvbiAmJiBjb21wYXJpc29uUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmRpc3BsYXlDb21wYXJpc29uKGNvbXBhcmlzb25SZXN1bHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0czogYWxsUmVzdWx0cyxcbiAgICAgIGNvbXBhcmlzb246IGNvbXBhcmlzb25SZXN1bHRzLmxlbmd0aCA+IDAgPyBjb21wYXJpc29uUmVzdWx0cyA6IHVuZGVmaW5lZCxcbiAgICAgIHN1bW1hcnlcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBydW5TaW5nbGVQcm9tcHQoXG4gICAgcHJvbXB0OiBFdmFsUHJvbXB0LCBcbiAgICBtb2RlbFBhY2tJZDogc3RyaW5nLCBcbiAgICB2ZXJib3NlOiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxEZXRhaWxlZEV2YWxSZXN1bHQ+IHtcbiAgICBjb25zb2xlLmxvZyhgICDimqEgVGVzdGluZyAke3Byb21wdC50eXBlID09PSAnaW1hZ2UnID8gJ/CflrzvuI8nIDogJ/Cfp6AnfSBicmFpbiB3aXRoIHByb21wdDogJHtwcm9tcHQubmFtZX1gKTtcbiAgICBcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG1vZGVsUGFjayA9IE1PREVMX1BBQ0tTW21vZGVsUGFja0lkXTtcbiAgICBcbiAgICBpZiAoIW1vZGVsUGFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2RlbCBwYWNrICR7bW9kZWxQYWNrSWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgYWN0aXZlIG1vZGVsIHBhY2sgZm9yIHRoaXMgdGVzdFxuICAgIHByb2Nlc3MuZW52LkFDVElWRV9NT0RFTF9QQUNLID0gbW9kZWxQYWNrSWQ7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJlc3BvbnNlOiBhbnk7XG4gICAgICBsZXQgdG9vbHNVc2VkOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgbGV0IGNvZGVPdXRwdXQgPSAnJztcbiAgICAgIGxldCBpbWFnZUFuYWx5c2lzID0gJyc7XG5cbiAgICAgIC8vIFByZXBhcmUgY29udGV4dCBiYXNlZCBvbiBwcm9tcHQgdHlwZVxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMucHJlcGFyZUNvbnRleHQocHJvbXB0KTtcblxuICAgICAgLy8g8J+aqCBGSVhFRDogR2VuZXJhdGUgcHJvcGVyIFVVSURzIGZvciBldmFsdWF0aW9uIGluc3RlYWQgb2YgaW52YWxpZCBzdHJpbmdzXG4gICAgICBjb25zdCBwcm9qZWN0SWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgICAgY29uc3QgdXNlcklkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcblxuICAgICAgLy8g8J+aqCBDUklUSUNBTCBGSVg6IENyZWF0ZSB1c2VyIGZpcnN0LCB0aGVuIHByb2plY3QgdG8gc2F0aXNmeSBmb3JlaWduIGtleSBjb25zdHJhaW50c1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU3RlcCAxOiBDcmVhdGUgdXNlciByZWNvcmQgZmlyc3RcbiAgICAgICAgYXdhaXQgZGIuaW5zZXJ0KHVzZXJzKS52YWx1ZXMoe1xuICAgICAgICAgIGlkOiB1c2VySWQsXG4gICAgICAgICAgbmFtZTogYEV2YWwgVXNlcmAsXG4gICAgICAgICAgZW1haWw6IGBldmFsLSR7dXNlcklkfUB0ZXN0LmxvY2FsYCxcbiAgICAgICAgICBlbWFpbFZlcmlmaWVkOiBudWxsLFxuICAgICAgICAgIGltYWdlOiBudWxsLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pLm9uQ29uZmxpY3REb05vdGhpbmcoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbRXZhbHVhdGlvblJ1bm5lcl0gQ3JlYXRlZCB1c2VyOiAke3VzZXJJZH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgMjogQ3JlYXRlIHByb2plY3QgcmVjb3JkICBcbiAgICAgICAgYXdhaXQgZGIuaW5zZXJ0KHByb2plY3RzKS52YWx1ZXMoe1xuICAgICAgICAgIGlkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgdGl0bGU6IGBFdmFsIFByb2plY3QgLSAke3Byb21wdC5uYW1lfWAsXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgdGl0bGU6IGBFdmFsIFByb2plY3QgLSAke3Byb21wdC5uYW1lfWAsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMWExYTFhXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2VuZXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICBpc1dlbGNvbWU6IGZhbHNlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pLm9uQ29uZmxpY3REb05vdGhpbmcoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbRXZhbHVhdGlvblJ1bm5lcl0gQ3JlYXRlZCBwcm9qZWN0OiAke3Byb2plY3RJZH1gKTtcbiAgICAgIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0V2YWx1YXRpb25SdW5uZXJdIEZhaWxlZCB0byBjcmVhdGUgZXZhbHVhdGlvbiByZWNvcmRzOmAsIGRiRXJyb3IpO1xuICAgICAgICAvLyBDb250aW51ZSBhbnl3YXkgLSB0aGUgYnJhaW4gb3JjaGVzdHJhdG9yIG1pZ2h0IGhhbmRsZSBtaXNzaW5nIHByb2plY3RzIGdyYWNlZnVsbHlcbiAgICAgIH1cblxuICAgICAgLy8g8J+aqCBDUklUSUNBTCBGSVg6IENyZWF0ZSBhbnkgZXhpc3Rpbmcgc2NlbmVzIGluIHRoZSBkYXRhYmFzZVxuICAgICAgaWYgKGNvbnRleHQuc3Rvcnlib2FyZFNvRmFyICYmIGNvbnRleHQuc3Rvcnlib2FyZFNvRmFyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIGNvbnRleHQuc3Rvcnlib2FyZFNvRmFyKSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5pbnNlcnQoc2NlbmVzKS52YWx1ZXMoe1xuICAgICAgICAgICAgICBpZDogc2NlbmUuaWQsXG4gICAgICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkLFxuICAgICAgICAgICAgICBuYW1lOiBzY2VuZS5uYW1lLFxuICAgICAgICAgICAgICB0c3hDb2RlOiBzY2VuZS50c3hDb2RlLFxuICAgICAgICAgICAgICBvcmRlcjogc2NlbmUub3JkZXIgfHwgMCxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHNjZW5lLmR1cmF0aW9uIHx8IDE4MCxcbiAgICAgICAgICAgICAgcHJvcHM6IG51bGwsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgfSkub25Db25mbGljdERvTm90aGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0V2YWx1YXRpb25SdW5uZXJdIENyZWF0ZWQgJHtjb250ZXh0LnN0b3J5Ym9hcmRTb0Zhci5sZW5ndGh9IHNjZW5lcyBmb3IgcHJvamVjdDogJHtwcm9qZWN0SWR9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGRiRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRXZhbHVhdGlvblJ1bm5lcl0gRmFpbGVkIHRvIGNyZWF0ZSBzY2VuZXM6YCwgZGJFcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgYW55d2F5XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb21wdC50eXBlID09PSAnaW1hZ2UnICYmIHByb21wdC5pbnB1dC5pbWFnZSkge1xuICAgICAgICAvLyDinIUgRklYRUQ6IEhhbmRsZSBpbWFnZSBwcm9tcHRzIHdpdGggcHJvcGVyIFVSTCBmb3JtYXRcbiAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBwcm9tcHQuaW5wdXQuaW1hZ2U7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAg8J+WvO+4jyAgUHJvY2Vzc2luZyBpbWFnZTogJHtpbWFnZVVybC5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xuICAgICAgICBcbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRvIHVzZSBuZXcgb3JjaGVzdHJhdG9yTkVXIGFuZCBnZW5lcmF0aW9uLnRzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2YWwgcnVubmVyIG5lZWRzIHRvIGJlIHVwZGF0ZWQgdG8gdXNlIG5ldyBhcmNoaXRlY3R1cmVcIik7XG4gICAgICAgIC8qXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYnJhaW5PcmNoZXN0cmF0b3IucHJvY2Vzc1VzZXJJbnB1dCh7XG4gICAgICAgICAgcHJvbXB0OiBwcm9tcHQuaW5wdXQudGV4dCB8fCAnJyxcbiAgICAgICAgICBwcm9qZWN0SWQsXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIHVzZXJDb250ZXh0OiB7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgaW1hZ2VVcmxzOiBbaW1hZ2VVcmxdIC8vIFBhc3MgaW1hZ2UgYXMgVVJMIGluIHVzZXJDb250ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9yeWJvYXJkU29GYXI6IGNvbnRleHQuc3Rvcnlib2FyZFNvRmFyIHx8IFtdLFxuICAgICAgICAgIGNoYXRIaXN0b3J5OiBjb250ZXh0LmNoYXRIaXN0b3J5IHx8IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQ/LmltYWdlQW5hbHlzaXMpIHtcbiAgICAgICAgICBpbWFnZUFuYWx5c2lzID0gcmVzcG9uc2UucmVzdWx0LmltYWdlQW5hbHlzaXM7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRleHQtYmFzZWQgcHJvbXB0c1xuICAgICAgICAvLyBUT0RPOiBVcGRhdGUgdG8gdXNlIG5ldyBvcmNoZXN0cmF0b3JORVcgYW5kIGdlbmVyYXRpb24udHNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZhbCBydW5uZXIgbmVlZHMgdG8gYmUgdXBkYXRlZCB0byB1c2UgbmV3IGFyY2hpdGVjdHVyZVwiKTtcbiAgICAgICAgLypcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBicmFpbk9yY2hlc3RyYXRvci5wcm9jZXNzVXNlcklucHV0KHtcbiAgICAgICAgICBwcm9tcHQ6IHByb21wdC5pbnB1dC50ZXh0IHx8ICcnLFxuICAgICAgICAgIHByb2plY3RJZCxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgdXNlckNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgc3Rvcnlib2FyZFNvRmFyOiBjb250ZXh0LnN0b3J5Ym9hcmRTb0ZhciB8fCBbXSxcbiAgICAgICAgICBjaGF0SGlzdG9yeTogY29udGV4dC5jaGF0SGlzdG9yeSB8fCBbXVxuICAgICAgICB9KTtcbiAgICAgICAgKi9cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlLnRvb2xVc2VkKSB7XG4gICAgICAgIHRvb2xzVXNlZCA9IFtyZXNwb25zZS50b29sVXNlZF07XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQ/LnNjZW5lQ29kZSkge1xuICAgICAgICBjb2RlT3V0cHV0ID0gcmVzcG9uc2UucmVzdWx0LnNjZW5lQ29kZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGF0ZW5jeSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBtb2RlbCA9IG1vZGVsUGFjay5tb2RlbHMuYnJhaW47XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGAgICAg4o+x77iPICAke2xhdGVuY3l9bXMgfCAke21vZGVsLnByb3ZpZGVyfS8ke21vZGVsLm1vZGVsfWApO1xuICAgICAgXG4gICAgICBpZiAodmVyYm9zZSAmJiByZXNwb25zZS5yZWFzb25pbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgICDwn6SUIFJlYXNvbmluZzogJHtyZXNwb25zZS5yZWFzb25pbmcuc3Vic3RyaW5nKDAsIDEwMCl9Li4uYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvc3QgPSB0aGlzLmVzdGltYXRlQ29zdChyZXNwb25zZS5jaGF0UmVzcG9uc2UgfHwgJycsIG1vZGVsLnByb3ZpZGVyLCBtb2RlbC5tb2RlbCk7XG5cbiAgICAgIC8vIPCfmqggQ0xFQU5VUDogUmVtb3ZlIHRoZSB0ZXN0IHJlY29yZHMgYWZ0ZXIgZXZhbHVhdGlvbiAoaW4gcHJvcGVyIG9yZGVyKVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGIuZGVsZXRlKHNjZW5lcykud2hlcmUoZXEoc2NlbmVzLnByb2plY3RJZCwgcHJvamVjdElkKSk7XG4gICAgICAgIGF3YWl0IGRiLmRlbGV0ZShwcm9qZWN0cykud2hlcmUoZXEocHJvamVjdHMuaWQsIHByb2plY3RJZCkpO1xuICAgICAgICBhd2FpdCBkYi5kZWxldGUodXNlcnMpLndoZXJlKGVxKHVzZXJzLmlkLCB1c2VySWQpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtFdmFsdWF0aW9uUnVubmVyXSBDbGVhbmVkIHVwIHByb2plY3Q6ICR7cHJvamVjdElkfSBhbmQgdXNlcjogJHt1c2VySWR9YCk7XG4gICAgICB9IGNhdGNoIChjbGVhbnVwRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbRXZhbHVhdGlvblJ1bm5lcl0gRmFpbGVkIHRvIGNsZWFudXAgcmVjb3JkczpgLCBjbGVhbnVwRXJyb3IpO1xuICAgICAgICAvLyBOb24tY3JpdGljYWwgZXJyb3IsIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb21wdElkOiBwcm9tcHQuaWQsXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbW9kZWxQYWNrOiBtb2RlbFBhY2tJZCxcbiAgICAgICAgbW9kZWxLZXk6ICdicmFpbicsXG4gICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsLFxuICAgICAgICBvdXRwdXQ6IHJlc3BvbnNlLmNoYXRSZXNwb25zZSB8fCAnJyxcbiAgICAgICAgYWN0dWFsT3V0cHV0OiByZXNwb25zZS5jaGF0UmVzcG9uc2UgfHwgJycsXG4gICAgICAgIGNvZGVPdXRwdXQsXG4gICAgICAgIGltYWdlQW5hbHlzaXMsXG4gICAgICAgIHRvb2xzVXNlZCxcbiAgICAgICAgcmVhc29uaW5nOiByZXNwb25zZS5yZWFzb25pbmcsXG4gICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlLnN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiByZXNwb25zZS5lcnJvcixcbiAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgIGxhdGVuY3ksXG4gICAgICAgICAgY29zdCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcmVwYXJlQ29udGV4dChwcm9tcHQ6IEV2YWxQcm9tcHQpOiBhbnkge1xuICAgIGNvbnN0IGNvbnRleHQ6IGFueSA9IHt9O1xuICAgIFxuICAgIGlmIChwcm9tcHQuaW5wdXQuY29udGV4dCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCBwcm9tcHQuaW5wdXQuY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8g8J+aqCBGSVhFRDogQWRkIHNjZW5lIGNvbnRleHQgdGhhdCBtYXRjaGVzIHByb2R1Y3Rpb24gKHdpdGggcHJvcGVyIFVVSURzKVxuICAgIGlmIChjb250ZXh0LmV4aXN0aW5nQ29kZSkge1xuICAgICAgY29uc3Qgc2NlbmVJZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7IC8vIEdlbmVyYXRlIHByb3BlciBVVUlEXG4gICAgICBcbiAgICAgIGNvbnRleHQuc3Rvcnlib2FyZFNvRmFyID0gW3tcbiAgICAgICAgaWQ6IHNjZW5lSWQsXG4gICAgICAgIG5hbWU6IGNvbnRleHQuc2NlbmVOYW1lIHx8ICdUZXN0IFNjZW5lJyxcbiAgICAgICAgdHN4Q29kZTogY29udGV4dC5leGlzdGluZ0NvZGUsXG4gICAgICAgIGR1cmF0aW9uOiBjb250ZXh0LmR1cmF0aW9uIHx8IDE4MCxcbiAgICAgICAgb3JkZXI6IDFcbiAgICAgIH1dO1xuICAgICAgXG4gICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgc2NlbmUgSUQgZm9yIGVkaXRpbmdcbiAgICAgIGNvbnRleHQuc2NlbmVJZCA9IHNjZW5lSWQ7XG4gICAgfVxuXG4gICAgLy8g8J+aqCBFTkhBTkNFRDogQWRkIGNoYXQgaGlzdG9yeSB0aGF0IG1hdGNoZXMgcHJvZHVjdGlvbiBmb3JtYXRcbiAgICBpZiAoIWNvbnRleHQuY2hhdEhpc3RvcnkgJiYgcHJvbXB0LmV4cGVjdGVkQmVoYXZpb3I/LmVkaXRUeXBlKSB7XG4gICAgICBjb250ZXh0LmNoYXRIaXN0b3J5ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogJ/CfkYsgKipXZWxjb21lIHRvIEJhemFhci1WaWQhKiogSSBjYW4gaGVscCB5b3UgY3JlYXRlIGFtYXppbmcgbW90aW9uIGdyYXBoaWNzIHZpZGVvcy4gV2hhdCB3b3VsZCB5b3UgbGlrZSB0byBjcmVhdGUgdG9kYXk/J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogJ3VzZXInLCBcbiAgICAgICAgICBjb250ZW50OiBwcm9tcHQuaW5wdXQudGV4dCB8fCAnUHJldmlvdXMgaW50ZXJhY3Rpb24gY29udGV4dCdcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICAvLyDwn5qoIEVOSEFOQ0VEOiBBZGQgY29tcGxleGl0eSBjbGFzc2lmaWNhdGlvbiBmb3IgZWRpdFNjZW5lIG9wZXJhdGlvbnNcbiAgICBpZiAocHJvbXB0LmV4cGVjdGVkQmVoYXZpb3I/LmVkaXRUeXBlKSB7XG4gICAgICBjb250ZXh0LmVkaXRDb21wbGV4aXR5ID0gcHJvbXB0LmV4cGVjdGVkQmVoYXZpb3IuZWRpdFR5cGU7IC8vIHN1cmdpY2FsLCBjcmVhdGl2ZSwgc3RydWN0dXJhbFxuICAgIH1cblxuICAgIC8vIPCfmqggRU5IQU5DRUQ6IEFkZCBleHBlY3RlZCBiZWhhdmlvciBmb3IgdmFsaWRhdGlvblxuICAgIGlmIChwcm9tcHQuZXhwZWN0ZWRCZWhhdmlvcikge1xuICAgICAgY29udGV4dC5leHBlY3RlZEJlaGF2aW9yID0gcHJvbXB0LmV4cGVjdGVkQmVoYXZpb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBwcml2YXRlIGRpc3BsYXlQcm9tcHRPdXRwdXQocmVzdWx0OiBEZXRhaWxlZEV2YWxSZXN1bHQsIG1vZGVsUGFjazogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc29sZS5sb2coYFxcbvCfk4sgJHtyZXN1bHQucHJvbXB0Lm5hbWV9ICgke21vZGVsUGFja30pYCk7XG4gICAgY29uc29sZS5sb2coYOKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgWApO1xuICAgIFxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzOiAke3Jlc3VsdC5tZXRyaWNzLmxhdGVuY3l9bXMsICQke3Jlc3VsdC5tZXRyaWNzLmNvc3Q/LnRvRml4ZWQoNCl9YCk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQudG9vbHNVc2VkICYmIHJlc3VsdC50b29sc1VzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+boO+4jyAgVG9vbHM6ICR7cmVzdWx0LnRvb2xzVXNlZC5qb2luKCcsICcpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LmltYWdlQW5hbHlzaXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflrzvuI8gIEltYWdlIEFuYWx5c2lzOiAke3Jlc3VsdC5pbWFnZUFuYWx5c2lzLnN1YnN0cmluZygwLCAyMDApfS4uLmApO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LmNvZGVPdXRwdXQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfkrsgR2VuZXJhdGVkIENvZGU6YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5jb2RlT3V0cHV0LnN1YnN0cmluZygwLCA1MDApICsgKHJlc3VsdC5jb2RlT3V0cHV0Lmxlbmd0aCA+IDUwMCA/ICcuLi4nIDogJycpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5yZWFzb25pbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfpJQgUmVhc29uaW5nOiAke3Jlc3VsdC5yZWFzb25pbmcuc3Vic3RyaW5nKDAsIDMwMCl9Li4uYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinYwgRmFpbGVkOiAke3Jlc3VsdC5lcnJvcn1gKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJycpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUNvbXBhcmlzb24ocHJvbXB0OiBFdmFsUHJvbXB0LCByZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBEZXRhaWxlZEV2YWxSZXN1bHQ+KTogTW9kZWxDb21wYXJpc29uUmVzdWx0IHtcbiAgICBjb25zdCBhbmFseXNpcyA9IHtcbiAgICAgIHNwZWVkUmFua2luZzogT2JqZWN0LmVudHJpZXMocmVzdWx0cylcbiAgICAgICAgLmZpbHRlcigoWywgcl0pID0+IHIuc3VjY2VzcylcbiAgICAgICAgLnNvcnQoKFssIGFdLCBbLCBiXSkgPT4gYS5tZXRyaWNzLmxhdGVuY3kgLSBiLm1ldHJpY3MubGF0ZW5jeSlcbiAgICAgICAgLm1hcCgoW3BhY2tdKSA9PiBwYWNrKSxcbiAgICAgIFxuICAgICAgY29zdEVmZmljaWVuY3k6IE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpXG4gICAgICAgIC5maWx0ZXIoKFssIHJdKSA9PiByLnN1Y2Nlc3MgJiYgci5tZXRyaWNzLmNvc3QpXG4gICAgICAgIC5zb3J0KChbLCBhXSwgWywgYl0pID0+IChhLm1ldHJpY3MuY29zdCB8fCAwKSAtIChiLm1ldHJpY3MuY29zdCB8fCAwKSlcbiAgICAgICAgLm1hcCgoW3BhY2tdKSA9PiBwYWNrKSxcbiAgICAgIFxuICAgICAgY29kZVF1YWxpdHk6IE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpXG4gICAgICAgIC5maWx0ZXIoKFssIHJdKSA9PiByLnN1Y2Nlc3MgJiYgci5jb2RlT3V0cHV0KVxuICAgICAgICAubWFwKChbcGFja10pID0+IHBhY2spLCAvLyBDb3VsZCBhZGQgcXVhbGl0eSBzY29yaW5nIGxhdGVyXG4gICAgICBcbiAgICAgIG92ZXJhbGxSYW5raW5nOiBbXSBhcyBzdHJpbmdbXVxuICAgIH07XG5cbiAgICAvLyBTaW1wbGUgb3ZlcmFsbCByYW5raW5nIGJhc2VkIG9uIHN1Y2Nlc3MsIHNwZWVkLCBhbmQgY29zdFxuICAgIGFuYWx5c2lzLm92ZXJhbGxSYW5raW5nID0gT2JqZWN0LmVudHJpZXMocmVzdWx0cylcbiAgICAgIC5tYXAoKFtwYWNrLCByZXN1bHRdKSA9PiAoe1xuICAgICAgICBwYWNrLFxuICAgICAgICBzY29yZTogcmVzdWx0LnN1Y2Nlc3MgPyBcbiAgICAgICAgICAoMTAwIC0gcmVzdWx0Lm1ldHJpY3MubGF0ZW5jeSAvIDEwMCkgKyAocmVzdWx0Lm1ldHJpY3MuY29zdCA/IDUwIC0gcmVzdWx0Lm1ldHJpY3MuY29zdCAqIDEwMDAgOiAwKSA6IDBcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgLm1hcChpdGVtID0+IGl0ZW0ucGFjayk7XG5cbiAgICBjb25zdCB3aW5uZXIgPSBhbmFseXNpcy5vdmVyYWxsUmFua2luZ1swXSA/IHtcbiAgICAgIG1vZGVsUGFjazogYW5hbHlzaXMub3ZlcmFsbFJhbmtpbmdbMF0sXG4gICAgICByZWFzb246ICdCZXN0IG92ZXJhbGwgcGVyZm9ybWFuY2UnLFxuICAgICAgc2NvcmVzOiB7XG4gICAgICAgIHNwZWVkOiBhbmFseXNpcy5zcGVlZFJhbmtpbmcuaW5kZXhPZihhbmFseXNpcy5vdmVyYWxsUmFua2luZ1swXSkgKyAxLFxuICAgICAgICBjb3N0OiBhbmFseXNpcy5jb3N0RWZmaWNpZW5jeS5pbmRleE9mKGFuYWx5c2lzLm92ZXJhbGxSYW5raW5nWzBdKSArIDEsXG4gICAgICAgIHF1YWxpdHk6IDEsIC8vIFBsYWNlaG9sZGVyXG4gICAgICAgIGFjY3VyYWN5OiByZXN1bHRzW2FuYWx5c2lzLm92ZXJhbGxSYW5raW5nWzBdXT8uc3VjY2VzcyA/IDEgOiAwXG4gICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB7XG4gICAgICBwcm9tcHRJZDogcHJvbXB0LmlkLFxuICAgICAgcHJvbXB0TmFtZTogcHJvbXB0Lm5hbWUsXG4gICAgICByZXN1bHRzLFxuICAgICAgd2lubmVyLFxuICAgICAgYW5hbHlzaXNcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBkaXNwbGF5Q29tcGFyaXNvbihjb21wYXJpc29uczogTW9kZWxDb21wYXJpc29uUmVzdWx0W10pOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZyhgXFxu8J+PhiBNT0RFTCBDT01QQVJJU09OIFJFU1VMVFNgKTtcbiAgICBjb25zb2xlLmxvZyhg4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSBYCk7XG5cbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcGFyaXNvbnMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBcXG7wn5OKICR7Y29tcC5wcm9tcHROYW1lfWApO1xuICAgICAgXG4gICAgICBpZiAoY29tcC53aW5uZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIPCfpYcgV2lubmVyOiAke2NvbXAud2lubmVyLm1vZGVsUGFja30gKCR7Y29tcC53aW5uZXIucmVhc29ufSlgKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYCAgIOKaoSBTcGVlZCByYW5raW5nOiAke2NvbXAuYW5hbHlzaXMuc3BlZWRSYW5raW5nLmpvaW4oJyA+ICcpfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIPCfkrAgQ29zdCBlZmZpY2llbmN5OiAke2NvbXAuYW5hbHlzaXMuY29zdEVmZmljaWVuY3kuam9pbignID4gJyl9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAg8J+OryBPdmVyYWxsOiAke2NvbXAuYW5hbHlzaXMub3ZlcmFsbFJhbmtpbmcuam9pbignID4gJyl9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVN1bW1hcnkocmVzdWx0czogRGV0YWlsZWRFdmFsUmVzdWx0W10sIG1vZGVsUGFja3M6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgdG90YWxUZXN0cyA9IHJlc3VsdHMubGVuZ3RoO1xuICAgIGNvbnN0IHN1Y2Nlc3NmdWxUZXN0cyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKTtcbiAgICBjb25zdCBhdmVyYWdlTGF0ZW5jeSA9IHN1Y2Nlc3NmdWxUZXN0cy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5tZXRyaWNzLmxhdGVuY3ksIDApIC8gc3VjY2Vzc2Z1bFRlc3RzLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbENvc3QgPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyAoci5tZXRyaWNzLmNvc3QgfHwgMCksIDApO1xuICAgIGNvbnN0IGVycm9yUmF0ZSA9ICgodG90YWxUZXN0cyAtIHN1Y2Nlc3NmdWxUZXN0cy5sZW5ndGgpIC8gdG90YWxUZXN0cykgKiAxMDA7XG5cbiAgICBsZXQgbW9kZWxQYWNrUGVyZm9ybWFuY2U6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKG1vZGVsUGFja3MubGVuZ3RoID4gMSkge1xuICAgICAgbW9kZWxQYWNrUGVyZm9ybWFuY2UgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgcGFjayBvZiBtb2RlbFBhY2tzKSB7XG4gICAgICAgIGNvbnN0IHBhY2tSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIociA9PiByLm1vZGVsUGFjayA9PT0gcGFjayk7XG4gICAgICAgIGNvbnN0IHBhY2tTdWNjZXNzZXMgPSBwYWNrUmVzdWx0cy5maWx0ZXIociA9PiByLnN1Y2Nlc3MpO1xuICAgICAgICBcbiAgICAgICAgbW9kZWxQYWNrUGVyZm9ybWFuY2VbcGFja10gPSB7XG4gICAgICAgICAgc3BlZWQ6IHBhY2tTdWNjZXNzZXMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIubWV0cmljcy5sYXRlbmN5LCAwKSAvIHBhY2tTdWNjZXNzZXMubGVuZ3RoLFxuICAgICAgICAgIGNvc3Q6IHBhY2tSZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyAoci5tZXRyaWNzLmNvc3QgfHwgMCksIDApLFxuICAgICAgICAgIGVycm9yczogcGFja1Jlc3VsdHMuZmlsdGVyKHIgPT4gIXIuc3VjY2VzcykubGVuZ3RoLFxuICAgICAgICAgIHN1Y2Nlc3NSYXRlOiAocGFja1N1Y2Nlc3Nlcy5sZW5ndGggLyBwYWNrUmVzdWx0cy5sZW5ndGgpICogMTAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsVGVzdHMsXG4gICAgICBhdmVyYWdlTGF0ZW5jeTogTWF0aC5yb3VuZChhdmVyYWdlTGF0ZW5jeSksXG4gICAgICB0b3RhbENvc3QsXG4gICAgICBlcnJvclJhdGU6IE1hdGgucm91bmQoZXJyb3JSYXRlKSxcbiAgICAgIG1vZGVsUGFja1BlcmZvcm1hbmNlXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFN1aXRlKHN1aXRlSWQ6IHN0cmluZyk6IFByb21pc2U8RXZhbFN1aXRlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZ2V0U3VpdGUgfSA9IGF3YWl0IGltcG9ydCgnLi9yZWdpc3RyeScpO1xuICAgICAgY29uc3Qgc3VpdGUgPSBnZXRTdWl0ZShzdWl0ZUlkKTtcbiAgICAgIGlmICghc3VpdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWl0ZSAke3N1aXRlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1aXRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN1aXRlICR7c3VpdGVJZH06ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlc3RpbWF0ZUNvc3QodGV4dDogc3RyaW5nLCBwcm92aWRlcjogc3RyaW5nLCBtb2RlbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbnB1dFRva2VucyA9IE1hdGguY2VpbCh0ZXh0Lmxlbmd0aCAvIDQpO1xuICAgIGNvbnN0IG91dHB1dFRva2VucyA9IE1hdGguY2VpbCh0ZXh0Lmxlbmd0aCAvIDQpO1xuXG4gICAgaWYgKHByb3ZpZGVyID09PSAnYW50aHJvcGljJykge1xuICAgICAgaWYgKG1vZGVsLmluY2x1ZGVzKCdjbGF1ZGUtMy01LXNvbm5ldCcpKSB7XG4gICAgICAgIHJldHVybiAoaW5wdXRUb2tlbnMgKiAwLjAwMyArIG91dHB1dFRva2VucyAqIDAuMDE1KSAvIDEwMDA7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwuaW5jbHVkZXMoJ2NsYXVkZS0zLWhhaWt1JykpIHtcbiAgICAgICAgcmV0dXJuIChpbnB1dFRva2VucyAqIDAuMDAwMjUgKyBvdXRwdXRUb2tlbnMgKiAwLjAwMTI1KSAvIDEwMDA7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChwcm92aWRlciA9PT0gJ29wZW5haScpIHtcbiAgICAgIGlmIChtb2RlbC5pbmNsdWRlcygnZ3B0LTRvLW1pbmknKSkge1xuICAgICAgICByZXR1cm4gKGlucHV0VG9rZW5zICogMC4wMDAxNSArIG91dHB1dFRva2VucyAqIDAuMDAwNikgLyAxMDAwO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLmluY2x1ZGVzKCdncHQtNCcpKSB7XG4gICAgICAgIHJldHVybiAoaW5wdXRUb2tlbnMgKiAwLjAzICsgb3V0cHV0VG9rZW5zICogMC4wNikgLyAxMDAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwLjAwMTsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBldmFsdWF0aW9uUnVubmVyID0gbmV3IEV2YWx1YXRpb25SdW5uZXIoKTtcblxuLyoqXG4gKiBJbXByb3ZlZCBKU09OIHBhcnNpbmcgdGhhdCBoYW5kbGVzIG1hcmtkb3duLXdyYXBwZWQgcmVzcG9uc2VzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTlJlc3BvbnNlKGNvbnRlbnQ6IHN0cmluZyk6IGFueSB7XG4gIC8vIENsZWFuIHVwIHRoZSBjb250ZW50IC0gcmVtb3ZlIG1hcmtkb3duIGNvZGUgYmxvY2tzIGlmIHByZXNlbnRcbiAgbGV0IGNsZWFuQ29udGVudCA9IGNvbnRlbnQudHJpbSgpO1xuICBcbiAgLy8gUmVtb3ZlIG1hcmtkb3duIGNvZGUgYmxvY2sgc3ludGF4IGlmIHByZXNlbnRcbiAgaWYgKGNsZWFuQ29udGVudC5zdGFydHNXaXRoKCdgYGBqc29uJykpIHtcbiAgICBjbGVhbkNvbnRlbnQgPSBjbGVhbkNvbnRlbnQucmVwbGFjZSgvXmBgYGpzb25cXHMqLywgJycpLnJlcGxhY2UoL1xccypgYGAkLywgJycpO1xuICB9IGVsc2UgaWYgKGNsZWFuQ29udGVudC5zdGFydHNXaXRoKCdgYGAnKSkge1xuICAgIGNsZWFuQ29udGVudCA9IGNsZWFuQ29udGVudC5yZXBsYWNlKC9eYGBgXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqYGBgJC8sICcnKTtcbiAgfVxuICBcbiAgLy8gUmVtb3ZlIGFueSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2Ugb3IgbmV3bGluZXNcbiAgY2xlYW5Db250ZW50ID0gY2xlYW5Db250ZW50LnRyaW0oKTtcbiAgXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY2xlYW5Db250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbRXZhbHVhdGlvblJ1bm5lcl0gSlNPTiBQYXJzZSBFcnJvcjonLCB7XG4gICAgICBvcmlnaW5hbENvbnRlbnQ6IGNvbnRlbnQuc3Vic3RyaW5nKDAsIDIwMCksXG4gICAgICBjbGVhbmVkQ29udGVudDogY2xlYW5Db250ZW50LnN1YnN0cmluZygwLCAyMDApLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgSlNPTiBmcm9tIHRoZSBjb250ZW50IGlmIGl0J3MgbWl4ZWQgd2l0aCBvdGhlciB0ZXh0XG4gICAgY29uc3QganNvbk1hdGNoID0gY2xlYW5Db250ZW50Lm1hdGNoKC9cXHtbXFxzXFxTXSpcXH0vKTtcbiAgICBpZiAoanNvbk1hdGNoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgfSBjYXRjaCAoc2Vjb25kRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0V2YWx1YXRpb25SdW5uZXJdIFNlY29uZCBKU09OIFBhcnNlIGF0dGVtcHQgZmFpbGVkOicsIHNlY29uZEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHByb2plY3QgaW4gdGhlIGRhdGFiYXNlIGZvciBldmFsdWF0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUV2YWx1YXRpb25Qcm9qZWN0KHByb2plY3REYXRhOiBQcm9qZWN0RGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBbRXZhbHVhdGlvblJ1bm5lcl0gQ3JlYXRpbmcgcHJvamVjdDogJHtwcm9qZWN0RGF0YS5pZH1gKTtcbiAgICBcbiAgICBhd2FpdCBkYi5pbnNlcnQocHJvamVjdHMpLnZhbHVlcyh7XG4gICAgICBpZDogcHJvamVjdERhdGEuaWQsXG4gICAgICB0aXRsZTogcHJvamVjdERhdGEubmFtZSwgLy8gU2NoZW1hIHVzZXMgJ3RpdGxlJyBub3QgJ25hbWUnXG4gICAgICBwcm9wczogeyAvLyBSZXF1aXJlZCBmaWVsZCAtIGJhc2ljIHByb3BzIHN0cnVjdHVyZVxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgdGl0bGU6IHByb2plY3REYXRhLm5hbWUsXG4gICAgICAgICAgZHVyYXRpb246IDMwMCwgLy8gMTAgc2Vjb25kcyBkZWZhdWx0XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMxYTFhMWFcIlxuICAgICAgICB9LFxuICAgICAgICBzY2VuZXM6IFtdXG4gICAgICB9LFxuICAgICAgdXNlcklkOiBwcm9qZWN0RGF0YS51c2VySWQsXG4gICAgICBpc1dlbGNvbWU6IGZhbHNlLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH0pLm9uQ29uZmxpY3REb05vdGhpbmcoKTsgLy8gRG9uJ3QgZmFpbCBpZiBwcm9qZWN0IGFscmVhZHkgZXhpc3RzXG4gICAgXG4gICAgY29uc29sZS5sb2coYFtFdmFsdWF0aW9uUnVubmVyXSBQcm9qZWN0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OiAke3Byb2plY3REYXRhLmlkfWApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtFdmFsdWF0aW9uUnVubmVyXSBGYWlsZWQgdG8gY3JlYXRlIHByb2plY3Q6YCwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHNjZW5lcyBpbiB0aGUgZGF0YWJhc2UgZm9yIGV2YWx1YXRpb24gY29udGV4dFxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVFdmFsdWF0aW9uU2NlbmVzKHNjZW5lc0RhdGE6IFNjZW5lRGF0YVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgZm9yIChjb25zdCBzY2VuZURhdGEgb2Ygc2NlbmVzRGF0YSkge1xuICAgICAgY29uc29sZS5sb2coYFtFdmFsdWF0aW9uUnVubmVyXSBDcmVhdGluZyBzY2VuZTogJHtzY2VuZURhdGEuaWR9YCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGRiLmluc2VydChzY2VuZXMpLnZhbHVlcyh7XG4gICAgICAgIGlkOiBzY2VuZURhdGEuaWQsXG4gICAgICAgIHByb2plY3RJZDogc2NlbmVEYXRhLnByb2plY3RJZCxcbiAgICAgICAgbmFtZTogc2NlbmVEYXRhLm5hbWUsXG4gICAgICAgIHRzeENvZGU6IHNjZW5lRGF0YS5jb2RlLCAvLyBTY2hlbWEgdXNlcyAndHN4Q29kZScgbm90ICdjb2RlJ1xuICAgICAgICBvcmRlcjogc2NlbmVEYXRhLm9yZGVyLFxuICAgICAgICBkdXJhdGlvbjogc2NlbmVEYXRhLmR1cmF0aW9uRnJhbWVzLCAvLyBTY2hlbWEgdXNlcyAnZHVyYXRpb24nIG5vdCAnZHVyYXRpb25GcmFtZXMnXG4gICAgICAgIHByb3BzOiBudWxsLCAvLyBPcHRpb25hbCBmaWVsZFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIH0pLm9uQ29uZmxpY3REb05vdGhpbmcoKTsgLy8gRG9uJ3QgZmFpbCBpZiBzY2VuZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW0V2YWx1YXRpb25SdW5uZXJdIFNjZW5lIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OiAke3NjZW5lRGF0YS5pZH1gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW0V2YWx1YXRpb25SdW5uZXJdIEZhaWxlZCB0byBjcmVhdGUgc2NlbmVzOmAsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VkIGNvbnRleHQgcHJlcGFyYXRpb24gdGhhdCBjcmVhdGVzIERCIHJlY29yZHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUV2YWx1YXRpb25Db250ZXh0KHNjZW5hcmlvOiBhbnkpOiBQcm9taXNlPEV2YWx1YXRpb25Db250ZXh0PiB7XG4gIC8vIEdlbmVyYXRlIHByb3BlciBVVUlEc1xuICBjb25zdCBwcm9qZWN0SWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICBjb25zdCBzY2VuZUlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBbRXZhbHVhdGlvblJ1bm5lcl0gUHJlcGFyaW5nIGNvbnRleHQgd2l0aCBwcm9qZWN0SWQ6ICR7cHJvamVjdElkfSwgc2NlbmVJZDogJHtzY2VuZUlkfWApO1xuICBcbiAgLy8gQ3JlYXRlIHByb2plY3QgZGF0YVxuICBjb25zdCBwcm9qZWN0RGF0YTogUHJvamVjdERhdGEgPSB7XG4gICAgaWQ6IHByb2plY3RJZCxcbiAgICBuYW1lOiBgRXZhbHVhdGlvbiBQcm9qZWN0IC0gJHtEYXRlLm5vdygpfWAsXG4gICAgZGVzY3JpcHRpb246ICdBdXRvLWdlbmVyYXRlZCBwcm9qZWN0IGZvciBldmFsdWF0aW9uIHRlc3RpbmcnLFxuICAgIHVzZXJJZDogJ2V2YWwtdXNlci0nICsgY3J5cHRvLnJhbmRvbVVVSUQoKVxuICB9O1xuICBcbiAgLy8gQ3JlYXRlIGluaXRpYWwgc2NlbmUgZGF0YSBpZiBuZWVkZWRcbiAgY29uc3Qgc3Rvcnlib2FyZDogU2NlbmVEYXRhW10gPSBzY2VuYXJpby5pbmNsdWRlU2NlbmVzID8gW1xuICAgIHtcbiAgICAgIGlkOiBzY2VuZUlkLFxuICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICBuYW1lOiAnV2VsY29tZSBTY2VuZScsXG4gICAgICB0eXBlOiAnVGV4dFNjZW5lJyxcbiAgICAgIGNvZGU6IGBjb25zdCB7IEFic29sdXRlRmlsbCwgdXNlQ3VycmVudEZyYW1lLCB1c2VWaWRlb0NvbmZpZywgaW50ZXJwb2xhdGUgfSA9IHdpbmRvdy5SZW1vdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2VsY29tZVNjZW5lKCkge1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgXG4gIGNvbnN0IG9wYWNpdHkgPSBpbnRlcnBvbGF0ZShmcmFtZSwgWzAsIGZwcyAqIDAuNV0sIFswLCAxXSwge1xuICAgIGV4dHJhcG9sYXRlTGVmdDogXCJjbGFtcFwiLFxuICAgIGV4dHJhcG9sYXRlUmlnaHQ6IFwiY2xhbXBcIlxuICB9KTtcbiAgXG4gIHJldHVybiAoXG4gICAgPEFic29sdXRlRmlsbCBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzFhMWExYVwiIH19PlxuICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB0b3A6IFwiNTAlXCIsXG4gICAgICAgIGxlZnQ6IFwiNTAlXCIsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSlcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBvcGFjaXR5XG4gICAgICB9fT5cbiAgICAgICAgPGgxIHN0eWxlPXt7XG4gICAgICAgICAgZm9udFNpemU6IFwiNHJlbVwiLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNzAwXCIsXG4gICAgICAgICAgY29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICAgIG1hcmdpbjogXCIwXCJcbiAgICAgICAgfX0+XG4gICAgICAgICAgV2VsY29tZVxuICAgICAgICA8L2gxPlxuICAgICAgPC9kaXY+XG4gICAgPC9BYnNvbHV0ZUZpbGw+XG4gICk7XG59YCxcbiAgICAgIGlzVGVtcGxhdGU6IGZhbHNlLFxuICAgICAgb3JkZXI6IDAsXG4gICAgICBkdXJhdGlvbkZyYW1lczogMTgwXG4gICAgfVxuICBdIDogW107XG4gIFxuICAvLyBDcmVhdGUgZGF0YWJhc2UgcmVjb3Jkc1xuICBhd2FpdCBjcmVhdGVFdmFsdWF0aW9uUHJvamVjdChwcm9qZWN0RGF0YSk7XG4gIGlmIChzdG9yeWJvYXJkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FpdCBjcmVhdGVFdmFsdWF0aW9uU2NlbmVzKHN0b3J5Ym9hcmQpO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgY2hhdCBoaXN0b3J5IGluIHByb2R1Y3Rpb24gZm9ybWF0XG4gIGNvbnN0IGNoYXRIaXN0b3J5OiBDaGF0TWVzc2FnZVtdID0gc2NlbmFyaW8uY2hhdEhpc3Rvcnk/Lm1hcCgobXNnOiBhbnksIGluZGV4OiBudW1iZXIpID0+ICh7XG4gICAgcm9sZTogbXNnLnJvbGUsXG4gICAgY29udGVudDogbXNnLmNvbnRlbnQsXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpIC0gKDEwMDAgKiAoc2NlbmFyaW8uY2hhdEhpc3RvcnkubGVuZ3RoIC0gaW5kZXgpKVxuICB9KSkgfHwgW107XG4gIFxuICByZXR1cm4ge1xuICAgIHByb2plY3RJZCxcbiAgICBzdG9yeWJvYXJkLFxuICAgIGNoYXRIaXN0b3J5XG4gIH07XG59XG5cbi8qKlxuICogQ2xlYW51cCBldmFsdWF0aW9uIGRhdGEgZnJvbSBkYXRhYmFzZVxuICovXG5hc3luYyBmdW5jdGlvbiBjbGVhbnVwRXZhbHVhdGlvbkRhdGEocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgW0V2YWx1YXRpb25SdW5uZXJdIENsZWFuaW5nIHVwIGV2YWx1YXRpb24gZGF0YSBmb3IgcHJvamVjdDogJHtwcm9qZWN0SWR9YCk7XG4gICAgXG4gICAgLy8gRGVsZXRlIHNjZW5lcyBmaXJzdCAoZHVlIHRvIEZLIGNvbnN0cmFpbnQpXG4gICAgYXdhaXQgZGIuZGVsZXRlKHNjZW5lcykud2hlcmUoZXEoc2NlbmVzLnByb2plY3RJZCwgcHJvamVjdElkKSk7XG4gICAgY29uc29sZS5sb2coYFtFdmFsdWF0aW9uUnVubmVyXSBEZWxldGVkIHNjZW5lcyBmb3IgcHJvamVjdDogJHtwcm9qZWN0SWR9YCk7XG4gICAgXG4gICAgLy8gRGVsZXRlIHByb2plY3RcbiAgICBhd2FpdCBkYi5kZWxldGUocHJvamVjdHMpLndoZXJlKGVxKHByb2plY3RzLmlkLCBwcm9qZWN0SWQpKTtcbiAgICBjb25zb2xlLmxvZyhgW0V2YWx1YXRpb25SdW5uZXJdIERlbGV0ZWQgcHJvamVjdDogJHtwcm9qZWN0SWR9YCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW0V2YWx1YXRpb25SdW5uZXJdIEZhaWxlZCB0byBjbGVhbnVwIGV2YWx1YXRpb24gZGF0YTpgLCBlcnJvcik7XG4gICAgLy8gRG9uJ3QgdGhyb3cgLSBjbGVhbnVwIGZhaWx1cmVzIHNob3VsZG4ndCBmYWlsIHRoZSBldmFsdWF0aW9uXG4gIH1cbn1cblxuLyoqXG4gKiBSdW4gZXZhbHVhdGlvbiB3aXRoIHByb3BlciBjb250ZXh0IGFuZCBlbmhhbmNlZCBlcnJvciBoYW5kbGluZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuRXZhbHVhdGlvbihzY2VuYXJpbzogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgbGV0IGNvbnRleHQ6IEV2YWx1YXRpb25Db250ZXh0IHwgbnVsbCA9IG51bGw7XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBbRXZhbHVhdGlvblJ1bm5lcl0gU3RhcnRpbmcgZXZhbHVhdGlvbjogJHtzY2VuYXJpby5uYW1lfWApO1xuICAgIFxuICAgIC8vIFByZXBhcmUgZXZhbHVhdGlvbiBjb250ZXh0IHdpdGggREIgcmVjb3Jkc1xuICAgIGNvbnRleHQgPSBhd2FpdCBwcmVwYXJlRXZhbHVhdGlvbkNvbnRleHQoc2NlbmFyaW8pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBvcmNoZXN0cmF0b3IgaW5zdGFuY2VcbiAgICAvLyBUT0RPOiBVcGRhdGUgdG8gdXNlIG5ldyBvcmNoZXN0cmF0b3JORVdcbiAgICAvLyBjb25zdCBvcmNoZXN0cmF0b3IgPSBuZXcgQnJhaW5PcmNoZXN0cmF0b3IoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmFsIHJ1bm5lciBuZWVkcyB0byBiZSB1cGRhdGVkIHRvIHVzZSBuZXcgYXJjaGl0ZWN0dXJlXCIpO1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgdGhlIGJyYWluIG9yY2hlc3RyYXRvclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3JjaGVzdHJhdG9yLnByb2Nlc3NVc2VySW5wdXQoe1xuICAgICAgcHJvbXB0OiBzY2VuYXJpby5pbnB1dC51c2VyUHJvbXB0LFxuICAgICAgc3Rvcnlib2FyZFNvRmFyOiBjb250ZXh0LnN0b3J5Ym9hcmQsXG4gICAgICBjaGF0SGlzdG9yeTogY29udGV4dC5jaGF0SGlzdG9yeSxcbiAgICAgIHByb2plY3RJZDogY29udGV4dC5wcm9qZWN0SWQsXG4gICAgICB1c2VySWQ6ICdldmFsLXVzZXItJyArIGNyeXB0by5yYW5kb21VVUlEKClcbiAgICB9KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW0V2YWx1YXRpb25SdW5uZXJdIFJhdyBvcmNoZXN0cmF0b3IgcmVzcG9uc2U6YCwgcmVzcG9uc2UpO1xuICAgIFxuICAgIC8vIEhhbmRsZSBPcmNoZXN0cmF0aW9uT3V0cHV0IGZvcm1hdFxuICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiByZXNwb25zZS5lcnJvciB8fCAnT3JjaGVzdHJhdG9yIGV4ZWN1dGlvbiBmYWlsZWQnLFxuICAgICAgICByYXdSZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgIHNjZW5hcmlvOiBzY2VuYXJpby5uYW1lXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXR1cm4gZXZhbHVhdGlvbiByZXN1bHQgd2l0aCBvcmNoZXN0cmF0b3Igb3V0cHV0XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UsIC8vIFJldHVybiB0aGUgZnVsbCBPcmNoZXN0cmF0aW9uT3V0cHV0XG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIHByb2plY3RJZDogY29udGV4dC5wcm9qZWN0SWQsXG4gICAgICAgIHN0b3J5Ym9hcmRMZW5ndGg6IGNvbnRleHQuc3Rvcnlib2FyZC5sZW5ndGgsXG4gICAgICAgIGNoYXRIaXN0b3J5TGVuZ3RoOiBjb250ZXh0LmNoYXRIaXN0b3J5Lmxlbmd0aFxuICAgICAgfSxcbiAgICAgIHNjZW5hcmlvOiBzY2VuYXJpby5uYW1lLFxuICAgICAgdG9vbFVzZWQ6IHJlc3BvbnNlLnRvb2xVc2VkLFxuICAgICAgcmVhc29uaW5nOiByZXNwb25zZS5yZWFzb25pbmcsXG4gICAgICBjaGF0UmVzcG9uc2U6IHJlc3BvbnNlLmNoYXRSZXNwb25zZVxuICAgIH07XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW0V2YWx1YXRpb25SdW5uZXJdIEV2YWx1YXRpb24gZmFpbGVkOmAsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICBzY2VuYXJpbzogc2NlbmFyaW8ubmFtZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQgPyB7XG4gICAgICAgIHByb2plY3RJZDogY29udGV4dC5wcm9qZWN0SWQsXG4gICAgICAgIHN0b3J5Ym9hcmRMZW5ndGg6IGNvbnRleHQuc3Rvcnlib2FyZC5sZW5ndGgsXG4gICAgICAgIGNoYXRIaXN0b3J5TGVuZ3RoOiBjb250ZXh0LmNoYXRIaXN0b3J5Lmxlbmd0aFxuICAgICAgfSA6IG51bGxcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEFsd2F5cyBjbGVhbnVwIGV2YWx1YXRpb24gZGF0YVxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBhd2FpdCBjbGVhbnVwRXZhbHVhdGlvbkRhdGEoY29udGV4dC5wcm9qZWN0SWQpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyeXB0byIsIk1PREVMX1BBQ0tTIiwiQUlDbGllbnRTZXJ2aWNlIiwiZGIiLCJzY2VuZXMiLCJwcm9qZWN0cyIsInVzZXJzIiwiZXEiLCJFdmFsdWF0aW9uUnVubmVyIiwiY29uc3RydWN0b3IiLCJjdXJyZW50TW9kZWxQYWNrIiwiYWlDbGllbnQiLCJydW5TdWl0ZSIsImNvbmZpZyIsImNvbnNvbGUiLCJsb2ciLCJzdWl0ZUlkIiwibW9kZWxQYWNrcyIsImxlbmd0aCIsImpvaW4iLCJzdWl0ZSIsImxvYWRTdWl0ZSIsInByb21wdHMiLCJtYXhQcm9tcHRzIiwic2xpY2UiLCJhbGxSZXN1bHRzIiwiY29tcGFyaXNvblJlc3VsdHMiLCJuYW1lIiwicHJvbXB0IiwicHJvbXB0UmVzdWx0cyIsIm1vZGVsUGFja0lkIiwicmVzdWx0IiwicnVuU2luZ2xlUHJvbXB0IiwidmVyYm9zZSIsInB1c2giLCJzaG93T3V0cHV0cyIsImRpc3BsYXlQcm9tcHRPdXRwdXQiLCJlcnJvciIsImVycm9yUmVzdWx0IiwicHJvbXB0SWQiLCJpZCIsIm1vZGVsUGFjayIsIm1vZGVsS2V5IiwicHJvdmlkZXIiLCJtb2RlbCIsIm91dHB1dCIsImFjdHVhbE91dHB1dCIsInN1Y2Nlc3MiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJtZXRyaWNzIiwibGF0ZW5jeSIsImNvc3QiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb21wYXJpc29uIiwiZ2VuZXJhdGVDb21wYXJpc29uIiwic3VtbWFyeSIsImdlbmVyYXRlU3VtbWFyeSIsImRpc3BsYXlDb21wYXJpc29uIiwicmVzdWx0cyIsInVuZGVmaW5lZCIsInR5cGUiLCJzdGFydFRpbWUiLCJub3ciLCJwcm9jZXNzIiwiZW52IiwiQUNUSVZFX01PREVMX1BBQ0siLCJyZXNwb25zZSIsInRvb2xzVXNlZCIsImNvZGVPdXRwdXQiLCJpbWFnZUFuYWx5c2lzIiwiY29udGV4dCIsInByZXBhcmVDb250ZXh0IiwicHJvamVjdElkIiwicmFuZG9tVVVJRCIsInVzZXJJZCIsImluc2VydCIsInZhbHVlcyIsImVtYWlsIiwiZW1haWxWZXJpZmllZCIsImltYWdlIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0Iiwib25Db25mbGljdERvTm90aGluZyIsInRpdGxlIiwicHJvcHMiLCJtZXRhIiwiZHVyYXRpb24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJpc1dlbGNvbWUiLCJkYkVycm9yIiwic3Rvcnlib2FyZFNvRmFyIiwic2NlbmUiLCJ0c3hDb2RlIiwib3JkZXIiLCJpbnB1dCIsImltYWdlVXJsIiwic3Vic3RyaW5nIiwidG9vbFVzZWQiLCJzY2VuZUNvZGUiLCJtb2RlbHMiLCJicmFpbiIsInJlYXNvbmluZyIsImVzdGltYXRlQ29zdCIsImNoYXRSZXNwb25zZSIsImRlbGV0ZSIsIndoZXJlIiwiY2xlYW51cEVycm9yIiwid2FybiIsIk9iamVjdCIsImFzc2lnbiIsImV4aXN0aW5nQ29kZSIsInNjZW5lSWQiLCJzY2VuZU5hbWUiLCJjaGF0SGlzdG9yeSIsImV4cGVjdGVkQmVoYXZpb3IiLCJlZGl0VHlwZSIsInJvbGUiLCJjb250ZW50IiwidGV4dCIsImVkaXRDb21wbGV4aXR5IiwidG9GaXhlZCIsImFuYWx5c2lzIiwic3BlZWRSYW5raW5nIiwiZW50cmllcyIsImZpbHRlciIsInIiLCJzb3J0IiwiYSIsImIiLCJtYXAiLCJwYWNrIiwiY29zdEVmZmljaWVuY3kiLCJjb2RlUXVhbGl0eSIsIm92ZXJhbGxSYW5raW5nIiwic2NvcmUiLCJpdGVtIiwid2lubmVyIiwicmVhc29uIiwic2NvcmVzIiwic3BlZWQiLCJpbmRleE9mIiwicXVhbGl0eSIsImFjY3VyYWN5IiwicHJvbXB0TmFtZSIsImNvbXBhcmlzb25zIiwiY29tcCIsInRvdGFsVGVzdHMiLCJzdWNjZXNzZnVsVGVzdHMiLCJhdmVyYWdlTGF0ZW5jeSIsInJlZHVjZSIsInN1bSIsInRvdGFsQ29zdCIsImVycm9yUmF0ZSIsIm1vZGVsUGFja1BlcmZvcm1hbmNlIiwicGFja1Jlc3VsdHMiLCJwYWNrU3VjY2Vzc2VzIiwiZXJyb3JzIiwic3VjY2Vzc1JhdGUiLCJNYXRoIiwicm91bmQiLCJnZXRTdWl0ZSIsImlucHV0VG9rZW5zIiwiY2VpbCIsIm91dHB1dFRva2VucyIsImluY2x1ZGVzIiwiZXZhbHVhdGlvblJ1bm5lciIsInBhcnNlSlNPTlJlc3BvbnNlIiwiY2xlYW5Db250ZW50IiwidHJpbSIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwiSlNPTiIsInBhcnNlIiwib3JpZ2luYWxDb250ZW50IiwiY2xlYW5lZENvbnRlbnQiLCJqc29uTWF0Y2giLCJtYXRjaCIsInNlY29uZEVycm9yIiwiY3JlYXRlRXZhbHVhdGlvblByb2plY3QiLCJwcm9qZWN0RGF0YSIsImNyZWF0ZUV2YWx1YXRpb25TY2VuZXMiLCJzY2VuZXNEYXRhIiwic2NlbmVEYXRhIiwiY29kZSIsImR1cmF0aW9uRnJhbWVzIiwicHJlcGFyZUV2YWx1YXRpb25Db250ZXh0Iiwic2NlbmFyaW8iLCJkZXNjcmlwdGlvbiIsInN0b3J5Ym9hcmQiLCJpbmNsdWRlU2NlbmVzIiwiaXNUZW1wbGF0ZSIsIm1zZyIsImluZGV4IiwiY2xlYW51cEV2YWx1YXRpb25EYXRhIiwicnVuRXZhbHVhdGlvbiIsIm9yY2hlc3RyYXRvciIsInByb2Nlc3NVc2VySW5wdXQiLCJ1c2VyUHJvbXB0IiwicmF3UmVzcG9uc2UiLCJzdG9yeWJvYXJkTGVuZ3RoIiwiY2hhdEhpc3RvcnlMZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/evals/runner.ts\n");

/***/ })

};
;