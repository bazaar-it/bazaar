# Token-Driven Brand Variants — Considerations & Trade-offs

## Prompt
Design a B2B “personalize-at-scale” workflow where one master Remotion video can generate 50–500 client-specific variants without hitting the LLM for each edit. Investigate whether scenes can consume a brand JSON instead of being rewritten per export, and map out the risks, gaps, and implementation trade-offs.

---

## 1. Architectural Baseline
- **Current state**
  - Scenes are plain TSX generated by tools. Many embed literal colors, font names, and asset URLs.
  - Rendering accepts scene props, but most scenes don’t expect external theme objects; they read constants or inline hex values.
  - Brand data exists in `brand_profile.brandData` (colors, typography, logos, etc.), produced by `extractBrandProfile`.
  - Website pipeline regenerates scenes per brand via LLM/template customization; no shared token layer.
- **Goal state**
  - Master project renders with a `BrandThemeProvider` supplying tokens.
  - Per-client variant = master scenes + brand JSON injected at render time.
  - Export pipeline pulls the theme from variant config, not from rewritten code.

**Gap**: we need deterministic token plumbing inside scenes plus a render service that can inject per-run props.

---

## 2. Brand Theme Contract
- **Proposed interface** (to live in `src/lib/theme/brandTheme.ts`):
  ```ts
  interface BrandTheme {
    colors: {
      primary: string;
      secondary: string;
      accents: string[];
      highlight: string;
      background: string;
      textDefault: string;
    };
    fonts: {
      heading: FontSpec;
      body: FontSpec;
      mono?: FontSpec;
    };
    assets: {
      logo?: {
        light?: string;
        dark?: string;
        monochrome?: string;
      };
      productShots?: string[];
    };
    iconStyle: 'line' | 'solid' | 'duotone';
    backgroundEffects: string[];
    motionPreferences?: {
      speedScale?: number;
      easings?: string[];
    };
    copyOverrides?: Record<string, string>;
  }
  ```
- **Mapping**: Derived from `brand_profile.brandData`; require a normalization step (`BrandTheme.fromBrandProfile(profile)`).
- **Trade-off**: Strict schema improves determinism but may not capture every bespoke visual nuance. Need extensibility without breaking type safety.

---

## 3. Scene Refactor Impact
- Must audit generated scenes to remove literal styling. Key changes:
  - Replace inline hex codes with `theme.colors.*`.
  - Replace `font-family` strings with `theme.fonts.heading.family` etc.
  - Swap logos/icons for `<BrandLogo variant="light" />` wrappers.
- **Cost**: Manual refactor of existing templates (time-consuming). For LLM-generated new scenes, update prompts to emit theme-aware code.
- **Risk**: If a scene assumes specific colors (e.g., gradient background), generic tokens may degrade design quality. Need fallback paths (e.g., if accent missing, derive from primary).

Mitigation: enforce lint rule that forbids hard-coded brand colors. Add unit tests comparing rendered CSS to theme values.

---

## 4. Rendering Pipeline Changes
- **Current**: `RenderService.queueProjectRender(projectId)` pulls scenes as stored.
- **Proposed**: Accept `renderProps.brandTheme` and inject into Remotion render call:
  ```ts
  renderVideo({ projectId, props: { brandTheme, variantId } });
  ```
- Need deterministic serialization (strip functions, ensure small payload). Store theme JSON alongside export metadata for reproducibility.
- **Trade-off**: Larger render payload per job (~5-20 KB). Minimal cost relative to video assets.

---

## 5. Variant Storage Strategy
- **Option A – Clone Projects**
  - Duplicate scenes per variant.
  - Pros: minimal infra changes.
  - Cons: explodes `projects` table (500 variants per campaign), harder to manage.
- **Option B – Variant Table** (recommended)
  - Keep master scenes. Create `project_variants` table storing `variantId`, `masterProjectId`, `brandThemeJson`, `status`, `exportId`.
  - Pros: lightweight, easier reporting, avoids cluttering user UI.
  - Cons: new surfaces for editing/downloading variants.

---

## 6. Orchestration Choices
- **n8n**: Quick to wire (CSV ingest → API calls → render queue). Good for low-frequency batches but limited visibility and retry control.
- **Internal worker (BullMQ/Temporal)**: Higher engineering lift but better scaling, retries, metrics. Recommended if we expect regular 200+ runs.
- **API entrypoint**: Build `/api/bulk-brand/submit` that accepts CSV/JSON, enqueues jobs, returns batchId. UI polls for progress.

Trade-off = speed vs robustness; choose based on GTM needs.

---

## 7. Brand Extraction Reliability
- Puppeteer/EnhancedWebAnalyzer must cope with:
  - Auth walls / cookie banners.
  - Dark-mode sites with inverted palettes.
  - Missing or raster-only logos.
- Consider fallback strategies:
  - If fonts inaccessible, default to Inter.
  - Generate color palette from dominant hues via screenshot analysis (color-thief).
- **Caching**: Store extracted artifacts in R2 (`brand-profiles/{company}`) to avoid re-scraping.
- **Rate limits**: throttle to 2–3 concurrent scrapes; respect robots.txt; log failures per company.

---

## 8. Testing & QA Requirements
- **Snapshot Tests**: For a set of brand fixtures, render hero frame → compare via pixel diff with tolerance.
- **Token Coverage Test**: Ensure every scene references theme tokens (eslint rule + jest check scanning compiled code).
- **Render Stress Test**: Simulate 100 queued variants; verify Lambda concurrency caps and export tracking.
- **Fallback Validation**: When brand JSON missing fields, ensure default theme keeps video legible.

Trade-off: Higher test complexity but essential to prevent brand bleed-over.

---

## 9. UX & Delivery
- Provide a dedicated “Personalize for Clients” dashboard separate from chat.
- Upload list (CSV / JSON / direct input). Show processing status, per-company logs, download links (individual + zip). Optionally send auto emails.
- Allow manual override: user can tweak a company’s theme before render if extractor misreads brand.

---

## 10. Trade-off Summary
| Decision | Pros | Cons | Notes |
| --- | --- | --- | --- |
| Tokenized scenes vs LLM edits | Deterministic, fast, cheap | Requires scene refactor + LLM prompt updates | Must enforce lint/tests |
| Variant table vs cloned projects | Lean storage, clearer UX | New data model + UI work | Recommended |
| n8n orchestrator | Quick MVP | Limited observability | OK for pilot |
| Internal worker | Robust, scalable | Engineering time | For production scale |
| Aggressive scraping | Accurate brand capture | Legal/ethical, rate limits | Use cache, respect robots |
| Dedicated B2B UI | Tailored experience | Separate surface to maintain | Prevents confusion in main editor |

---

## 11. Rollout Plan (Phased)
1. **Phase 1**: Tokenize master templates; add BrandTheme provider; verify single theme swap works.
2. **Phase 2**: Build variant storage + render props injection; create admin-only bulk runner (CLI/n8n) processing <10 brands.
3. **Phase 3**: Launch dedicated bulk UI, add CSV ingestion, autop-run 50+ variants; integrate export tracking.
4. **Phase 4**: Harden for production: worker queue, retry logic, auto emailing, analytics.

---

## 12. Open Questions
- How much structural variation should brand JSON influence (e.g. background patterns)? Need guardrails to keep layout stable.
- Do we persist variants indefinitely or auto-expire after campaign ends? (Storage costs.)
- Should prospects receive personalized previews automatically (tie into email automation)?
- How to price/limit usage (credits per variant)?

---

## References
- `src/server/api/routers/website-pipeline.ts` — current brand extraction and project overwrite flow.
- `brand_profile.brandData` schema (`src/server/db/schema.ts:1579`).
- `memory-bank/sprints/sprint108_one_last_export/bulk-brand-customization-workflow.md` — orchestration outline.
- Sprint 27 brand extraction notes for historical context.
