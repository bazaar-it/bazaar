## The Core Insight
  Scenes are an artificial boundary that BREAKS video flow. The entire
  video should be ONE continuous component with logical sections for
  editing.

  ## The Problem We're Solving

  ### Current Architecture (Broken)
  ```typescript
  // Scene 1: Button at x=500 at frame 75
  // Scene 2: Button at x=0 at frame 76
  // Result: Button teleports! ðŸ’¥

  New Architecture (Smooth)

  // One continuous timeline
  const buttonX = interpolate(
    frame,
    [0, 75, 76, 150],      // Continuous!
    [0, 500, 500, 800]     // No jumps!
  );

  Implementation Plan

  Phase 1: Master Compilation (Week 1)

  // New compilation pipeline
  function compileToMasterVideo(sections: Section[]): MasterVideo {
    // 1. Extract all unique elements
    const elements = extractAllElements(sections);

    // 2. Build continuous timelines
    const timelines = buildContinuousTimelines(elements, sections);

    // 3. Generate master component
    return {
      jsCode: generateMasterComponent(timelines, sections),
      duration: calculateTotalDuration(sections),
      elements: elements
    };
  }

  Phase 2: Database Schema (Week 1)

  -- Master video storage
  ALTER TABLE projects
  ADD COLUMN master_code TEXT,
  ADD COLUMN master_compiled_at TIMESTAMP,
  ADD COLUMN total_duration INTEGER;

  -- Sections (replaces scenes)
  CREATE TABLE video_sections (
    id UUID PRIMARY KEY,
    project_id UUID REFERENCES projects(id),
    name VARCHAR(255),
    start_frame INTEGER,
    end_frame INTEGER,
    tsx_code TEXT,  -- Section content
    order_index INTEGER
  );

  -- Continuous elements tracking
  CREATE TABLE video_elements (
    id UUID PRIMARY KEY,
    project_id UUID REFERENCES projects(id),
    element_id VARCHAR(255),  -- 'heroButton', 'logo', etc
    timeline JSONB,  -- Full interpolation data
    sections TEXT[]  -- Which sections it appears in
  );

  Phase 3: The Master Component Generator

  function generateMasterComponent(
    timelines: Map<string, Timeline>,
    sections: Section[]
  ): string {
    return `
      export default function MasterVideo() {
        const frame = useCurrentFrame();
        
        // Continuous element interpolations
        ${Array.from(timelines.entries()).map(([id, timeline]) => `
          const ${id}X = interpolate(
            frame,
            [${timeline.keyframes.map(k => k.frame).join(', ')}],
            [${timeline.keyframes.map(k => k.x).join(', ')}]
          );
          const ${id}Y = interpolate(
            frame,
            [${timeline.keyframes.map(k => k.frame).join(', ')}],
            [${timeline.keyframes.map(k => k.y).join(', ')}]
          );
          const ${id}Scale = interpolate(
            frame,
            [${timeline.keyframes.map(k => k.frame).join(', ')}],
            [${timeline.keyframes.map(k => k.scale).join(', ')}]
          );
        `).join('\n')}
        
        return (
          <AbsoluteFill>
            ${sections.map(section => `
              {/* Section: ${section.name} */}
              {frame >= ${section.startFrame} && frame < 
  ${section.endFrame} && (
                <>
                  ${section.content}
                </>
              )}
            `).join('\n')}
          </AbsoluteFill>
        );
      }
    `;
  }

  Phase 4: Smart Element Tracking

  interface ElementLifecycle {
    id: string;
    type: 'button' | 'text' | 'image' | 'shape';

    // Full timeline across entire video
    timeline: {
      firstAppears: number;
      lastAppears: number;
      keyframes: Array<{
        frame: number;
        x: number;
        y: number;
        scale: number;
        rotation: number;
        opacity: number;
      }>;
    };

    // Automatic transition generation
    transitions: Array<{
      fromSection: string;
      toSection: string;
      type: 'smooth' | 'morph' | 'fade';
    }>;
  }

  Phase 5: AI Integration

  // AI gets FULL video context
  function prepareAIContext(project: Project): string {
    return `
      VIDEO STRUCTURE:
      Total Duration: ${project.totalDuration} frames
      
      SECTIONS:
      ${project.sections.map(s => 
        `${s.name}: frames ${s.startFrame}-${s.endFrame}`
      ).join('\n')}
      
      CONTINUOUS ELEMENTS:
      ${project.elements.map(e => `
        ${e.id}:
        - Appears: frames 
  ${e.timeline.firstAppears}-${e.timeline.lastAppears}
        - Current position at frame ${currentFrame}: x=${e.currentX}, 
  y=${e.currentY}
      `).join('\n')}
      
      IMPORTANT: Elements should flow continuously. 
      If Button ends at x=500 in section 1, 
      it should start at x=500 in section 2.
    `;
  }

  The User Experience

  What Changes for Users

  - Nothing in the UI! Still looks like scenes
  - Everything in the output! Smooth, professional videos

  Edit Flow

  // User: "Make the logo slide from intro to features"
  // System: Modifies the logo's continuous timeline
  // Result: Smooth transition across sections

  Benefits

  1. No More Duplicate Identifiers
    - Each element defined once
    - Referenced by ID across sections
  2. Automatic Smooth Transitions
    - Elements continue naturally
    - No teleporting
  3. Better AI Context
    - AI sees entire video
    - Can plan ahead
  4. Simpler Mental Model
    - Video = One story
    - Sections = Chapters

  Migration Strategy

  Week 1: Backend Only

  - Build master compilation
  - Keep existing UI
  - Test with new projects

  Week 2: Gradual Rollout

  - Feature flag for new projects
  - Migrate simple projects
  - Monitor performance

  Week 3: Full Migration

  - Convert all projects
  - Update AI prompts
  - Remove old scene system

  Success Metrics

  - Transition smoothness: 100% (no jumps)
  - Compilation errors: -90%
  - AI retry rate: -75%
  - User satisfaction: "Finally, smooth videos!"

  Critical Code Example

  // Before: Isolated scenes
  Scene1: <Button x={500} />  // Frame 75
  Scene2: <Button x={0} />     // Frame 76 - JUMP!

  // After: Continuous video
  MasterVideo: {
    const buttonX = interpolate(
      frame,
      [0, 75, 76, 150],
      [0, 500, 500, 800]  // Continuous motion
    );

    return <Button x={buttonX} />;
  }

  This is it. This is the fix for:
  - Compilation errors (no duplicate identifiers)
  - Jarring transitions (continuous interpolation)
  - AI confusion (full context)
  - User frustration (smooth videos)

  **The key insight**: Scenes are for EDITING. The video is ONE CONTINUOUS
   EXPERIENCE.